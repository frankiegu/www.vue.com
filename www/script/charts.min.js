/*!
 * 
 * -------------------------------------------------------------
 * 本人保留所有版权与权利.
 * 
 * https://github.com/ningxiao
 * @version: 1.0.0
 * @author: ningxiao
 * @qq:363305175
 * @description:  VUE_TEST
 * @date: 2017/11/14 10:50:52
 * -------------------------------------------------------------
 */
webpackJsonp([3],{

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = clone;
/* harmony export (immutable) */ __webpack_exports__["w"] = merge;
/* harmony export (immutable) */ __webpack_exports__["x"] = mergeAll;
/* harmony export (immutable) */ __webpack_exports__["k"] = extend;
/* harmony export (immutable) */ __webpack_exports__["h"] = defaults;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return _createCanvas; });
/* harmony export (immutable) */ __webpack_exports__["m"] = getContext;
/* harmony export (immutable) */ __webpack_exports__["n"] = indexOf;
/* harmony export (immutable) */ __webpack_exports__["o"] = inherits;
/* harmony export (immutable) */ __webpack_exports__["y"] = mixin;
/* harmony export (immutable) */ __webpack_exports__["q"] = isArrayLike;
/* harmony export (immutable) */ __webpack_exports__["i"] = each;
/* harmony export (immutable) */ __webpack_exports__["v"] = map;
/* harmony export (immutable) */ __webpack_exports__["B"] = reduce;
/* harmony export (immutable) */ __webpack_exports__["l"] = filter;
/* unused harmony export find */
/* harmony export (immutable) */ __webpack_exports__["c"] = bind;
/* harmony export (immutable) */ __webpack_exports__["g"] = curry;
/* harmony export (immutable) */ __webpack_exports__["p"] = isArray;
/* harmony export (immutable) */ __webpack_exports__["s"] = isFunction;
/* harmony export (immutable) */ __webpack_exports__["u"] = isString;
/* harmony export (immutable) */ __webpack_exports__["t"] = isObject;
/* unused harmony export isBuiltInObject */
/* harmony export (immutable) */ __webpack_exports__["r"] = isDom;
/* harmony export (immutable) */ __webpack_exports__["j"] = eqNaN;
/* harmony export (immutable) */ __webpack_exports__["C"] = retrieve;
/* harmony export (immutable) */ __webpack_exports__["D"] = retrieve2;
/* harmony export (immutable) */ __webpack_exports__["E"] = retrieve3;
/* harmony export (immutable) */ __webpack_exports__["G"] = slice;
/* harmony export (immutable) */ __webpack_exports__["A"] = normalizeCssArray;
/* harmony export (immutable) */ __webpack_exports__["b"] = assert;
/* harmony export (immutable) */ __webpack_exports__["F"] = setAsPrimitive;
/* unused harmony export isPrimitive */
/* harmony export (immutable) */ __webpack_exports__["f"] = createHashMap;
/* harmony export (immutable) */ __webpack_exports__["z"] = noop;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return $inject; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var BUILTIN_OBJECT = {
    '[object Function]': 1,
    '[object RegExp]': 1,
    '[object Date]': 1,
    '[object Error]': 1,
    '[object CanvasGradient]': 1,
    '[object CanvasPattern]': 1,

    '[object Image]': 1,
    '[object Canvas]': 1
};

var TYPED_ARRAY = {
    '[object Int8Array]': 1,
    '[object Uint8Array]': 1,
    '[object Uint8ClampedArray]': 1,
    '[object Int16Array]': 1,
    '[object Uint16Array]': 1,
    '[object Int32Array]': 1,
    '[object Uint32Array]': 1,
    '[object Float32Array]': 1,
    '[object Float64Array]': 1
};

var objToString = Object.prototype.toString;

var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var nativeReduce = arrayProto.reduce;

function clone(source) {
    if (source == null || (typeof source === 'undefined' ? 'undefined' : _typeof(source)) != 'object') {
        return source;
    }

    var result = source;
    var typeStr = objToString.call(source);

    if (typeStr === '[object Array]') {
        result = [];
        for (var i = 0, len = source.length; i < len; i++) {
            result[i] = clone(source[i]);
        }
    } else if (TYPED_ARRAY[typeStr]) {
        var Ctor = source.constructor;
        if (source.constructor.from) {
            result = Ctor.from(source);
        } else {
            result = new Ctor(source.length);
            for (var i = 0, len = source.length; i < len; i++) {
                result[i] = clone(source[i]);
            }
        }
    } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
        result = {};
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                result[key] = clone(source[key]);
            }
        }
    }

    return result;
}

function merge(target, source, overwrite) {
    if (!isObject(source) || !isObject(target)) {
        return overwrite ? clone(source) : target;
    }

    for (var key in source) {
        if (source.hasOwnProperty(key)) {
            var targetProp = target[key];
            var sourceProp = source[key];

            if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
                merge(targetProp, sourceProp, overwrite);
            } else if (overwrite || !(key in target)) {
                target[key] = clone(source[key], true);
            }
        }
    }

    return target;
}

function mergeAll(targetAndSources, overwrite) {
    var result = targetAndSources[0];
    for (var i = 1, len = targetAndSources.length; i < len; i++) {
        result = merge(result, targetAndSources[i], overwrite);
    }
    return result;
}

function extend(target, source) {
    for (var key in source) {
        if (source.hasOwnProperty(key)) {
            target[key] = source[key];
        }
    }
    return target;
}

function defaults(target, source, overlay) {
    for (var key in source) {
        if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
            target[key] = source[key];
        }
    }
    return target;
}

var _createCanvas = function createCanvas() {
    return document.createElement('canvas');
};



var _ctx;

function getContext() {
    if (!_ctx) {
        _ctx = _createCanvas().getContext('2d');
    }
    return _ctx;
}

function indexOf(array, value) {
    if (array) {
        if (array.indexOf) {
            return array.indexOf(value);
        }
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] === value) {
                return i;
            }
        }
    }
    return -1;
}

function inherits(clazz, baseClazz) {
    var clazzPrototype = clazz.prototype;
    function F() {}
    F.prototype = baseClazz.prototype;
    clazz.prototype = new F();

    for (var prop in clazzPrototype) {
        clazz.prototype[prop] = clazzPrototype[prop];
    }
    clazz.prototype.constructor = clazz;
    clazz.superClass = baseClazz;
}

function mixin(target, source, overlay) {
    target = 'prototype' in target ? target.prototype : target;
    source = 'prototype' in source ? source.prototype : source;

    defaults(target, source, overlay);
}

function isArrayLike(data) {
    if (!data) {
        return;
    }
    if (typeof data == 'string') {
        return false;
    }
    return typeof data.length == 'number';
}

function each(obj, cb, context) {
    if (!(obj && cb)) {
        return;
    }
    if (obj.forEach && obj.forEach === nativeForEach) {
        obj.forEach(cb, context);
    } else if (obj.length === +obj.length) {
        for (var i = 0, len = obj.length; i < len; i++) {
            cb.call(context, obj[i], i, obj);
        }
    } else {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                cb.call(context, obj[key], key, obj);
            }
        }
    }
}

function map(obj, cb, context) {
    if (!(obj && cb)) {
        return;
    }
    if (obj.map && obj.map === nativeMap) {
        return obj.map(cb, context);
    } else {
        var result = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            result.push(cb.call(context, obj[i], i, obj));
        }
        return result;
    }
}

function reduce(obj, cb, memo, context) {
    if (!(obj && cb)) {
        return;
    }
    if (obj.reduce && obj.reduce === nativeReduce) {
        return obj.reduce(cb, memo, context);
    } else {
        for (var i = 0, len = obj.length; i < len; i++) {
            memo = cb.call(context, memo, obj[i], i, obj);
        }
        return memo;
    }
}

function filter(obj, cb, context) {
    if (!(obj && cb)) {
        return;
    }
    if (obj.filter && obj.filter === nativeFilter) {
        return obj.filter(cb, context);
    } else {
        var result = [];
        for (var i = 0, len = obj.length; i < len; i++) {
            if (cb.call(context, obj[i], i, obj)) {
                result.push(obj[i]);
            }
        }
        return result;
    }
}

function find(obj, cb, context) {
    if (!(obj && cb)) {
        return;
    }
    for (var i = 0, len = obj.length; i < len; i++) {
        if (cb.call(context, obj[i], i, obj)) {
            return obj[i];
        }
    }
}

function bind(func, context) {
    var args = nativeSlice.call(arguments, 2);
    return function () {
        return func.apply(context, args.concat(nativeSlice.call(arguments)));
    };
}

function curry(func) {
    var args = nativeSlice.call(arguments, 1);
    return function () {
        return func.apply(this, args.concat(nativeSlice.call(arguments)));
    };
}

function isArray(value) {
    return objToString.call(value) === '[object Array]';
}

function isFunction(value) {
    return typeof value === 'function';
}

function isString(value) {
    return objToString.call(value) === '[object String]';
}

function isObject(value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    return type === 'function' || !!value && type == 'object';
}

function isBuiltInObject(value) {
    return !!BUILTIN_OBJECT[objToString.call(value)];
}

function isDom(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && typeof value.nodeType === 'number' && _typeof(value.ownerDocument) === 'object';
}

function eqNaN(value) {
    return value !== value;
}

function retrieve(values) {
    for (var i = 0, len = arguments.length; i < len; i++) {
        if (arguments[i] != null) {
            return arguments[i];
        }
    }
}

function retrieve2(value0, value1) {
    return value0 != null ? value0 : value1;
}

function retrieve3(value0, value1, value2) {
    return value0 != null ? value0 : value1 != null ? value1 : value2;
}

function slice() {
    return Function.call.apply(nativeSlice, arguments);
}

function normalizeCssArray(val) {
    if (typeof val === 'number') {
        return [val, val, val, val];
    }
    var len = val.length;
    if (len === 2) {
        return [val[0], val[1], val[0], val[1]];
    } else if (len === 3) {
        return [val[0], val[1], val[2], val[1]];
    }
    return val;
}

function assert(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}

var primitiveKey = '__ec_primitive__';

function setAsPrimitive(obj) {
    obj[primitiveKey] = true;
}

function isPrimitive(obj) {
    return obj[primitiveKey];
}

function HashMap(obj) {
    obj && each(obj, function (value, key) {
        this.set(key, value);
    }, this);
}

var HASH_MAP_PREFIX = '_ec_';
var HASH_MAP_PREFIX_LENGTH = 4;

HashMap.prototype = {
    constructor: HashMap,

    get: function get(key) {
        return this[HASH_MAP_PREFIX + key];
    },
    set: function set(key, value) {
        this[HASH_MAP_PREFIX + key] = value;

        return value;
    },

    each: function each(cb, context) {
        context !== void 0 && (cb = bind(cb, context));
        for (var prefixedKey in this) {
            this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));
        }
    },

    removeKey: function removeKey(key) {
        delete this[HASH_MAP_PREFIX + key];
    }
};

function createHashMap(obj) {
    return new HashMap(obj);
}

function noop() {}

var $inject = {
    createCanvas: function createCanvas(f) {
        _createCanvas = f;
    }
};

/***/ }),

/***/ 1:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/zrender/src/core/util.js
var util = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Path.js + 7 modules
var Path = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/PathProxy.js + 1 modules
var PathProxy = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/vector.js
var vector = __webpack_require__(5);

// CONCATENATED MODULE: ./node_modules/zrender/src/tool/transformPath.js



var transformPath_CMD = PathProxy["a" /* default */].CMD;

var transformPath_points = [[], [], []];
var mathSqrt = Math.sqrt;
var mathAtan2 = Math.atan2;

/* harmony default export */ var transformPath = (function (path, m) {
    var data = path.data;
    var cmd;
    var nPoint;
    var i;
    var j;
    var k;
    var p;

    var M = transformPath_CMD.M;
    var C = transformPath_CMD.C;
    var L = transformPath_CMD.L;
    var R = transformPath_CMD.R;
    var A = transformPath_CMD.A;
    var Q = transformPath_CMD.Q;

    for (i = 0, j = 0; i < data.length;) {
        cmd = data[i++];
        j = i;
        nPoint = 0;

        switch (cmd) {
            case M:
                nPoint = 1;
                break;
            case L:
                nPoint = 1;
                break;
            case C:
                nPoint = 3;
                break;
            case Q:
                nPoint = 2;
                break;
            case A:
                var x = m[4];
                var y = m[5];
                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
                var angle = mathAtan2(-m[1] / sy, m[0] / sx);

                data[i] *= sx;
                data[i++] += x;

                data[i] *= sy;
                data[i++] += y;

                data[i++] *= sx;
                data[i++] *= sy;

                data[i++] += angle;

                data[i++] += angle;

                i += 2;
                j = i;
                break;
            case R:
                p[0] = data[i++];
                p[1] = data[i++];
                Object(vector["b" /* applyTransform */])(p, p, m);
                data[j++] = p[0];
                data[j++] = p[1];

                p[0] += data[i++];
                p[1] += data[i++];
                Object(vector["b" /* applyTransform */])(p, p, m);
                data[j++] = p[0];
                data[j++] = p[1];
        }

        for (k = 0; k < nPoint; k++) {
            var p = transformPath_points[k];
            p[0] = data[i++];
            p[1] = data[i++];

            Object(vector["b" /* applyTransform */])(p, p, m);

            data[j++] = p[0];
            data[j++] = p[1];
        }
    }
});
// CONCATENATED MODULE: ./node_modules/zrender/src/tool/path.js




var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];

var path_mathSqrt = Math.sqrt;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI = Math.PI;

var vMag = function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
};
var vRatio = function vRatio(u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
};
var vAngle = function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
};

function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
    var psi = psiDeg * (PI / 180.0);
    var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;
    var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;

    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

    if (lambda > 1) {
        rx *= path_mathSqrt(lambda);
        ry *= path_mathSqrt(lambda);
    }

    var f = (fa === fs ? -1 : 1) * path_mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;

    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;

    var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;
    var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;

    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);

    if (vRatio(u, v) <= -1) {
        dTheta = PI;
    }
    if (vRatio(u, v) >= 1) {
        dTheta = 0;
    }
    if (fs === 0 && dTheta > 0) {
        dTheta = dTheta - 2 * PI;
    }
    if (fs === 1 && dTheta < 0) {
        dTheta = dTheta + 2 * PI;
    }

    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}

function createPathProxyFromString(data) {
    if (!data) {
        return [];
    }

    var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');

    var n;

    for (n = 0; n < cc.length; n++) {
        cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
    }

    var arr = cs.split('|');

    var cpx = 0;
    var cpy = 0;

    var path = new PathProxy["a" /* default */]();
    var CMD = PathProxy["a" /* default */].CMD;

    var prevCmd;
    for (n = 1; n < arr.length; n++) {
        var str = arr[n];
        var c = str.charAt(0);
        var off = 0;
        var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
        var cmd;

        if (p.length > 0 && p[0] === '') {
            p.shift();
        }

        for (var i = 0; i < p.length; i++) {
            p[i] = parseFloat(p[i]);
        }
        while (off < p.length && !isNaN(p[off])) {
            if (isNaN(p[0])) {
                break;
            }
            var ctlPtx;
            var ctlPty;

            var rx;
            var ry;
            var psi;
            var fa;
            var fs;

            var x1 = cpx;
            var y1 = cpy;

            switch (c) {
                case 'l':
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'L':
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'm':
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.M;
                    path.addData(cmd, cpx, cpy);
                    c = 'l';
                    break;
                case 'M':
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.M;
                    path.addData(cmd, cpx, cpy);
                    c = 'L';
                    break;
                case 'h':
                    cpx += p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'H':
                    cpx = p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'v':
                    cpy += p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'V':
                    cpy = p[off++];
                    cmd = CMD.L;
                    path.addData(cmd, cpx, cpy);
                    break;
                case 'C':
                    cmd = CMD.C;
                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
                    cpx = p[off - 2];
                    cpy = p[off - 1];
                    break;
                case 'c':
                    cmd = CMD.C;
                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
                    cpx += p[off - 2];
                    cpy += p[off - 1];
                    break;
                case 'S':
                    ctlPtx = cpx;
                    ctlPty = cpy;
                    var len = path.len();
                    var pathData = path.data;
                    if (prevCmd === CMD.C) {
                        ctlPtx += cpx - pathData[len - 4];
                        ctlPty += cpy - pathData[len - 3];
                    }
                    cmd = CMD.C;
                    x1 = p[off++];
                    y1 = p[off++];
                    cpx = p[off++];
                    cpy = p[off++];
                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
                    break;
                case 's':
                    ctlPtx = cpx;
                    ctlPty = cpy;
                    var len = path.len();
                    var pathData = path.data;
                    if (prevCmd === CMD.C) {
                        ctlPtx += cpx - pathData[len - 4];
                        ctlPty += cpy - pathData[len - 3];
                    }
                    cmd = CMD.C;
                    x1 = cpx + p[off++];
                    y1 = cpy + p[off++];
                    cpx += p[off++];
                    cpy += p[off++];
                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
                    break;
                case 'Q':
                    x1 = p[off++];
                    y1 = p[off++];
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.Q;
                    path.addData(cmd, x1, y1, cpx, cpy);
                    break;
                case 'q':
                    x1 = p[off++] + cpx;
                    y1 = p[off++] + cpy;
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.Q;
                    path.addData(cmd, x1, y1, cpx, cpy);
                    break;
                case 'T':
                    ctlPtx = cpx;
                    ctlPty = cpy;
                    var len = path.len();
                    var pathData = path.data;
                    if (prevCmd === CMD.Q) {
                        ctlPtx += cpx - pathData[len - 4];
                        ctlPty += cpy - pathData[len - 3];
                    }
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.Q;
                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
                    break;
                case 't':
                    ctlPtx = cpx;
                    ctlPty = cpy;
                    var len = path.len();
                    var pathData = path.data;
                    if (prevCmd === CMD.Q) {
                        ctlPtx += cpx - pathData[len - 4];
                        ctlPty += cpy - pathData[len - 3];
                    }
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.Q;
                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
                    break;
                case 'A':
                    rx = p[off++];
                    ry = p[off++];
                    psi = p[off++];
                    fa = p[off++];
                    fs = p[off++];

                    x1 = cpx, y1 = cpy;
                    cpx = p[off++];
                    cpy = p[off++];
                    cmd = CMD.A;
                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
                    break;
                case 'a':
                    rx = p[off++];
                    ry = p[off++];
                    psi = p[off++];
                    fa = p[off++];
                    fs = p[off++];

                    x1 = cpx, y1 = cpy;
                    cpx += p[off++];
                    cpy += p[off++];
                    cmd = CMD.A;
                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
                    break;
            }
        }

        if (c === 'z' || c === 'Z') {
            cmd = CMD.Z;
            path.addData(cmd);
        }

        prevCmd = cmd;
    }

    path.toStatic();

    return path;
}

function createPathOptions(str, opts) {
    var pathProxy = createPathProxyFromString(str);
    opts = opts || {};
    opts.buildPath = function (path) {
        if (path.setData) {
            path.setData(pathProxy.data);

            var ctx = path.getContext();
            if (ctx) {
                path.rebuildPath(ctx);
            }
        } else {
            var ctx = path;
            pathProxy.rebuildPath(ctx);
        }
    };

    opts.applyTransform = function (m) {
        transformPath(pathProxy, m);

        this.dirty(true);
    };

    return opts;
}

function createFromString(str, opts) {
    return new Path["a" /* default */](createPathOptions(str, opts));
}

function extendFromString(str, opts) {
    return Path["a" /* default */].extend(createPathOptions(str, opts));
}

function mergePath(pathEls, opts) {
    var pathList = [];
    var len = pathEls.length;
    for (var i = 0; i < len; i++) {
        var pathEl = pathEls[i];
        if (!pathEl.path) {
            pathEl.createPathProxy();
        }
        if (pathEl.__dirtyPath) {
            pathEl.buildPath(pathEl.path, pathEl.shape, true);
        }
        pathList.push(pathEl.path);
    }

    var pathBundle = new Path["a" /* default */](opts);

    pathBundle.createPathProxy();
    pathBundle.buildPath = function (path) {
        path.appendPath(pathList);

        var ctx = path.getContext();
        if (ctx) {
            path.rebuildPath(ctx);
        }
    };

    return pathBundle;
}
// EXTERNAL MODULE: ./node_modules/zrender/src/tool/color.js
var tool_color = __webpack_require__(40);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/matrix.js
var matrix = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/zrender/src/mixin/Transformable.js
var Transformable = __webpack_require__(93);

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Image.js
var Image = __webpack_require__(99);

// EXTERNAL MODULE: ./node_modules/zrender/src/container/Group.js
var Group = __webpack_require__(39);

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Displayable.js + 1 modules
var Displayable = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/zrender/src/contain/text.js
var contain_text = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/helper/text.js
var helper_text = __webpack_require__(100);

// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/Text.js





var Text_Text = function Text(opts) {
    Displayable["a" /* default */].call(this, opts);
};

Text_Text.prototype = {

    constructor: Text_Text,

    type: 'text',

    brush: function brush(ctx, prevEl) {
        var style = this.style;

        this.__dirty && helper_text["c" /* normalizeTextStyle */](style, true);

        style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;

        var text = style.text;

        text != null && (text += '');

        style.bind(ctx, this, prevEl);

        if (!helper_text["b" /* needDrawText */](text, style)) {
            return;
        }

        this.setTransform(ctx);

        helper_text["d" /* renderText */](this, ctx, text, style);

        this.restoreTransform(ctx);
    },

    getBoundingRect: function getBoundingRect() {
        var style = this.style;

        this.__dirty && helper_text["c" /* normalizeTextStyle */](style, true);

        if (!this._rect) {
            var text = style.text;
            text != null ? text += '' : text = '';

            var rect = contain_text["e" /* getBoundingRect */](style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);

            rect.x += style.x || 0;
            rect.y += style.y || 0;

            if (helper_text["a" /* getStroke */](style.textStroke, style.textStrokeWidth)) {
                var w = style.textStrokeWidth;
                rect.x -= w / 2;
                rect.y -= w / 2;
                rect.width += w;
                rect.height += w;
            }

            this._rect = rect;
        }

        return this._rect;
    }
};

util["o" /* inherits */](Text_Text, Displayable["a" /* default */]);

/* harmony default export */ var graphic_Text = (Text_Text);
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/shape/Circle.js




/* harmony default export */ var Circle = (Path["a" /* default */].extend({

    type: 'circle',

    shape: {
        cx: 0,
        cy: 0,
        r: 0
    },

    buildPath: function buildPath(ctx, shape, inBundle) {
        if (inBundle) {
            ctx.moveTo(shape.cx + shape.r, shape.cy);
        }

        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
    }
}));
// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/helper/fixClipWithShadow.js
var fixClipWithShadow = __webpack_require__(102);

// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/shape/Sector.js





/* harmony default export */ var Sector = (Path["a" /* default */].extend({

    type: 'sector',

    shape: {

        cx: 0,

        cy: 0,

        r0: 0,

        r: 0,

        startAngle: 0,

        endAngle: Math.PI * 2,

        clockwise: true
    },

    brush: Object(fixClipWithShadow["a" /* default */])(Path["a" /* default */].prototype.brush),

    buildPath: function buildPath(ctx, shape) {

        var x = shape.cx;
        var y = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;

        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);

        ctx.moveTo(unitX * r0 + x, unitY * r0 + y);

        ctx.lineTo(unitX * r + x, unitY * r + y);

        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);

        ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);

        if (r0 !== 0) {
            ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
        }

        ctx.closePath();
    }
}));
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/shape/Ring.js




/* harmony default export */ var Ring = (Path["a" /* default */].extend({

    type: 'ring',

    shape: {
        cx: 0,
        cy: 0,
        r: 0,
        r0: 0
    },

    buildPath: function buildPath(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var PI2 = Math.PI * 2;
        ctx.moveTo(x + shape.r, y);
        ctx.arc(x, y, shape.r, 0, PI2, false);
        ctx.moveTo(x + shape.r0, y);
        ctx.arc(x, y, shape.r0, 0, PI2, true);
    }
}));
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/helper/smoothSpline.js




function interpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}

/* harmony default export */ var smoothSpline = (function (points, isLoop) {
    var len = points.length;
    var ret = [];

    var distance = 0;
    for (var i = 1; i < len; i++) {
        distance += Object(vector["h" /* distance */])(points[i - 1], points[i]);
    }

    var segs = distance / 2;
    segs = segs < len ? len : segs;
    for (var i = 0; i < segs; i++) {
        var pos = i / (segs - 1) * (isLoop ? len : len - 1);
        var idx = Math.floor(pos);

        var w = pos - idx;

        var p0;
        var p1 = points[idx % len];
        var p2;
        var p3;
        if (!isLoop) {
            p0 = points[idx === 0 ? idx : idx - 1];
            p2 = points[idx > len - 2 ? len - 1 : idx + 1];
            p3 = points[idx > len - 3 ? len - 1 : idx + 2];
        } else {
            p0 = points[(idx - 1 + len) % len];
            p2 = points[(idx + 1) % len];
            p3 = points[(idx + 2) % len];
        }

        var w2 = w * w;
        var w3 = w * w2;

        ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
    }
    return ret;
});
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/helper/smoothBezier.js




/* harmony default export */ var smoothBezier = (function (points, smooth, isLoop, constraint) {
    var cps = [];

    var v = [];
    var v1 = [];
    var v2 = [];
    var prevPoint;
    var nextPoint;

    var min, max;
    if (constraint) {
        min = [Infinity, Infinity];
        max = [-Infinity, -Infinity];
        for (var i = 0, len = points.length; i < len; i++) {
            Object(vector["j" /* min */])(min, min, points[i]);
            Object(vector["i" /* max */])(max, max, points[i]);
        }

        Object(vector["j" /* min */])(min, min, constraint[0]);
        Object(vector["i" /* max */])(max, max, constraint[1]);
    }

    for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];

        if (isLoop) {
            prevPoint = points[i ? i - 1 : len - 1];
            nextPoint = points[(i + 1) % len];
        } else {
            if (i === 0 || i === len - 1) {
                cps.push(Object(vector["c" /* clone */])(points[i]));
                continue;
            } else {
                prevPoint = points[i - 1];
                nextPoint = points[i + 1];
            }
        }

        Object(vector["n" /* sub */])(v, nextPoint, prevPoint);

        Object(vector["l" /* scale */])(v, v, smooth);

        var d0 = Object(vector["h" /* distance */])(point, prevPoint);
        var d1 = Object(vector["h" /* distance */])(point, nextPoint);
        var sum = d0 + d1;
        if (sum !== 0) {
            d0 /= sum;
            d1 /= sum;
        }

        Object(vector["l" /* scale */])(v1, v, -d0);
        Object(vector["l" /* scale */])(v2, v, d1);
        var cp0 = Object(vector["a" /* add */])([], point, v1);
        var cp1 = Object(vector["a" /* add */])([], point, v2);
        if (constraint) {
            Object(vector["i" /* max */])(cp0, cp0, min);
            Object(vector["j" /* min */])(cp0, cp0, max);
            Object(vector["i" /* max */])(cp1, cp1, min);
            Object(vector["j" /* min */])(cp1, cp1, max);
        }
        cps.push(cp0);
        cps.push(cp1);
    }

    if (isLoop) {
        cps.push(cps.shift());
    }

    return cps;
});
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/helper/poly.js




function poly_buildPath(ctx, shape, closePath) {
    var points = shape.points;
    var smooth = shape.smooth;
    if (points && points.length >= 2) {
        if (smooth && smooth !== 'spline') {
            var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);

            ctx.moveTo(points[0][0], points[0][1]);
            var len = points.length;
            for (var i = 0; i < (closePath ? len : len - 1); i++) {
                var cp1 = controlPoints[i * 2];
                var cp2 = controlPoints[i * 2 + 1];
                var p = points[(i + 1) % len];
                ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
            }
        } else {
            if (smooth === 'spline') {
                points = smoothSpline(points, closePath);
            }

            ctx.moveTo(points[0][0], points[0][1]);
            for (var i = 1, l = points.length; i < l; i++) {
                ctx.lineTo(points[i][0], points[i][1]);
            }
        }

        closePath && ctx.closePath();
    }
}
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/shape/Polygon.js





/* harmony default export */ var Polygon = (Path["a" /* default */].extend({

    type: 'polygon',

    shape: {
        points: null,

        smooth: false,

        smoothConstraint: null
    },

    buildPath: function buildPath(ctx, shape) {
        poly_buildPath(ctx, shape, true);
    }
}));
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/shape/Polyline.js





/* harmony default export */ var Polyline = (Path["a" /* default */].extend({

    type: 'polyline',

    shape: {
        points: null,

        smooth: false,

        smoothConstraint: null
    },

    style: {
        stroke: '#000',

        fill: null
    },

    buildPath: function buildPath(ctx, shape) {
        poly_buildPath(ctx, shape, false);
    }
}));
// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/helper/roundRect.js
var roundRect = __webpack_require__(101);

// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/shape/Rect.js





/* harmony default export */ var Rect = (Path["a" /* default */].extend({

    type: 'rect',

    shape: {
        r: 0,

        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    buildPath: function buildPath(ctx, shape) {
        var x = shape.x;
        var y = shape.y;
        var width = shape.width;
        var height = shape.height;
        if (!shape.r) {
            ctx.rect(x, y, width, height);
        } else {
            roundRect["a" /* buildPath */](ctx, shape);
        }
        ctx.closePath();
        return;
    }
}));
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/shape/Line.js




/* harmony default export */ var Line = (Path["a" /* default */].extend({

    type: 'line',

    shape: {
        x1: 0,
        y1: 0,

        x2: 0,
        y2: 0,

        percent: 1
    },

    style: {
        stroke: '#000',
        fill: null
    },

    buildPath: function buildPath(ctx, shape) {
        var x1 = shape.x1;
        var y1 = shape.y1;
        var x2 = shape.x2;
        var y2 = shape.y2;
        var percent = shape.percent;

        if (percent === 0) {
            return;
        }

        ctx.moveTo(x1, y1);

        if (percent < 1) {
            x2 = x1 * (1 - percent) + x2 * percent;
            y2 = y1 * (1 - percent) + y2 * percent;
        }
        ctx.lineTo(x2, y2);
    },

    pointAt: function pointAt(p) {
        var shape = this.shape;
        return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
    }
}));
// EXTERNAL MODULE: ./node_modules/zrender/src/core/curve.js
var curve = __webpack_require__(22);

// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/shape/BezierCurve.js






var out = [];

function someVectorAt(shape, t, isTangent) {
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    if (cpx2 === null || cpy2 === null) {
        return [(isTangent ? curve["b" /* cubicDerivativeAt */] : curve["a" /* cubicAt */])(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? curve["b" /* cubicDerivativeAt */] : curve["a" /* cubicAt */])(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
    } else {
        return [(isTangent ? curve["h" /* quadraticDerivativeAt */] : curve["g" /* quadraticAt */])(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? curve["h" /* quadraticDerivativeAt */] : curve["g" /* quadraticAt */])(shape.y1, shape.cpy1, shape.y2, t)];
    }
}

/* harmony default export */ var BezierCurve = (Path["a" /* default */].extend({

    type: 'bezier-curve',

    shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        cpx1: 0,
        cpy1: 0,

        percent: 1
    },

    style: {
        stroke: '#000',
        fill: null
    },

    buildPath: function buildPath(ctx, shape) {
        var x1 = shape.x1;
        var y1 = shape.y1;
        var x2 = shape.x2;
        var y2 = shape.y2;
        var cpx1 = shape.cpx1;
        var cpy1 = shape.cpy1;
        var cpx2 = shape.cpx2;
        var cpy2 = shape.cpy2;
        var percent = shape.percent;
        if (percent === 0) {
            return;
        }

        ctx.moveTo(x1, y1);

        if (cpx2 == null || cpy2 == null) {
            if (percent < 1) {
                Object(curve["l" /* quadraticSubdivide */])(x1, cpx1, x2, percent, out);
                cpx1 = out[1];
                x2 = out[2];
                Object(curve["l" /* quadraticSubdivide */])(y1, cpy1, y2, percent, out);
                cpy1 = out[1];
                y2 = out[2];
            }

            ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
        } else {
            if (percent < 1) {
                Object(curve["f" /* cubicSubdivide */])(x1, cpx1, cpx2, x2, percent, out);
                cpx1 = out[1];
                cpx2 = out[2];
                x2 = out[3];
                Object(curve["f" /* cubicSubdivide */])(y1, cpy1, cpy2, y2, percent, out);
                cpy1 = out[1];
                cpy2 = out[2];
                y2 = out[3];
            }
            ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
        }
    },

    pointAt: function pointAt(t) {
        return someVectorAt(this.shape, t, false);
    },

    tangentAt: function tangentAt(t) {
        var p = someVectorAt(this.shape, t, true);
        return vector["k" /* normalize */](p, p);
    }
}));
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/shape/Arc.js




/* harmony default export */ var Arc = (Path["a" /* default */].extend({

    type: 'arc',

    shape: {

        cx: 0,

        cy: 0,

        r: 0,

        startAngle: 0,

        endAngle: Math.PI * 2,

        clockwise: true
    },

    style: {

        stroke: '#000',

        fill: null
    },

    buildPath: function buildPath(ctx, shape) {

        var x = shape.cx;
        var y = shape.cy;
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;

        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);

        ctx.moveTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    }
}));
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/CompoundPath.js




/* harmony default export */ var CompoundPath = (Path["a" /* default */].extend({

    type: 'compound',

    shape: {

        paths: null
    },

    _updatePathDirty: function _updatePathDirty() {
        var dirtyPath = this.__dirtyPath;
        var paths = this.shape.paths;
        for (var i = 0; i < paths.length; i++) {
            dirtyPath = dirtyPath || paths[i].__dirtyPath;
        }
        this.__dirtyPath = dirtyPath;
        this.__dirty = this.__dirty || dirtyPath;
    },

    beforeBrush: function beforeBrush() {
        this._updatePathDirty();
        var paths = this.shape.paths || [];
        var scale = this.getGlobalScale();

        for (var i = 0; i < paths.length; i++) {
            if (!paths[i].path) {
                paths[i].createPathProxy();
            }
            paths[i].path.setScale(scale[0], scale[1]);
        }
    },

    buildPath: function buildPath(ctx, shape) {
        var paths = shape.paths || [];
        for (var i = 0; i < paths.length; i++) {
            paths[i].buildPath(ctx, paths[i].shape, true);
        }
    },

    afterBrush: function afterBrush() {
        var paths = this.shape.paths || [];
        for (var i = 0; i < paths.length; i++) {
            paths[i].__dirtyPath = false;
        }
    },

    getBoundingRect: function getBoundingRect() {
        this._updatePathDirty();
        return Path["a" /* default */].prototype.getBoundingRect.call(this);
    }
}));
// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Gradient.js
var Gradient = __webpack_require__(58);

// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/LinearGradient.js



var LinearGradient_LinearGradient = function LinearGradient(x, y, x2, y2, colorStops, globalCoord) {

    this.x = x == null ? 0 : x;

    this.y = y == null ? 0 : y;

    this.x2 = x2 == null ? 1 : x2;

    this.y2 = y2 == null ? 0 : y2;

    this.type = 'linear';

    this.global = globalCoord || false;

    Gradient["a" /* default */].call(this, colorStops);
};

LinearGradient_LinearGradient.prototype = {

    constructor: LinearGradient_LinearGradient
};

util["o" /* inherits */](LinearGradient_LinearGradient, Gradient["a" /* default */]);

/* harmony default export */ var graphic_LinearGradient = (LinearGradient_LinearGradient);
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/RadialGradient.js



var RadialGradient_RadialGradient = function RadialGradient(x, y, r, colorStops, globalCoord) {

    this.x = x == null ? 0.5 : x;

    this.y = y == null ? 0.5 : y;

    this.r = r == null ? 0.5 : r;

    this.type = 'radial';

    this.global = globalCoord || false;

    Gradient["a" /* default */].call(this, colorStops);
};

RadialGradient_RadialGradient.prototype = {

    constructor: RadialGradient_RadialGradient
};

util["o" /* inherits */](RadialGradient_RadialGradient, Gradient["a" /* default */]);

/* harmony default export */ var graphic_RadialGradient = (RadialGradient_RadialGradient);
// EXTERNAL MODULE: ./node_modules/zrender/src/core/BoundingRect.js
var BoundingRect = __webpack_require__(11);

// CONCATENATED MODULE: ./node_modules/echarts/src/util/graphic.js
/* harmony export (immutable) */ __webpack_exports__["extendShape"] = extendShape;
/* harmony export (immutable) */ __webpack_exports__["extendPath"] = extendPath;
/* harmony export (immutable) */ __webpack_exports__["makePath"] = makePath;
/* harmony export (immutable) */ __webpack_exports__["makeImage"] = makeImage;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergePath", function() { return graphic_mergePath; });
/* harmony export (immutable) */ __webpack_exports__["resizePath"] = resizePath;
/* harmony export (immutable) */ __webpack_exports__["subPixelOptimizeLine"] = subPixelOptimizeLine;
/* harmony export (immutable) */ __webpack_exports__["subPixelOptimizeRect"] = subPixelOptimizeRect;
/* harmony export (immutable) */ __webpack_exports__["subPixelOptimize"] = subPixelOptimize;
/* harmony export (immutable) */ __webpack_exports__["setHoverStyle"] = setHoverStyle;
/* harmony export (immutable) */ __webpack_exports__["setLabelStyle"] = setLabelStyle;
/* harmony export (immutable) */ __webpack_exports__["setTextStyle"] = setTextStyle;
/* harmony export (immutable) */ __webpack_exports__["setText"] = setText;
/* harmony export (immutable) */ __webpack_exports__["getFont"] = getFont;
/* harmony export (immutable) */ __webpack_exports__["updateProps"] = updateProps;
/* harmony export (immutable) */ __webpack_exports__["initProps"] = initProps;
/* harmony export (immutable) */ __webpack_exports__["getTransform"] = getTransform;
/* harmony export (immutable) */ __webpack_exports__["applyTransform"] = applyTransform;
/* harmony export (immutable) */ __webpack_exports__["transformDirection"] = transformDirection;
/* harmony export (immutable) */ __webpack_exports__["groupTransition"] = groupTransition;
/* harmony export (immutable) */ __webpack_exports__["clipPointsByRect"] = clipPointsByRect;
/* harmony export (immutable) */ __webpack_exports__["clipRectByRect"] = clipRectByRect;
/* harmony export (immutable) */ __webpack_exports__["createIcon"] = createIcon;
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Group", function() { return Group["a" /* default */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Image", function() { return Image["a" /* default */]; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Text", function() { return graphic_Text; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Sector", function() { return Sector; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Ring", function() { return Ring; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Rect", function() { return Rect; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "BezierCurve", function() { return BezierCurve; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Arc", function() { return Arc; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "CompoundPath", function() { return CompoundPath; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "LinearGradient", function() { return graphic_LinearGradient; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "RadialGradient", function() { return graphic_RadialGradient; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "BoundingRect", function() { return BoundingRect["a" /* default */]; });
























var round = Math.round;
var mathMax = Math.max;
var mathMin = Math.min;

var EMPTY_OBJ = {};

function extendShape(opts) {
    return Path["a" /* default */].extend(opts);
}

function extendPath(pathData, opts) {
    return extendFromString(pathData, opts);
}

function makePath(pathData, opts, rect, layout) {
    var path = createFromString(pathData, opts);
    var boundingRect = path.getBoundingRect();
    if (rect) {
        if (layout === 'center') {
            rect = centerGraphic(rect, boundingRect);
        }

        resizePath(path, rect);
    }
    return path;
}

function makeImage(imageUrl, rect, layout) {
    var path = new Image["a" /* default */]({
        style: {
            image: imageUrl,
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
        },
        onload: function onload(img) {
            if (layout === 'center') {
                var boundingRect = {
                    width: img.width,
                    height: img.height
                };
                path.setStyle(centerGraphic(rect, boundingRect));
            }
        }
    });
    return path;
}

function centerGraphic(rect, boundingRect) {
    var aspect = boundingRect.width / boundingRect.height;
    var width = rect.height * aspect;
    var height;
    if (width <= rect.width) {
        height = rect.height;
    } else {
        width = rect.width;
        height = width / aspect;
    }
    var cx = rect.x + rect.width / 2;
    var cy = rect.y + rect.height / 2;

    return {
        x: cx - width / 2,
        y: cy - height / 2,
        width: width,
        height: height
    };
}

var graphic_mergePath = mergePath;

function resizePath(path, rect) {
    if (!path.applyTransform) {
        return;
    }

    var pathRect = path.getBoundingRect();

    var m = pathRect.calculateTransform(rect);

    path.applyTransform(m);
}

function subPixelOptimizeLine(param) {
    var shape = param.shape;
    var lineWidth = param.style.lineWidth;

    if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
        shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
    }
    if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
        shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
    }
    return param;
}

function subPixelOptimizeRect(param) {
    var shape = param.shape;
    var lineWidth = param.style.lineWidth;
    var originX = shape.x;
    var originY = shape.y;
    var originWidth = shape.width;
    var originHeight = shape.height;
    shape.x = subPixelOptimize(shape.x, lineWidth, true);
    shape.y = subPixelOptimize(shape.y, lineWidth, true);
    shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);
    shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);
    return param;
}

function subPixelOptimize(position, lineWidth, positiveOrNegative) {
    var doubledPosition = round(position * 2);
    return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

function hasFillOrStroke(fillOrStroke) {
    return fillOrStroke != null && fillOrStroke != 'none';
}

function liftColor(color) {
    return typeof color === 'string' ? tool_color["a" /* lift */](color, -0.1) : color;
}

function cacheElementStl(el) {
    if (el.__hoverStlDirty) {
        var stroke = el.style.stroke;
        var fill = el.style.fill;

        var hoverStyle = el.__hoverStl;
        hoverStyle.fill = hoverStyle.fill || (hasFillOrStroke(fill) ? liftColor(fill) : null);
        hoverStyle.stroke = hoverStyle.stroke || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);

        var normalStyle = {};
        for (var name in hoverStyle) {
            if (hoverStyle[name] != null) {
                normalStyle[name] = el.style[name];
            }
        }

        el.__normalStl = normalStyle;

        el.__hoverStlDirty = false;
    }
}

function doSingleEnterHover(el) {
    if (el.__isHover) {
        return;
    }

    cacheElementStl(el);

    if (el.useHoverLayer) {
        el.__zr && el.__zr.addHover(el, el.__hoverStl);
    } else {
        var style = el.style;
        var insideRollbackOpt = style.insideRollbackOpt;

        insideRollbackOpt && rollbackInsideStyle(style);

        style.extendFrom(el.__hoverStl);

        if (insideRollbackOpt) {
            applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt);

            if (style.textFill == null) {
                style.textFill = insideRollbackOpt.autoColor;
            }
        }

        el.dirty(false);
        el.z2 += 1;
    }

    el.__isHover = true;
}

function doSingleLeaveHover(el) {
    if (!el.__isHover) {
        return;
    }

    var normalStl = el.__normalStl;
    if (el.useHoverLayer) {
        el.__zr && el.__zr.removeHover(el);
    } else {
        normalStl && el.setStyle(normalStl);
        el.z2 -= 1;
    }

    el.__isHover = false;
}

function doEnterHover(el) {
    el.type === 'group' ? el.traverse(function (child) {
        if (child.type !== 'group') {
            doSingleEnterHover(child);
        }
    }) : doSingleEnterHover(el);
}

function doLeaveHover(el) {
    el.type === 'group' ? el.traverse(function (child) {
        if (child.type !== 'group') {
            doSingleLeaveHover(child);
        }
    }) : doSingleLeaveHover(el);
}

function setElementHoverStl(el, hoverStl) {
    el.__hoverStl = el.hoverStyle || hoverStl || {};
    el.__hoverStlDirty = true;

    if (el.__isHover) {
        cacheElementStl(el);
    }
}

function onElementMouseOver(e) {
    if (this.__hoverSilentOnTouch && e.zrByTouch) {
        return;
    }

    !this.__isEmphasis && doEnterHover(this);
}

function onElementMouseOut(e) {
    if (this.__hoverSilentOnTouch && e.zrByTouch) {
        return;
    }

    !this.__isEmphasis && doLeaveHover(this);
}

function enterEmphasis() {
    this.__isEmphasis = true;
    doEnterHover(this);
}

function leaveEmphasis() {
    this.__isEmphasis = false;
    doLeaveHover(this);
}

function setHoverStyle(el, hoverStyle, opt) {
    el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;

    el.type === 'group' ? el.traverse(function (child) {
        if (child.type !== 'group') {
            setElementHoverStl(child, hoverStyle);
        }
    }) : setElementHoverStl(el, hoverStyle);

    el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);

    el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);
}

function setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
    opt = opt || EMPTY_OBJ;
    var labelFetcher = opt.labelFetcher;
    var labelDataIndex = opt.labelDataIndex;
    var labelDimIndex = opt.labelDimIndex;

    var showNormal = normalModel.getShallow('show');
    var showEmphasis = emphasisModel.getShallow('show');

    var baseText = showNormal || showEmphasis ? util["D" /* retrieve2 */](labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex) : null, opt.defaultText) : null;
    var normalStyleText = showNormal ? baseText : null;
    var emphasisStyleText = showEmphasis ? util["D" /* retrieve2 */](labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex) : null, baseText) : null;

    if (normalStyleText != null || emphasisStyleText != null) {
        setTextStyle(normalStyle, normalModel, normalSpecified, opt);
        setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);
    }

    normalStyle.text = normalStyleText;
    emphasisStyle.text = emphasisStyleText;
}

function setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
    setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);
    specifiedTextStyle && util["k" /* extend */](textStyle, specifiedTextStyle);
    textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);

    return textStyle;
}

function setText(textStyle, labelModel, defaultColor) {
    var opt = { isRectText: true };
    var isEmphasis;

    if (defaultColor === false) {
        isEmphasis = true;
    } else {
        opt.autoColor = defaultColor;
    }
    setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);
    textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);
}

function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {
    opt = opt || EMPTY_OBJ;

    if (opt.isRectText) {
        var textPosition = textStyleModel.getShallow('position') || (isEmphasis ? null : 'inside');

        textPosition === 'outside' && (textPosition = 'top');
        textStyle.textPosition = textPosition;
        textStyle.textOffset = textStyleModel.getShallow('offset');
        var labelRotate = textStyleModel.getShallow('rotate');
        labelRotate != null && (labelRotate *= Math.PI / 180);
        textStyle.textRotation = labelRotate;
        textStyle.textDistance = util["D" /* retrieve2 */](textStyleModel.getShallow('distance'), isEmphasis ? null : 5);
    }

    var ecModel = textStyleModel.ecModel;
    var globalTextStyle = ecModel && ecModel.option.textStyle;

    var richItemNames = getRichItemNames(textStyleModel);
    var richResult;
    if (richItemNames) {
        richResult = {};
        for (var name in richItemNames) {
            if (richItemNames.hasOwnProperty(name)) {
                var richTextStyle = textStyleModel.getModel(['rich', name]);

                setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
            }
        }
    }
    textStyle.rich = richResult;

    setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);

    if (opt.forceRich && !opt.textStyle) {
        opt.textStyle = {};
    }

    return textStyle;
}

function getRichItemNames(textStyleModel) {
    var richItemNameMap;
    while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
        var rich = (textStyleModel.option || EMPTY_OBJ).rich;
        if (rich) {
            richItemNameMap = richItemNameMap || {};
            for (var name in rich) {
                if (rich.hasOwnProperty(name)) {
                    richItemNameMap[name] = 1;
                }
            }
        }
        textStyleModel = textStyleModel.parentModel;
    }
    return richItemNameMap;
}

function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
    globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;

    textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt) || globalTextStyle.color;
    textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt) || globalTextStyle.textBorderColor;
    textStyle.textStrokeWidth = util["D" /* retrieve2 */](textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);

    if (!isEmphasis) {
        if (isBlock) {
            var originalTextPosition = textStyle.textPosition;
            textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt);

            textStyle.insideOriginalTextPosition = originalTextPosition;
            textStyle.insideRollbackOpt = opt;
        }

        if (textStyle.textFill == null) {
            textStyle.textFill = opt.autoColor;
        }
    }

    textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;
    textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;
    textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;
    textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;

    textStyle.textAlign = textStyleModel.getShallow('align');
    textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign') || textStyleModel.getShallow('baseline');

    textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');
    textStyle.textWidth = textStyleModel.getShallow('width');
    textStyle.textHeight = textStyleModel.getShallow('height');
    textStyle.textTag = textStyleModel.getShallow('tag');

    if (!isBlock || !opt.disableBox) {
        textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);
        textStyle.textPadding = textStyleModel.getShallow('padding');
        textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);
        textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');
        textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');

        textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');
        textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');
        textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');
        textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');
    }

    textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor') || globalTextStyle.textShadowColor;
    textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur') || globalTextStyle.textShadowBlur;
    textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX') || globalTextStyle.textShadowOffsetX;
    textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY') || globalTextStyle.textShadowOffsetY;
}

function getAutoColor(color, opt) {
    return color !== 'auto' ? color : opt && opt.autoColor ? opt.autoColor : null;
}

function applyInsideStyle(textStyle, textPosition, opt) {
    var useInsideStyle = opt.useInsideStyle;
    var insideRollback;

    if (textStyle.textFill == null && useInsideStyle !== false && (useInsideStyle === true || opt.isRectText && textPosition && typeof textPosition === 'string' && textPosition.indexOf('inside') >= 0)) {
        insideRollback = {
            textFill: null,
            textStroke: textStyle.textStroke,
            textStrokeWidth: textStyle.textStrokeWidth
        };
        textStyle.textFill = '#fff';

        if (textStyle.textStroke == null) {
            textStyle.textStroke = opt.autoColor;
            textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);
        }
    }

    return insideRollback;
}

function rollbackInsideStyle(style) {
    var insideRollback = style.insideRollback;
    if (insideRollback) {
        style.textFill = insideRollback.textFill;
        style.textStroke = insideRollback.textStroke;
        style.textStrokeWidth = insideRollback.textStrokeWidth;
    }
}

function getFont(opt, ecModel) {
    var gTextStyleModel = ecModel || ecModel.getModel('textStyle');
    return [opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' ');
}

function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
    if (typeof dataIndex === 'function') {
        cb = dataIndex;
        dataIndex = null;
    }

    var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();

    if (animationEnabled) {
        var postfix = isUpdate ? 'Update' : '';
        var duration = animatableModel.getShallow('animationDuration' + postfix);
        var animationEasing = animatableModel.getShallow('animationEasing' + postfix);
        var animationDelay = animatableModel.getShallow('animationDelay' + postfix);
        if (typeof animationDelay === 'function') {
            animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
        }
        if (typeof duration === 'function') {
            duration = duration(dataIndex);
        }

        duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());
    } else {
        el.stopAnimation();
        el.attr(props);
        cb && cb();
    }
}

function updateProps(el, props, animatableModel, dataIndex, cb) {
    animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
}

function initProps(el, props, animatableModel, dataIndex, cb) {
    animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
}

function getTransform(target, ancestor) {
    var mat = matrix["c" /* identity */]([]);

    while (target && target !== ancestor) {
        matrix["e" /* mul */](mat, target.getLocalTransform(), mat);
        target = target.parent;
    }

    return mat;
}

function applyTransform(target, transform, invert) {
    if (transform && !util["q" /* isArrayLike */](transform)) {
        transform = Transformable["a" /* default */].getLocalTransform(transform);
    }

    if (invert) {
        transform = matrix["d" /* invert */]([], transform);
    }
    return vector["b" /* applyTransform */]([], target, transform);
}

function transformDirection(direction, transform, invert) {
    var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
    var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);

    var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];

    vertex = applyTransform(vertex, transform, invert);

    return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';
}

function groupTransition(g1, g2, animatableModel, cb) {
    if (!g1 || !g2) {
        return;
    }

    function getElMap(g) {
        var elMap = {};
        g.traverse(function (el) {
            if (!el.isGroup && el.anid) {
                elMap[el.anid] = el;
            }
        });
        return elMap;
    }
    function getAnimatableProps(el) {
        var obj = {
            position: vector["c" /* clone */](el.position),
            rotation: el.rotation
        };
        if (el.shape) {
            obj.shape = util["k" /* extend */]({}, el.shape);
        }
        return obj;
    }
    var elMap1 = getElMap(g1);

    g2.traverse(function (el) {
        if (!el.isGroup && el.anid) {
            var oldEl = elMap1[el.anid];
            if (oldEl) {
                var newProp = getAnimatableProps(el);
                el.attr(getAnimatableProps(oldEl));
                updateProps(el, newProp, animatableModel, el.dataIndex);
            }
        }
    });
}

function clipPointsByRect(points, rect) {
    return util["v" /* map */](points, function (point) {
        var x = point[0];
        x = mathMax(x, rect.x);
        x = mathMin(x, rect.x + rect.width);
        var y = point[1];
        y = mathMax(y, rect.y);
        y = mathMin(y, rect.y + rect.height);
        return [x, y];
    });
}

function clipRectByRect(targetRect, rect) {
    var x = mathMax(targetRect.x, rect.x);
    var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);
    var y = mathMax(targetRect.y, rect.y);
    var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);

    if (x2 >= x && y2 >= y) {
        return {
            x: x,
            y: y,
            width: x2 - x,
            height: y2 - y
        };
    }
}

function createIcon(iconStr, opt, rect) {
    opt = util["k" /* extend */]({ rectHover: true }, opt);
    var style = opt.style = { strokeNoScale: true };
    rect = rect || { x: -1, y: -1, width: 2, height: 2 };

    if (iconStr) {
        return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), util["h" /* defaults */](style, rect), new Image["a" /* default */](opt)) : makePath(iconStr.replace('path://', ''), opt, rect, 'center');
    }
}



/***/ }),

/***/ 100:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = normalizeTextStyle;
/* harmony export (immutable) */ __webpack_exports__["d"] = renderText;
/* harmony export (immutable) */ __webpack_exports__["a"] = getStroke;
/* unused harmony export getFill */
/* harmony export (immutable) */ __webpack_exports__["b"] = needDrawText;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__contain_text__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__roundRect__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__image__ = __webpack_require__(57);






var VALID_TEXT_ALIGN = { left: 1, right: 1, center: 1 };
var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };

function normalizeTextStyle(style) {
    normalizeStyle(style);
    Object(__WEBPACK_IMPORTED_MODULE_0__core_util__["i" /* each */])(style.rich, normalizeStyle);
    return style;
}

function normalizeStyle(style) {
    if (style) {

        style.font = __WEBPACK_IMPORTED_MODULE_1__contain_text__["g" /* makeFont */](style);

        var textAlign = style.textAlign;
        textAlign === 'middle' && (textAlign = 'center');
        style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left';

        var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
        textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
        style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';

        var textPadding = style.textPadding;
        if (textPadding) {
            style.textPadding = Object(__WEBPACK_IMPORTED_MODULE_0__core_util__["A" /* normalizeCssArray */])(style.textPadding);
        }
    }
}

function renderText(hostEl, ctx, text, style, rect) {
    style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect);
}

function renderPlainText(hostEl, ctx, text, style, rect) {
    var font = setCtx(ctx, 'font', style.font || __WEBPACK_IMPORTED_MODULE_1__contain_text__["a" /* DEFAULT_FONT */]);

    var textPadding = style.textPadding;

    var contentBlock = hostEl.__textCotentBlock;
    if (!contentBlock || hostEl.__dirty) {
        contentBlock = hostEl.__textCotentBlock = __WEBPACK_IMPORTED_MODULE_1__contain_text__["h" /* parsePlainText */](text, font, textPadding, style.truncate);
    }

    var outerHeight = contentBlock.outerHeight;

    var textLines = contentBlock.lines;
    var lineHeight = contentBlock.lineHeight;

    var boxPos = getBoxPosition(outerHeight, style, rect);
    var baseX = boxPos.baseX;
    var baseY = boxPos.baseY;
    var textAlign = boxPos.textAlign;
    var textVerticalAlign = boxPos.textVerticalAlign;

    applyTextRotation(ctx, style, rect, baseX, baseY);

    var boxY = __WEBPACK_IMPORTED_MODULE_1__contain_text__["d" /* adjustTextY */](baseY, outerHeight, textVerticalAlign);
    var textX = baseX;
    var textY = boxY;

    var needDrawBg = needDrawBackground(style);
    if (needDrawBg || textPadding) {
        var textWidth = __WEBPACK_IMPORTED_MODULE_1__contain_text__["f" /* getWidth */](text, font);
        var outerWidth = textWidth;
        textPadding && (outerWidth += textPadding[1] + textPadding[3]);
        var boxX = __WEBPACK_IMPORTED_MODULE_1__contain_text__["c" /* adjustTextX */](baseX, outerWidth, textAlign);

        needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

        if (textPadding) {
            textX = getTextXForPadding(baseX, textAlign, textPadding);
            textY += textPadding[0];
        }
    }

    setCtx(ctx, 'textAlign', textAlign || 'left');

    setCtx(ctx, 'textBaseline', 'middle');

    setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);
    setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');
    setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);
    setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0);

    textY += lineHeight / 2;

    var textStrokeWidth = style.textStrokeWidth;
    var textStroke = getStroke(style.textStroke, textStrokeWidth);
    var textFill = getFill(style.textFill);

    if (textStroke) {
        setCtx(ctx, 'lineWidth', textStrokeWidth);
        setCtx(ctx, 'strokeStyle', textStroke);
    }
    if (textFill) {
        setCtx(ctx, 'fillStyle', textFill);
    }

    for (var i = 0; i < textLines.length; i++) {
        textStroke && ctx.strokeText(textLines[i], textX, textY);
        textFill && ctx.fillText(textLines[i], textX, textY);
        textY += lineHeight;
    }
}

function renderRichText(hostEl, ctx, text, style, rect) {
    var contentBlock = hostEl.__textCotentBlock;

    if (!contentBlock || hostEl.__dirty) {
        contentBlock = hostEl.__textCotentBlock = __WEBPACK_IMPORTED_MODULE_1__contain_text__["i" /* parseRichText */](text, style);
    }

    drawRichText(hostEl, ctx, contentBlock, style, rect);
}

function drawRichText(hostEl, ctx, contentBlock, style, rect) {
    var contentWidth = contentBlock.width;
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;
    var textPadding = style.textPadding;

    var boxPos = getBoxPosition(outerHeight, style, rect);
    var baseX = boxPos.baseX;
    var baseY = boxPos.baseY;
    var textAlign = boxPos.textAlign;
    var textVerticalAlign = boxPos.textVerticalAlign;

    applyTextRotation(ctx, style, rect, baseX, baseY);

    var boxX = __WEBPACK_IMPORTED_MODULE_1__contain_text__["c" /* adjustTextX */](baseX, outerWidth, textAlign);
    var boxY = __WEBPACK_IMPORTED_MODULE_1__contain_text__["d" /* adjustTextY */](baseY, outerHeight, textVerticalAlign);
    var xLeft = boxX;
    var lineTop = boxY;
    if (textPadding) {
        xLeft += textPadding[3];
        lineTop += textPadding[0];
    }
    var xRight = xLeft + contentWidth;

    needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

    for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var tokens = line.tokens;
        var tokenCount = tokens.length;
        var lineHeight = line.lineHeight;
        var usedWidth = line.width;

        var leftIndex = 0;
        var lineXLeft = xLeft;
        var lineXRight = xRight;
        var rightIndex = tokenCount - 1;
        var token;

        while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
            placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
            usedWidth -= token.width;
            lineXLeft += token.width;
            leftIndex++;
        }

        while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
            placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
            usedWidth -= token.width;
            lineXRight -= token.width;
            rightIndex--;
        }

        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
        while (leftIndex <= rightIndex) {
            token = tokens[leftIndex];

            placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
            lineXLeft += token.width;
            leftIndex++;
        }

        lineTop += lineHeight;
    }
}

function applyTextRotation(ctx, style, rect, x, y) {
    if (rect && style.textRotation) {
        var origin = style.textOrigin;
        if (origin === 'center') {
            x = rect.width / 2 + rect.x;
            y = rect.height / 2 + rect.y;
        } else if (origin) {
            x = origin[0] + rect.x;
            y = origin[1] + rect.y;
        }

        ctx.translate(x, y);

        ctx.rotate(-style.textRotation);
        ctx.translate(-x, -y);
    }
}

function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
    var tokenStyle = style.rich[token.styleName] || {};

    var textVerticalAlign = token.textVerticalAlign;
    var y = lineTop + lineHeight / 2;
    if (textVerticalAlign === 'top') {
        y = lineTop + token.height / 2;
    } else if (textVerticalAlign === 'bottom') {
        y = lineTop + lineHeight - token.height / 2;
    }

    !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);

    var textPadding = token.textPadding;
    if (textPadding) {
        x = getTextXForPadding(x, textAlign, textPadding);
        y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
    }

    setCtx(ctx, 'shadowBlur', Object(__WEBPACK_IMPORTED_MODULE_0__core_util__["E" /* retrieve3 */])(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
    setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
    setCtx(ctx, 'shadowOffsetX', Object(__WEBPACK_IMPORTED_MODULE_0__core_util__["E" /* retrieve3 */])(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
    setCtx(ctx, 'shadowOffsetY', Object(__WEBPACK_IMPORTED_MODULE_0__core_util__["E" /* retrieve3 */])(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));

    setCtx(ctx, 'textAlign', textAlign);

    setCtx(ctx, 'textBaseline', 'middle');

    setCtx(ctx, 'font', token.font || __WEBPACK_IMPORTED_MODULE_1__contain_text__["a" /* DEFAULT_FONT */]);

    var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
    var textFill = getFill(tokenStyle.textFill || style.textFill);
    var textStrokeWidth = Object(__WEBPACK_IMPORTED_MODULE_0__core_util__["D" /* retrieve2 */])(tokenStyle.textStrokeWidth, style.textStrokeWidth);

    if (textStroke) {
        setCtx(ctx, 'lineWidth', textStrokeWidth);
        setCtx(ctx, 'strokeStyle', textStroke);
        ctx.strokeText(token.text, x, y);
    }
    if (textFill) {
        setCtx(ctx, 'fillStyle', textFill);
        ctx.fillText(token.text, x, y);
    }
}

function needDrawBackground(style) {
    return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
}

function drawBackground(hostEl, ctx, style, x, y, width, height) {
    var textBackgroundColor = style.textBackgroundColor;
    var textBorderWidth = style.textBorderWidth;
    var textBorderColor = style.textBorderColor;
    var isPlainBg = Object(__WEBPACK_IMPORTED_MODULE_0__core_util__["u" /* isString */])(textBackgroundColor);

    setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
    setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
    setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
    setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);

    if (isPlainBg || textBorderWidth && textBorderColor) {
        ctx.beginPath();
        var textBorderRadius = style.textBorderRadius;
        if (!textBorderRadius) {
            ctx.rect(x, y, width, height);
        } else {
            __WEBPACK_IMPORTED_MODULE_2__roundRect__["a" /* buildPath */](ctx, {
                x: x, y: y, width: width, height: height, r: textBorderRadius
            });
        }
        ctx.closePath();
    }

    if (isPlainBg) {
        setCtx(ctx, 'fillStyle', textBackgroundColor);
        ctx.fill();
    } else if (Object(__WEBPACK_IMPORTED_MODULE_0__core_util__["t" /* isObject */])(textBackgroundColor)) {
        var image = textBackgroundColor.image;

        image = __WEBPACK_IMPORTED_MODULE_3__image__["a" /* createOrUpdateImage */](image, null, hostEl, onBgImageLoaded, textBackgroundColor);
        if (image && __WEBPACK_IMPORTED_MODULE_3__image__["c" /* isImageReady */](image)) {
            ctx.drawImage(image, x, y, width, height);
        }
    }

    if (textBorderWidth && textBorderColor) {
        setCtx(ctx, 'lineWidth', textBorderWidth);
        setCtx(ctx, 'strokeStyle', textBorderColor);
        ctx.stroke();
    }
}

function onBgImageLoaded(image, textBackgroundColor) {
    textBackgroundColor.image = image;
}

function getBoxPosition(blockHeiht, style, rect) {
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var textAlign = style.textAlign;
    var textVerticalAlign = style.textVerticalAlign;

    if (rect) {
        var textPosition = style.textPosition;
        if (textPosition instanceof Array) {
            baseX = rect.x + parsePercent(textPosition[0], rect.width);
            baseY = rect.y + parsePercent(textPosition[1], rect.height);
        } else {
            var res = __WEBPACK_IMPORTED_MODULE_1__contain_text__["b" /* adjustTextPositionOnRect */](textPosition, rect, style.textDistance);
            baseX = res.x;
            baseY = res.y;

            textAlign = textAlign || res.textAlign;
            textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
        }

        var textOffset = style.textOffset;
        if (textOffset) {
            baseX += textOffset[0];
            baseY += textOffset[1];
        }
    }

    return {
        baseX: baseX,
        baseY: baseY,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
    };
}

function setCtx(ctx, prop, value) {
    ctx[prop] = value;

    return ctx[prop];
}

function getStroke(stroke, lineWidth) {
    return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null : stroke.image || stroke.colorStops ? '#000' : stroke;
}

function getFill(fill) {
    return fill == null || fill === 'none' ? null : fill.image || fill.colorStops ? '#000' : fill;
}

function parsePercent(value, maxValue) {
    if (typeof value === 'string') {
        if (value.lastIndexOf('%') >= 0) {
            return parseFloat(value) / 100 * maxValue;
        }
        return parseFloat(value);
    }
    return value;
}

function getTextXForPadding(x, textAlign, textPadding) {
    return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}

function needDrawText(text, style) {
    return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
}

/***/ }),

/***/ 101:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = buildPath;

function buildPath(ctx, shape) {
    var x = shape.x;
    var y = shape.y;
    var width = shape.width;
    var height = shape.height;
    var r = shape.r;
    var r1;
    var r2;
    var r3;
    var r4;

    if (width < 0) {
        x = x + width;
        width = -width;
    }
    if (height < 0) {
        y = y + height;
        height = -height;
    }

    if (typeof r === 'number') {
        r1 = r2 = r3 = r4 = r;
    } else if (r instanceof Array) {
        if (r.length === 1) {
            r1 = r2 = r3 = r4 = r[0];
        } else if (r.length === 2) {
            r1 = r3 = r[0];
            r2 = r4 = r[1];
        } else if (r.length === 3) {
            r1 = r[0];
            r2 = r4 = r[1];
            r3 = r[2];
        } else {
            r1 = r[0];
            r2 = r[1];
            r3 = r[2];
            r4 = r[3];
        }
    } else {
        r1 = r2 = r3 = r4 = 0;
    }

    var total;
    if (r1 + r2 > width) {
        total = r1 + r2;
        r1 *= width / total;
        r2 *= width / total;
    }
    if (r3 + r4 > width) {
        total = r3 + r4;
        r3 *= width / total;
        r4 *= width / total;
    }
    if (r2 + r3 > height) {
        total = r2 + r3;
        r2 *= height / total;
        r3 *= height / total;
    }
    if (r1 + r4 > height) {
        total = r1 + r4;
        r1 *= height / total;
        r4 *= height / total;
    }
    ctx.moveTo(x + r1, y);
    ctx.lineTo(x + width - r2, y);
    r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
    ctx.lineTo(x + width, y + height - r3);
    r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
    ctx.lineTo(x + r4, y + height);
    r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
    ctx.lineTo(x, y + r1);
    r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
}

/***/ }),

/***/ 102:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_env__ = __webpack_require__(4);


var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];

/* harmony default export */ __webpack_exports__["a"] = (function (orignalBrush) {
    return __WEBPACK_IMPORTED_MODULE_0__core_env__["a" /* default */].browser.ie && __WEBPACK_IMPORTED_MODULE_0__core_env__["a" /* default */].browser.version >= 11 ? function () {
        var clipPaths = this.__clipPaths;
        var style = this.style;
        var modified;

        if (clipPaths) {
            for (var i = 0; i < clipPaths.length; i++) {
                var clipPath = clipPaths[i];
                var shape = clipPath && clipPath.shape;
                var type = clipPath && clipPath.type;

                if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
                    for (var j = 0; j < shadowTemp.length; j++) {
                        shadowTemp[j][2] = style[shadowTemp[j][0]];
                        style[shadowTemp[j][0]] = shadowTemp[j][1];
                    }
                    modified = true;
                    break;
                }
            }
        }

        orignalBrush.apply(this, arguments);

        if (modified) {
            for (var j = 0; j < shadowTemp.length; j++) {
                style[shadowTemp[j][0]] = shadowTemp[j][2];
            }
        }
    } : orignalBrush;
});

/***/ }),

/***/ 11:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__matrix__ = __webpack_require__(31);





var v2ApplyTransform = __WEBPACK_IMPORTED_MODULE_0__vector__["b" /* applyTransform */];
var mathMin = Math.min;
var mathMax = Math.max;

function BoundingRect(x, y, width, height) {

    if (width < 0) {
        x = x + width;
        width = -width;
    }
    if (height < 0) {
        y = y + height;
        height = -height;
    }

    this.x = x;

    this.y = y;

    this.width = width;

    this.height = height;
}

BoundingRect.prototype = {

    constructor: BoundingRect,

    union: function union(other) {
        var x = mathMin(other.x, this.x);
        var y = mathMin(other.y, this.y);

        this.width = mathMax(other.x + other.width, this.x + this.width) - x;
        this.height = mathMax(other.y + other.height, this.y + this.height) - y;
        this.x = x;
        this.y = y;
    },

    applyTransform: function () {
        var lt = [];
        var rb = [];
        var lb = [];
        var rt = [];
        return function (m) {
            if (!m) {
                return;
            }
            lt[0] = lb[0] = this.x;
            lt[1] = rt[1] = this.y;
            rb[0] = rt[0] = this.x + this.width;
            rb[1] = lb[1] = this.y + this.height;

            v2ApplyTransform(lt, lt, m);
            v2ApplyTransform(rb, rb, m);
            v2ApplyTransform(lb, lb, m);
            v2ApplyTransform(rt, rt, m);

            this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
            this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
            var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
            var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
            this.width = maxX - this.x;
            this.height = maxY - this.y;
        };
    }(),

    calculateTransform: function calculateTransform(b) {
        var a = this;
        var sx = b.width / a.width;
        var sy = b.height / a.height;

        var m = __WEBPACK_IMPORTED_MODULE_1__matrix__["b" /* create */]();

        __WEBPACK_IMPORTED_MODULE_1__matrix__["h" /* translate */](m, m, [-a.x, -a.y]);
        __WEBPACK_IMPORTED_MODULE_1__matrix__["g" /* scale */](m, m, [sx, sy]);
        __WEBPACK_IMPORTED_MODULE_1__matrix__["h" /* translate */](m, m, [b.x, b.y]);

        return m;
    },

    intersect: function intersect(b) {
        if (!b) {
            return false;
        }

        if (!(b instanceof BoundingRect)) {
            b = BoundingRect.create(b);
        }

        var a = this;
        var ax0 = a.x;
        var ax1 = a.x + a.width;
        var ay0 = a.y;
        var ay1 = a.y + a.height;

        var bx0 = b.x;
        var bx1 = b.x + b.width;
        var by0 = b.y;
        var by1 = b.y + b.height;

        return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    },

    contain: function contain(x, y) {
        var rect = this;
        return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
    },

    clone: function clone() {
        return new BoundingRect(this.x, this.y, this.width, this.height);
    },

    copy: function copy(other) {
        this.x = other.x;
        this.y = other.y;
        this.width = other.width;
        this.height = other.height;
    },

    plain: function plain() {
        return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height
        };
    }
};

BoundingRect.create = function (rect) {
    return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
};

/* harmony default export */ __webpack_exports__["a"] = (BoundingRect);

/***/ }),

/***/ 12:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = addCommas;
/* harmony export (immutable) */ __webpack_exports__["h"] = toCamelCase;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return normalizeCssArray; });
/* harmony export (immutable) */ __webpack_exports__["c"] = encodeHTML;
/* harmony export (immutable) */ __webpack_exports__["e"] = formatTpl;
/* unused harmony export formatTplSimple */
/* harmony export (immutable) */ __webpack_exports__["f"] = getTooltipMarker;
/* harmony export (immutable) */ __webpack_exports__["d"] = formatTime;
/* harmony export (immutable) */ __webpack_exports__["b"] = capitalFirst;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return truncateText; });
/* unused harmony export getTextRect */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_zrender_src_contain_text__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__number__ = __webpack_require__(3);




function addCommas(x) {
    if (isNaN(x)) {
        return '-';
    }
    x = (x + '').split('.');
    return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');
}

function toCamelCase(str, upperCaseFirst) {
    str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
        return group1.toUpperCase();
    });

    if (upperCaseFirst && str) {
        str = str.charAt(0).toUpperCase() + str.slice(1);
    }

    return str;
}

var normalizeCssArray = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["A" /* normalizeCssArray */];

function encodeHTML(source) {
    return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

var wrapVar = function wrapVar(varName, seriesIdx) {
    return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
};

function formatTpl(tpl, paramsList, encode) {
    if (!__WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["p" /* isArray */](paramsList)) {
        paramsList = [paramsList];
    }
    var seriesLen = paramsList.length;
    if (!seriesLen) {
        return '';
    }

    var $vars = paramsList[0].$vars || [];
    for (var i = 0; i < $vars.length; i++) {
        var alias = TPL_VAR_ALIAS[i];
        var val = wrapVar(alias, 0);
        tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);
    }
    for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
        for (var k = 0; k < $vars.length; k++) {
            var val = paramsList[seriesIdx][$vars[k]];
            tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
        }
    }

    return tpl;
}

function formatTplSimple(tpl, param, encode) {
    __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["i" /* each */](param, function (value, key) {
        tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);
    });
    return tpl;
}

function getTooltipMarker(color, extraCssText) {
    return color ? '<span style="display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>' : '';
}

var s2d = function s2d(str) {
    return str < 10 ? '0' + str : str;
};

function formatTime(tpl, value, isUTC) {
    if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
        tpl = 'MM-dd\nyyyy';
    }

    var date = __WEBPACK_IMPORTED_MODULE_2__number__["g" /* parseDate */](value);
    var utc = isUTC ? 'UTC' : '';
    var y = date['get' + utc + 'FullYear']();
    var M = date['get' + utc + 'Month']() + 1;
    var d = date['get' + utc + 'Date']();
    var h = date['get' + utc + 'Hours']();
    var m = date['get' + utc + 'Minutes']();
    var s = date['get' + utc + 'Seconds']();

    tpl = tpl.replace('MM', s2d(M)).replace('M', M).replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);

    return tpl;
}

function capitalFirst(str) {
    return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}

var truncateText = __WEBPACK_IMPORTED_MODULE_1_zrender_src_contain_text__["j" /* truncateText */];

var getTextRect = __WEBPACK_IMPORTED_MODULE_1_zrender_src_contain_text__["e" /* getBoundingRect */];

/***/ }),

/***/ 14:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/zrender/src/core/util.js
var util = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/env.js
var env = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/echarts/src/util/clazz.js
var clazz = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/echarts/src/model/mixin/makeStyleMapper.js
var makeStyleMapper = __webpack_require__(42);

// CONCATENATED MODULE: ./node_modules/echarts/src/model/mixin/lineStyle.js


var _getLineStyle = Object(makeStyleMapper["a" /* default */])([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);

/* harmony default export */ var lineStyle = ({
    getLineStyle: function getLineStyle(excludes) {
        var style = _getLineStyle(this, excludes);
        var lineDash = this.getLineDash(style.lineWidth);
        lineDash && (style.lineDash = lineDash);
        return style;
    },

    getLineDash: function getLineDash(lineWidth) {
        if (lineWidth == null) {
            lineWidth = 1;
        }
        var lineType = this.get('type');
        var dotSize = Math.max(lineWidth, 2);
        var dashSize = lineWidth * 4;
        return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize];
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/model/mixin/areaStyle.js


var _getAreaStyle = Object(makeStyleMapper["a" /* default */])([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]);

/* harmony default export */ var areaStyle = ({
    getAreaStyle: function getAreaStyle(excludes, includes) {
        return _getAreaStyle(this, excludes, includes);
    }
});
// EXTERNAL MODULE: ./node_modules/zrender/src/contain/text.js
var contain_text = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/echarts/src/util/graphic.js + 18 modules
var graphic = __webpack_require__(1);

// CONCATENATED MODULE: ./node_modules/echarts/src/model/mixin/textStyle.js



var PATH_COLOR = ['textStyle', 'color'];

/* harmony default export */ var textStyle = ({
    getTextColor: function getTextColor(isEmphasis) {
        var ecModel = this.ecModel;
        return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
    },

    getFont: function getFont() {
        return graphic["getFont"]({
            fontStyle: this.getShallow('fontStyle'),
            fontWeight: this.getShallow('fontWeight'),
            fontSize: this.getShallow('fontSize'),
            fontFamily: this.getShallow('fontFamily')
        }, this.ecModel);
    },

    getTextRect: function getTextRect(text) {
        return contain_text["e" /* getBoundingRect */](text, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('rich'), this.getShallow('truncateText'));
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/model/mixin/itemStyle.js


var _getItemStyle = Object(makeStyleMapper["a" /* default */])([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]);

/* harmony default export */ var itemStyle = ({
    getItemStyle: function getItemStyle(excludes, includes) {
        var style = _getItemStyle(this, excludes, includes);
        var lineDash = this.getBorderLineDash();
        lineDash && (style.lineDash = lineDash);
        return style;
    },

    getBorderLineDash: function getBorderLineDash() {
        var lineType = this.get('borderType');
        return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [5, 5] : [1, 1];
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/model/Model.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };










var mixin = util["y" /* mixin */];

function Model(option, parentModel, ecModel) {
    this.parentModel = parentModel;

    this.ecModel = ecModel;

    this.option = option;
}

Model.prototype = {

    constructor: Model,

    init: null,

    mergeOption: function mergeOption(option) {
        util["w" /* merge */](this.option, option, true);
    },

    get: function get(path, ignoreParent) {
        if (path == null) {
            return this.option;
        }

        return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));
    },

    getShallow: function getShallow(key, ignoreParent) {
        var option = this.option;

        var val = option == null ? option : option[key];
        var parentModel = !ignoreParent && getParent(this, key);
        if (val == null && parentModel) {
            val = parentModel.getShallow(key);
        }
        return val;
    },

    getModel: function getModel(path, parentModel) {
        var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));

        var thisParentModel;
        parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);

        return new Model(obj, parentModel, this.ecModel);
    },

    isEmpty: function isEmpty() {
        return this.option == null;
    },

    restoreData: function restoreData() {},

    clone: function clone() {
        var Ctor = this.constructor;
        return new Ctor(util["d" /* clone */](this.option));
    },

    setReadOnly: function setReadOnly(properties) {
        clazz["g" /* setReadOnly */](this, properties);
    },

    parsePath: function parsePath(path) {
        if (typeof path === 'string') {
            path = path.split('.');
        }
        return path;
    },

    customizeGetParent: function customizeGetParent(getParentMethod) {
        clazz["f" /* set */](this, 'getParent', getParentMethod);
    },

    isAnimationEnabled: function isAnimationEnabled() {
        if (!env["a" /* default */].node) {
            if (this.option.animation != null) {
                return !!this.option.animation;
            } else if (this.parentModel) {
                return this.parentModel.isAnimationEnabled();
            }
        }
    }
};

function doGet(obj, pathArr, parentModel) {
    for (var i = 0; i < pathArr.length; i++) {
        if (!pathArr[i]) {
            continue;
        }

        obj = obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' ? obj[pathArr[i]] : null;
        if (obj == null) {
            break;
        }
    }
    if (obj == null && parentModel) {
        obj = parentModel.get(pathArr);
    }
    return obj;
}

function getParent(model, path) {
    var getParentMethod = clazz["c" /* get */](model, 'getParent');
    return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;
}

clazz["a" /* enableClassExtend */](Model);

mixin(Model, lineStyle);
mixin(Model, areaStyle);
mixin(Model, textStyle);
mixin(Model, itemStyle);

/* harmony default export */ var model_Model = __webpack_exports__["a"] = (Model);

/***/ }),

/***/ 15:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["f"] = set;
/* harmony export (immutable) */ __webpack_exports__["c"] = get;
/* harmony export (immutable) */ __webpack_exports__["d"] = hasOwn;
/* harmony export (immutable) */ __webpack_exports__["e"] = parseClassType;
/* harmony export (immutable) */ __webpack_exports__["a"] = enableClassExtend;
/* harmony export (immutable) */ __webpack_exports__["b"] = enableClassManagement;
/* harmony export (immutable) */ __webpack_exports__["g"] = setReadOnly;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__ = __webpack_require__(0);


var TYPE_DELIMITER = '.';
var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
var MEMBER_PRIFIX = '\0ec_\0';

function set(host, name, value) {
    return host[MEMBER_PRIFIX + name] = value;
}

function get(host, name) {
    return host[MEMBER_PRIFIX + name];
}

function hasOwn(host, name) {
    return host.hasOwnProperty(MEMBER_PRIFIX + name);
}

function parseClassType(componentType) {
    var ret = { main: '', sub: '' };
    if (componentType) {
        componentType = componentType.split(TYPE_DELIMITER);
        ret.main = componentType[0] || '';
        ret.sub = componentType[1] || '';
    }
    return ret;
}

function checkClassType(componentType) {
    __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["b" /* assert */](/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}

function enableClassExtend(RootClass, mandatoryMethods) {

    RootClass.$constructor = RootClass;
    RootClass.extend = function (proto) {

        if (false) {
            zrUtil.each(mandatoryMethods, function (method) {
                if (!proto[method]) {
                    console.warn('Method `' + method + '` should be implemented' + (proto.type ? ' in ' + proto.type : '') + '.');
                }
            });
        }

        var superClass = this;
        var ExtendedClass = function ExtendedClass() {
            if (!proto.$constructor) {
                superClass.apply(this, arguments);
            } else {
                proto.$constructor.apply(this, arguments);
            }
        };

        __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["k" /* extend */](ExtendedClass.prototype, proto);

        ExtendedClass.extend = this.extend;
        ExtendedClass.superCall = superCall;
        ExtendedClass.superApply = superApply;
        __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["o" /* inherits */](ExtendedClass, this);
        ExtendedClass.superClass = superClass;

        return ExtendedClass;
    };
}

function superCall(context, methodName) {
    var args = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["G" /* slice */](arguments, 2);
    return this.superClass.prototype[methodName].apply(context, args);
}

function superApply(context, methodName, args) {
    return this.superClass.prototype[methodName].apply(context, args);
}

function enableClassManagement(entity, options) {
    options = options || {};

    var storage = {};

    entity.registerClass = function (Clazz, componentType) {
        if (componentType) {
            checkClassType(componentType);
            componentType = parseClassType(componentType);

            if (!componentType.sub) {
                if (false) {
                    if (storage[componentType.main]) {
                        console.warn(componentType.main + ' exists.');
                    }
                }
                storage[componentType.main] = Clazz;
            } else if (componentType.sub !== IS_CONTAINER) {
                var container = makeContainer(componentType);
                container[componentType.sub] = Clazz;
            }
        }
        return Clazz;
    };

    entity.getClass = function (componentMainType, subType, throwWhenNotFound) {
        var Clazz = storage[componentMainType];

        if (Clazz && Clazz[IS_CONTAINER]) {
            Clazz = subType ? Clazz[subType] : null;
        }

        if (throwWhenNotFound && !Clazz) {
            throw new Error(!subType ? componentMainType + '.' + 'type should be specified.' : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.');
        }

        return Clazz;
    };

    entity.getClassesByMainType = function (componentType) {
        componentType = parseClassType(componentType);

        var result = [];
        var obj = storage[componentType.main];

        if (obj && obj[IS_CONTAINER]) {
            __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["i" /* each */](obj, function (o, type) {
                type !== IS_CONTAINER && result.push(o);
            });
        } else {
            result.push(obj);
        }

        return result;
    };

    entity.hasClass = function (componentType) {
        componentType = parseClassType(componentType);
        return !!storage[componentType.main];
    };

    entity.getAllClassMainTypes = function () {
        var types = [];
        __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["i" /* each */](storage, function (obj, type) {
            types.push(type);
        });
        return types;
    };

    entity.hasSubTypes = function (componentType) {
        componentType = parseClassType(componentType);
        var obj = storage[componentType.main];
        return obj && obj[IS_CONTAINER];
    };

    entity.parseClassType = parseClassType;

    function makeContainer(componentType) {
        var container = storage[componentType.main];
        if (!container || !container[IS_CONTAINER]) {
            container = storage[componentType.main] = {};
            container[IS_CONTAINER] = true;
        }
        return container;
    }

    if (options.registerWhenExtend) {
        var originalExtend = entity.extend;
        if (originalExtend) {
            entity.extend = function (proto) {
                var ExtendedClass = originalExtend.call(this, proto);
                return entity.registerClass(ExtendedClass, proto.type);
            };
        }
    }

    return entity;
}

function setReadOnly(obj, properties) {}

/***/ }),

/***/ 2:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["m"] = normalizeToArray;
/* harmony export (immutable) */ __webpack_exports__["f"] = defaultEmphasis;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TEXT_STYLE_OPTIONS; });
/* harmony export (immutable) */ __webpack_exports__["g"] = getDataItemValue;
/* harmony export (immutable) */ __webpack_exports__["h"] = isDataItemOption;
/* harmony export (immutable) */ __webpack_exports__["b"] = converDataValue;
/* unused harmony export createDataFormatModel */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return dataFormatMixin; });
/* harmony export (immutable) */ __webpack_exports__["l"] = mappingToExists;
/* harmony export (immutable) */ __webpack_exports__["k"] = makeIdAndName;
/* harmony export (immutable) */ __webpack_exports__["i"] = isIdInner;
/* unused harmony export compressBatches */
/* harmony export (immutable) */ __webpack_exports__["p"] = queryDataIndex;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return makeGetter; });
/* harmony export (immutable) */ __webpack_exports__["o"] = parseFinder;
/* harmony export (immutable) */ __webpack_exports__["d"] = dataDimToCoordDim;
/* harmony export (immutable) */ __webpack_exports__["c"] = coordDimToDataDim;
/* harmony export (immutable) */ __webpack_exports__["n"] = otherDimToDataDim;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__format__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__number__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_Model__ = __webpack_require__(14);





var each = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["i" /* each */];
var isObject = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["t" /* isObject */];

function normalizeToArray(value) {
    return value instanceof Array ? value : value == null ? [] : [value];
}

function defaultEmphasis(opt, subOpts) {
    if (opt) {
        var emphasisOpt = opt.emphasis = opt.emphasis || {};
        var normalOpt = opt.normal = opt.normal || {};

        for (var i = 0, len = subOpts.length; i < len; i++) {
            var subOptName = subOpts[i];
            if (!emphasisOpt.hasOwnProperty(subOptName) && normalOpt.hasOwnProperty(subOptName)) {
                emphasisOpt[subOptName] = normalOpt[subOptName];
            }
        }
    }
}

var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding'];

function getDataItemValue(dataItem) {
    return dataItem && (dataItem.value == null ? dataItem : dataItem.value);
}

function isDataItemOption(dataItem) {
    return isObject(dataItem) && !(dataItem instanceof Array);
}

function converDataValue(value, dimInfo) {
    var dimType = dimInfo && dimInfo.type;
    if (dimType === 'ordinal') {
        return value;
    }

    if (dimType === 'time' && typeof value !== 'number' && value != null && value !== '-') {
        value = +__WEBPACK_IMPORTED_MODULE_2__number__["g" /* parseDate */](value);
    }

    return value == null || value === '' ? NaN : +value;
}

function createDataFormatModel(data, opt) {
    var model = new __WEBPACK_IMPORTED_MODULE_3__model_Model__["a" /* default */]();
    __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["y" /* mixin */](model, dataFormatMixin);
    model.seriesIndex = opt.seriesIndex;
    model.name = opt.name || '';
    model.mainType = opt.mainType;
    model.subType = opt.subType;

    model.getData = function () {
        return data;
    };
    return model;
}

var dataFormatMixin = {
    getDataParams: function getDataParams(dataIndex, dataType) {
        var data = this.getData(dataType);
        var rawValue = this.getRawValue(dataIndex, dataType);
        var rawDataIndex = data.getRawIndex(dataIndex);
        var name = data.getName(dataIndex, true);
        var itemOpt = data.getRawDataItem(dataIndex);
        var color = data.getItemVisual(dataIndex, 'color');

        return {
            componentType: this.mainType,
            componentSubType: this.subType,
            seriesType: this.mainType === 'series' ? this.subType : null,
            seriesIndex: this.seriesIndex,
            seriesId: this.id,
            seriesName: this.name,
            name: name,
            dataIndex: rawDataIndex,
            data: itemOpt,
            dataType: dataType,
            value: rawValue,
            color: color,
            marker: __WEBPACK_IMPORTED_MODULE_1__format__["f" /* getTooltipMarker */](color),

            $vars: ['seriesName', 'name', 'value']
        };
    },

    getFormattedLabel: function getFormattedLabel(dataIndex, status, dataType, dimIndex, labelProp) {
        status = status || 'normal';
        var data = this.getData(dataType);
        var itemModel = data.getItemModel(dataIndex);

        var params = this.getDataParams(dataIndex, dataType);
        if (dimIndex != null && params.value instanceof Array) {
            params.value = params.value[dimIndex];
        }

        var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);

        if (typeof formatter === 'function') {
            params.status = status;
            return formatter(params);
        } else if (typeof formatter === 'string') {
            return __WEBPACK_IMPORTED_MODULE_1__format__["e" /* formatTpl */](formatter, params);
        }
    },

    getRawValue: function getRawValue(idx, dataType) {
        var data = this.getData(dataType);
        var dataItem = data.getRawDataItem(idx);
        if (dataItem != null) {
            return isObject(dataItem) && !(dataItem instanceof Array) ? dataItem.value : dataItem;
        }
    },

    formatTooltip: __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["z" /* noop */]
};

function mappingToExists(exists, newCptOptions) {
    newCptOptions = (newCptOptions || []).slice();

    var result = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](exists || [], function (obj, index) {
        return { exist: obj };
    });

    each(newCptOptions, function (cptOption, index) {
        if (!isObject(cptOption)) {
            return;
        }

        for (var i = 0; i < result.length; i++) {
            if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + '') {
                result[i].option = cptOption;
                newCptOptions[index] = null;
                return;
            }
        }

        for (var i = 0; i < result.length; i++) {
            var exist = result[i].exist;
            if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + '') {
                result[i].option = cptOption;
                newCptOptions[index] = null;
                return;
            }
        }
    });

    each(newCptOptions, function (cptOption, index) {
        if (!isObject(cptOption)) {
            return;
        }

        var i = 0;
        for (; i < result.length; i++) {
            var exist = result[i].exist;
            if (!result[i].option && !isIdInner(exist) && cptOption.id == null) {
                result[i].option = cptOption;
                break;
            }
        }

        if (i >= result.length) {
            result.push({ option: cptOption });
        }
    });

    return result;
}

function makeIdAndName(mapResult) {
    var idMap = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["f" /* createHashMap */]();

    each(mapResult, function (item, index) {
        var existCpt = item.exist;
        existCpt && idMap.set(existCpt.id, item);
    });

    each(mapResult, function (item, index) {
        var opt = item.option;

        __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["b" /* assert */](!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));

        opt && opt.id != null && idMap.set(opt.id, item);
        !item.keyInfo && (item.keyInfo = {});
    });

    each(mapResult, function (item, index) {
        var existCpt = item.exist;
        var opt = item.option;
        var keyInfo = item.keyInfo;

        if (!isObject(opt)) {
            return;
        }

        keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\0-';

        if (existCpt) {
            keyInfo.id = existCpt.id;
        } else if (opt.id != null) {
            keyInfo.id = opt.id + '';
        } else {
            var idNum = 0;
            do {
                keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
            } while (idMap.get(keyInfo.id));
        }

        idMap.set(keyInfo.id, item);
    });
}

function isIdInner(cptOption) {
    return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
}

function compressBatches(batchA, batchB) {
    var mapA = {};
    var mapB = {};

    makeMap(batchA || [], mapA);
    makeMap(batchB || [], mapB, mapA);

    return [mapToArray(mapA), mapToArray(mapB)];

    function makeMap(sourceBatch, map, otherMap) {
        for (var i = 0, len = sourceBatch.length; i < len; i++) {
            var seriesId = sourceBatch[i].seriesId;
            var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
            var otherDataIndices = otherMap && otherMap[seriesId];

            for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
                var dataIndex = dataIndices[j];

                if (otherDataIndices && otherDataIndices[dataIndex]) {
                    otherDataIndices[dataIndex] = null;
                } else {
                    (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
                }
            }
        }
    }

    function mapToArray(map, isData) {
        var result = [];
        for (var i in map) {
            if (map.hasOwnProperty(i) && map[i] != null) {
                if (isData) {
                    result.push(+i);
                } else {
                    var dataIndices = mapToArray(map[i], true);
                    dataIndices.length && result.push({ seriesId: i, dataIndex: dataIndices });
                }
            }
        }
        return result;
    }
}

function queryDataIndex(data, payload) {
    if (payload.dataIndexInside != null) {
        return payload.dataIndexInside;
    } else if (payload.dataIndex != null) {
        return __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["p" /* isArray */](payload.dataIndex) ? __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](payload.dataIndex, function (value) {
            return data.indexOfRawIndex(value);
        }) : data.indexOfRawIndex(payload.dataIndex);
    } else if (payload.name != null) {
        return __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["p" /* isArray */](payload.name) ? __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](payload.name, function (value) {
            return data.indexOfName(value);
        }) : data.indexOfName(payload.name);
    }
}

var makeGetter = function () {
    var index = 0;
    return function () {
        var key = '\0__ec_prop_getter_' + index++;
        return function (hostObj) {
            return hostObj[key] || (hostObj[key] = {});
        };
    };
}();

function parseFinder(ecModel, finder, opt) {
    if (__WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["u" /* isString */](finder)) {
        var obj = {};
        obj[finder + 'Index'] = 0;
        finder = obj;
    }

    var defaultMainType = opt && opt.defaultMainType;
    if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name')) {
        finder[defaultMainType + 'Index'] = 0;
    }

    var result = {};

    each(finder, function (value, key) {
        var value = finder[key];

        if (key === 'dataIndex' || key === 'dataIndexInside') {
            result[key] = value;
            return;
        }

        var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
        var mainType = parsedKey[1];
        var queryType = (parsedKey[2] || '').toLowerCase();

        if (!mainType || !queryType || value == null || queryType === 'index' && value === 'none' || opt && opt.includeMainTypes && __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["n" /* indexOf */](opt.includeMainTypes, mainType) < 0) {
            return;
        }

        var queryParam = { mainType: mainType };
        if (queryType !== 'index' || value !== 'all') {
            queryParam[queryType] = value;
        }

        var models = ecModel.queryComponents(queryParam);
        result[mainType + 'Models'] = models;
        result[mainType + 'Model'] = models[0];
    });

    return result;
}

function dataDimToCoordDim(data, dataDim) {
    var dimensions = data.dimensions;
    dataDim = data.getDimension(dataDim);
    for (var i = 0; i < dimensions.length; i++) {
        var dimItem = data.getDimensionInfo(dimensions[i]);
        if (dimItem.name === dataDim) {
            return dimItem.coordDim;
        }
    }
}

function coordDimToDataDim(data, coordDim) {
    var dataDim = [];
    each(data.dimensions, function (dimName) {
        var dimItem = data.getDimensionInfo(dimName);
        if (dimItem.coordDim === coordDim) {
            dataDim[dimItem.coordDimIndex] = dimItem.name;
        }
    });
    return dataDim;
}

function otherDimToDataDim(data, otherDim) {
    var dataDim = [];
    each(data.dimensions, function (dimName) {
        var dimItem = data.getDimensionInfo(dimName);
        var otherDims = dimItem.otherDims;
        var dimIndex = otherDims[otherDim];
        if (dimIndex != null && dimIndex !== false) {
            dataDim[dimIndex] = dimItem.name;
        }
    });
    return dataDim;
}

function has(obj, prop) {
    return obj && obj.hasOwnProperty(prop);
}

/***/ }),

/***/ 20:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_FONT; });
/* harmony export (immutable) */ __webpack_exports__["f"] = getWidth;
/* harmony export (immutable) */ __webpack_exports__["e"] = getBoundingRect;
/* harmony export (immutable) */ __webpack_exports__["c"] = adjustTextX;
/* harmony export (immutable) */ __webpack_exports__["d"] = adjustTextY;
/* harmony export (immutable) */ __webpack_exports__["b"] = adjustTextPositionOnRect;
/* harmony export (immutable) */ __webpack_exports__["j"] = truncateText;
/* unused harmony export getLineHeight */
/* unused harmony export measureText */
/* harmony export (immutable) */ __webpack_exports__["h"] = parsePlainText;
/* harmony export (immutable) */ __webpack_exports__["i"] = parseRichText;
/* harmony export (immutable) */ __webpack_exports__["g"] = makeFont;
/* unused harmony export $inject */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_BoundingRect__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__graphic_helper_image__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util__ = __webpack_require__(0);




var textWidthCache = {};
var textWidthCacheCounter = 0;

var TEXT_CACHE_MAX = 5000;
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;

var DEFAULT_FONT = '12px sans-serif';

function getWidth(text, font) {
    font = font || DEFAULT_FONT;
    var key = text + ':' + font;
    if (textWidthCache[key]) {
        return textWidthCache[key];
    }

    var textLines = (text + '').split('\n');
    var width = 0;

    for (var i = 0, l = textLines.length; i < l; i++) {
        width = Math.max(_measureText(textLines[i], font).width, width);
    }

    if (textWidthCacheCounter > TEXT_CACHE_MAX) {
        textWidthCacheCounter = 0;
        textWidthCache = {};
    }
    textWidthCacheCounter++;
    textWidthCache[key] = width;

    return width;
}

function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
    return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
}

function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
    var contentBlock = parsePlainText(text, font, textPadding, truncate);
    var outerWidth = getWidth(text, font);
    if (textPadding) {
        outerWidth += textPadding[1] + textPadding[3];
    }
    var outerHeight = contentBlock.outerHeight;

    var x = adjustTextX(0, outerWidth, textAlign);
    var y = adjustTextY(0, outerHeight, textVerticalAlign);

    var rect = new __WEBPACK_IMPORTED_MODULE_0__core_BoundingRect__["a" /* default */](x, y, outerWidth, outerHeight);
    rect.lineHeight = contentBlock.lineHeight;

    return rect;
}

function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
    var contentBlock = parseRichText(text, {
        rich: rich,
        truncate: truncate,
        font: font,
        textAlign: textAlign,
        textPadding: textPadding
    });
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;

    var x = adjustTextX(0, outerWidth, textAlign);
    var y = adjustTextY(0, outerHeight, textVerticalAlign);

    return new __WEBPACK_IMPORTED_MODULE_0__core_BoundingRect__["a" /* default */](x, y, outerWidth, outerHeight);
}

function adjustTextX(x, width, textAlign) {
    if (textAlign === 'right') {
        x -= width;
    } else if (textAlign === 'center') {
        x -= width / 2;
    }
    return x;
}

function adjustTextY(y, height, textVerticalAlign) {
    if (textVerticalAlign === 'middle') {
        y -= height / 2;
    } else if (textVerticalAlign === 'bottom') {
        y -= height;
    }
    return y;
}

function adjustTextPositionOnRect(textPosition, rect, distance) {

    var x = rect.x;
    var y = rect.y;

    var height = rect.height;
    var width = rect.width;
    var halfHeight = height / 2;

    var textAlign = 'left';
    var textVerticalAlign = 'top';

    switch (textPosition) {
        case 'left':
            x -= distance;
            y += halfHeight;
            textAlign = 'right';
            textVerticalAlign = 'middle';
            break;
        case 'right':
            x += distance + width;
            y += halfHeight;
            textVerticalAlign = 'middle';
            break;
        case 'top':
            x += width / 2;
            y -= distance;
            textAlign = 'center';
            textVerticalAlign = 'bottom';
            break;
        case 'bottom':
            x += width / 2;
            y += height + distance;
            textAlign = 'center';
            break;
        case 'inside':
            x += width / 2;
            y += halfHeight;
            textAlign = 'center';
            textVerticalAlign = 'middle';
            break;
        case 'insideLeft':
            x += distance;
            y += halfHeight;
            textVerticalAlign = 'middle';
            break;
        case 'insideRight':
            x += width - distance;
            y += halfHeight;
            textAlign = 'right';
            textVerticalAlign = 'middle';
            break;
        case 'insideTop':
            x += width / 2;
            y += distance;
            textAlign = 'center';
            break;
        case 'insideBottom':
            x += width / 2;
            y += height - distance;
            textAlign = 'center';
            textVerticalAlign = 'bottom';
            break;
        case 'insideTopLeft':
            x += distance;
            y += distance;
            break;
        case 'insideTopRight':
            x += width - distance;
            y += distance;
            textAlign = 'right';
            break;
        case 'insideBottomLeft':
            x += distance;
            y += height - distance;
            textVerticalAlign = 'bottom';
            break;
        case 'insideBottomRight':
            x += width - distance;
            y += height - distance;
            textAlign = 'right';
            textVerticalAlign = 'bottom';
            break;
    }

    return {
        x: x,
        y: y,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
    };
}

function truncateText(text, containerWidth, font, ellipsis, options) {
    if (!containerWidth) {
        return '';
    }

    var textLines = (text + '').split('\n');
    options = prepareTruncateOptions(containerWidth, font, ellipsis, options);

    for (var i = 0, len = textLines.length; i < len; i++) {
        textLines[i] = truncateSingleLine(textLines[i], options);
    }

    return textLines.join('\n');
}

function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
    options = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["k" /* extend */])({}, options);

    options.font = font;
    var ellipsis = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["D" /* retrieve2 */])(ellipsis, '...');
    options.maxIterations = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["D" /* retrieve2 */])(options.maxIterations, 2);
    var minChar = options.minChar = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["D" /* retrieve2 */])(options.minChar, 0);

    options.cnCharWidth = getWidth('国', font);

    var ascCharWidth = options.ascCharWidth = getWidth('a', font);
    options.placeholder = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["D" /* retrieve2 */])(options.placeholder, '');

    var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
        contentWidth -= ascCharWidth;
    }

    var ellipsisWidth = getWidth(ellipsis);
    if (ellipsisWidth > contentWidth) {
        ellipsis = '';
        ellipsisWidth = 0;
    }

    contentWidth = containerWidth - ellipsisWidth;

    options.ellipsis = ellipsis;
    options.ellipsisWidth = ellipsisWidth;
    options.contentWidth = contentWidth;
    options.containerWidth = containerWidth;

    return options;
}

function truncateSingleLine(textLine, options) {
    var containerWidth = options.containerWidth;
    var font = options.font;
    var contentWidth = options.contentWidth;

    if (!containerWidth) {
        return '';
    }

    var lineWidth = getWidth(textLine, font);

    if (lineWidth <= containerWidth) {
        return textLine;
    }

    for (var j = 0;; j++) {
        if (lineWidth <= contentWidth || j >= options.maxIterations) {
            textLine += options.ellipsis;
            break;
        }

        var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;

        textLine = textLine.substr(0, subLength);
        lineWidth = getWidth(textLine, font);
    }

    if (textLine === '') {
        textLine = options.placeholder;
    }

    return textLine;
}

function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
    var width = 0;
    var i = 0;
    for (var len = text.length; i < len && width < contentWidth; i++) {
        var charCode = text.charCodeAt(i);
        width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
    }
    return i;
}

function getLineHeight(font) {
    return getWidth('国', font);
}

var _measureText = function measureText(text, font) {
    var ctx = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["m" /* getContext */])();
    ctx.font = font || DEFAULT_FONT;
    return ctx.measureText(text);
};



function parsePlainText(text, font, padding, truncate) {
    text != null && (text += '');

    var lineHeight = getLineHeight(font);
    var lines = text ? text.split('\n') : [];
    var height = lines.length * lineHeight;
    var outerHeight = height;

    if (padding) {
        outerHeight += padding[0] + padding[2];
    }

    if (text && truncate) {
        var truncOuterHeight = truncate.outerHeight;
        var truncOuterWidth = truncate.outerWidth;
        if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
            text = '';
            lines = [];
        } else if (truncOuterWidth != null) {
            var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, { minChar: truncate.minChar, placeholder: truncate.placeholder });

            for (var i = 0, len = lines.length; i < len; i++) {
                lines[i] = truncateSingleLine(lines[i], options);
            }
        }
    }

    return {
        lines: lines,
        height: height,
        outerHeight: outerHeight,
        lineHeight: lineHeight
    };
}

function parseRichText(text, style) {
    var contentBlock = { lines: [], width: 0, height: 0 };

    text != null && (text += '');
    if (!text) {
        return contentBlock;
    }

    var lastIndex = STYLE_REG.lastIndex = 0;
    var result;
    while ((result = STYLE_REG.exec(text)) != null) {
        var matchedIndex = result.index;
        if (matchedIndex > lastIndex) {
            pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
        }
        pushTokens(contentBlock, result[2], result[1]);
        lastIndex = STYLE_REG.lastIndex;
    }

    if (lastIndex < text.length) {
        pushTokens(contentBlock, text.substring(lastIndex, text.length));
    }

    var lines = contentBlock.lines;
    var contentHeight = 0;
    var contentWidth = 0;

    var pendingList = [];

    var stlPadding = style.textPadding;

    var truncate = style.truncate;
    var truncateWidth = truncate && truncate.outerWidth;
    var truncateHeight = truncate && truncate.outerHeight;
    if (stlPadding) {
        truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
        truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
    }

    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var lineHeight = 0;
        var lineWidth = 0;

        for (var j = 0; j < line.tokens.length; j++) {
            var token = line.tokens[j];
            var tokenStyle = token.styleName && style.rich[token.styleName] || {};

            var textPadding = token.textPadding = tokenStyle.textPadding;

            var font = token.font = tokenStyle.font || style.font;

            var tokenHeight = token.textHeight = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["D" /* retrieve2 */])(tokenStyle.textHeight, getLineHeight(font));
            textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
            token.height = tokenHeight;
            token.lineHeight = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["E" /* retrieve3 */])(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);

            token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
            token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';

            if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
                return { lines: [], width: 0, height: 0 };
            }

            token.textWidth = getWidth(token.text, font);
            var tokenWidth = tokenStyle.textWidth;
            var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto';

            if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
                token.percentWidth = tokenWidth;
                pendingList.push(token);
                tokenWidth = 0;
            } else {
                if (tokenWidthNotSpecified) {
                    tokenWidth = token.textWidth;

                    var textBackgroundColor = tokenStyle.textBackgroundColor;
                    var bgImg = textBackgroundColor && textBackgroundColor.image;

                    if (bgImg) {
                        bgImg = __WEBPACK_IMPORTED_MODULE_1__graphic_helper_image__["b" /* findExistImage */](bgImg);
                        if (__WEBPACK_IMPORTED_MODULE_1__graphic_helper_image__["c" /* isImageReady */](bgImg)) {
                            tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
                        }
                    }
                }

                var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
                tokenWidth += paddingW;

                var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;

                if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
                    if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
                        token.text = '';
                        token.textWidth = tokenWidth = 0;
                    } else {
                        token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, { minChar: truncate.minChar });
                        token.textWidth = getWidth(token.text, font);
                        tokenWidth = token.textWidth + paddingW;
                    }
                }
            }

            lineWidth += token.width = tokenWidth;
            tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
        }

        line.width = lineWidth;
        line.lineHeight = lineHeight;
        contentHeight += lineHeight;
        contentWidth = Math.max(contentWidth, lineWidth);
    }

    contentBlock.outerWidth = contentBlock.width = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["D" /* retrieve2 */])(style.textWidth, contentWidth);
    contentBlock.outerHeight = contentBlock.height = Object(__WEBPACK_IMPORTED_MODULE_2__core_util__["D" /* retrieve2 */])(style.textHeight, contentHeight);

    if (stlPadding) {
        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
    }

    for (var i = 0; i < pendingList.length; i++) {
        var token = pendingList[i];
        var percentWidth = token.percentWidth;

        token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
    }

    return contentBlock;
}

function pushTokens(block, str, styleName) {
    var isEmptyStr = str === '';
    var strs = str.split('\n');
    var lines = block.lines;

    for (var i = 0; i < strs.length; i++) {
        var text = strs[i];
        var token = {
            styleName: styleName,
            text: text,
            isLineHolder: !text && !isEmptyStr
        };

        if (!i) {
            var tokens = (lines[lines.length - 1] || (lines[0] = { tokens: [] })).tokens;

            var tokensLen = tokens.length;
            tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);
        } else {
                lines.push({ tokens: [token] });
            }
    }
}

function makeFont(style) {
    return (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', style.fontFamily || 'sans-serif'].join(' ') || style.textFont || style.font;
}

var $inject = {
    measureText: function measureText(f) {
        _measureText = f;
    }
};

/***/ }),

/***/ 21:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var arrySlice = Array.prototype.slice;

var Eventful = function Eventful() {
    this._$handlers = {};
};

Eventful.prototype = {

    constructor: Eventful,

    one: function one(event, handler, context) {
        var _h = this._$handlers;

        if (!handler || !event) {
            return this;
        }

        if (!_h[event]) {
            _h[event] = [];
        }

        for (var i = 0; i < _h[event].length; i++) {
            if (_h[event][i].h === handler) {
                return this;
            }
        }

        _h[event].push({
            h: handler,
            one: true,
            ctx: context || this
        });

        return this;
    },

    on: function on(event, handler, context) {
        var _h = this._$handlers;

        if (!handler || !event) {
            return this;
        }

        if (!_h[event]) {
            _h[event] = [];
        }

        for (var i = 0; i < _h[event].length; i++) {
            if (_h[event][i].h === handler) {
                return this;
            }
        }

        _h[event].push({
            h: handler,
            one: false,
            ctx: context || this
        });

        return this;
    },

    isSilent: function isSilent(event) {
        var _h = this._$handlers;
        return _h[event] && _h[event].length;
    },

    off: function off(event, handler) {
        var _h = this._$handlers;

        if (!event) {
            this._$handlers = {};
            return this;
        }

        if (handler) {
            if (_h[event]) {
                var newList = [];
                for (var i = 0, l = _h[event].length; i < l; i++) {
                    if (_h[event][i]['h'] != handler) {
                        newList.push(_h[event][i]);
                    }
                }
                _h[event] = newList;
            }

            if (_h[event] && _h[event].length === 0) {
                delete _h[event];
            }
        } else {
            delete _h[event];
        }

        return this;
    },

    trigger: function trigger(type) {
        if (this._$handlers[type]) {
            var args = arguments;
            var argLen = args.length;

            if (argLen > 3) {
                args = arrySlice.call(args, 1);
            }

            var _h = this._$handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                switch (argLen) {
                    case 1:
                        _h[i]['h'].call(_h[i]['ctx']);
                        break;
                    case 2:
                        _h[i]['h'].call(_h[i]['ctx'], args[1]);
                        break;
                    case 3:
                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
                        break;
                    default:
                        _h[i]['h'].apply(_h[i]['ctx'], args);
                        break;
                }

                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                } else {
                    i++;
                }
            }
        }

        return this;
    },

    triggerWithContext: function triggerWithContext(type) {
        if (this._$handlers[type]) {
            var args = arguments;
            var argLen = args.length;

            if (argLen > 4) {
                args = arrySlice.call(args, 1, args.length - 1);
            }
            var ctx = args[args.length - 1];

            var _h = this._$handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                switch (argLen) {
                    case 1:
                        _h[i]['h'].call(ctx);
                        break;
                    case 2:
                        _h[i]['h'].call(ctx, args[1]);
                        break;
                    case 3:
                        _h[i]['h'].call(ctx, args[1], args[2]);
                        break;
                    default:
                        _h[i]['h'].apply(ctx, args);
                        break;
                }

                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                } else {
                    i++;
                }
            }
        }

        return this;
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Eventful);

/***/ }),

/***/ 22:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = cubicAt;
/* harmony export (immutable) */ __webpack_exports__["b"] = cubicDerivativeAt;
/* harmony export (immutable) */ __webpack_exports__["e"] = cubicRootAt;
/* harmony export (immutable) */ __webpack_exports__["c"] = cubicExtrema;
/* harmony export (immutable) */ __webpack_exports__["f"] = cubicSubdivide;
/* harmony export (immutable) */ __webpack_exports__["d"] = cubicProjectPoint;
/* harmony export (immutable) */ __webpack_exports__["g"] = quadraticAt;
/* harmony export (immutable) */ __webpack_exports__["h"] = quadraticDerivativeAt;
/* harmony export (immutable) */ __webpack_exports__["k"] = quadraticRootAt;
/* harmony export (immutable) */ __webpack_exports__["i"] = quadraticExtremum;
/* harmony export (immutable) */ __webpack_exports__["l"] = quadraticSubdivide;
/* harmony export (immutable) */ __webpack_exports__["j"] = quadraticProjectPoint;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector__ = __webpack_require__(5);




var mathPow = Math.pow;
var mathSqrt = Math.sqrt;

var EPSILON = 1e-8;
var EPSILON_NUMERIC = 1e-4;

var THREE_SQRT = mathSqrt(3);
var ONE_THIRD = 1 / 3;

var _v0 = Object(__WEBPACK_IMPORTED_MODULE_0__vector__["e" /* create */])();
var _v1 = Object(__WEBPACK_IMPORTED_MODULE_0__vector__["e" /* create */])();
var _v2 = Object(__WEBPACK_IMPORTED_MODULE_0__vector__["e" /* create */])();

function isAroundZero(val) {
    return val > -EPSILON && val < EPSILON;
}
function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
}

function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}

function cubicDerivativeAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}

function cubicRootAt(p0, p1, p2, p3, val, roots) {
    var a = p3 + 3 * (p1 - p2) - p0;
    var b = 3 * (p2 - p1 * 2 + p0);
    var c = 3 * (p1 - p0);
    var d = p0 - val;

    var A = b * b - 3 * a * c;
    var B = b * c - 9 * a * d;
    var C = c * c - 3 * b * d;

    var n = 0;

    if (isAroundZero(A) && isAroundZero(B)) {
        if (isAroundZero(b)) {
            roots[0] = 0;
        } else {
            var t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
    } else {
        var disc = B * B - 4 * A * C;

        if (isAroundZero(disc)) {
            var K = B / A;
            var t1 = -b / a + K;
            var t2 = -K / 2;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
        } else if (disc > 0) {
            var discSqrt = mathSqrt(disc);
            var Y1 = A * b + 1.5 * a * (-B + discSqrt);
            var Y2 = A * b + 1.5 * a * (-B - discSqrt);
            if (Y1 < 0) {
                Y1 = -mathPow(-Y1, ONE_THIRD);
            } else {
                Y1 = mathPow(Y1, ONE_THIRD);
            }
            if (Y2 < 0) {
                Y2 = -mathPow(-Y2, ONE_THIRD);
            } else {
                Y2 = mathPow(Y2, ONE_THIRD);
            }
            var t1 = (-b - (Y1 + Y2)) / (3 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        } else {
            var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
            var theta = Math.acos(T) / 3;
            var ASqrt = mathSqrt(A);
            var tmp = Math.cos(theta);

            var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
            var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
            var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
            if (t3 >= 0 && t3 <= 1) {
                roots[n++] = t3;
            }
        }
    }
    return n;
}

function cubicExtrema(p0, p1, p2, p3, extrema) {
    var b = 6 * p2 - 12 * p1 + 6 * p0;
    var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
    var c = 3 * p1 - 3 * p0;

    var n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
            var t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                extrema[n++] = t1;
            }
        }
    } else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
            extrema[0] = -b / (2 * a);
        } else if (disc > 0) {
            var discSqrt = mathSqrt(disc);
            var t1 = (-b + discSqrt) / (2 * a);
            var t2 = (-b - discSqrt) / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                extrema[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                extrema[n++] = t2;
            }
        }
    }
    return n;
}

function cubicSubdivide(p0, p1, p2, p3, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p23 = (p3 - p2) * t + p2;

    var p012 = (p12 - p01) * t + p01;
    var p123 = (p23 - p12) * t + p12;

    var p0123 = (p123 - p012) * t + p012;

    out[0] = p0;
    out[1] = p01;
    out[2] = p012;
    out[3] = p0123;

    out[4] = p0123;
    out[5] = p123;
    out[6] = p23;
    out[7] = p3;
}

function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
    var t;
    var interval = 0.005;
    var d = Infinity;
    var prev;
    var next;
    var d1;
    var d2;

    _v0[0] = x;
    _v0[1] = y;

    for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = cubicAt(x0, x1, x2, x3, _t);
        _v1[1] = cubicAt(y0, y1, y2, y3, _t);
        d1 = Object(__WEBPACK_IMPORTED_MODULE_0__vector__["g" /* distSquare */])(_v0, _v1);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    d = Infinity;

    for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
            break;
        }
        prev = t - interval;
        next = t + interval;

        _v1[0] = cubicAt(x0, x1, x2, x3, prev);
        _v1[1] = cubicAt(y0, y1, y2, y3, prev);

        d1 = Object(__WEBPACK_IMPORTED_MODULE_0__vector__["g" /* distSquare */])(_v1, _v0);

        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        } else {
            _v2[0] = cubicAt(x0, x1, x2, x3, next);
            _v2[1] = cubicAt(y0, y1, y2, y3, next);
            d2 = Object(__WEBPACK_IMPORTED_MODULE_0__vector__["g" /* distSquare */])(_v2, _v0);

            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            } else {
                interval *= 0.5;
            }
        }
    }

    if (out) {
        out[0] = cubicAt(x0, x1, x2, x3, t);
        out[1] = cubicAt(y0, y1, y2, y3, t);
    }

    return mathSqrt(d);
}

function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}

function quadraticDerivativeAt(p0, p1, p2, t) {
    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}

function quadraticRootAt(p0, p1, p2, val, roots) {
    var a = p0 - 2 * p1 + p2;
    var b = 2 * (p1 - p0);
    var c = p0 - val;

    var n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
            var t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
    } else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
            var t1 = -b / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        } else if (disc > 0) {
            var discSqrt = mathSqrt(disc);
            var t1 = (-b + discSqrt) / (2 * a);
            var t2 = (-b - discSqrt) / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
        }
    }
    return n;
}

function quadraticExtremum(p0, p1, p2) {
    var divider = p0 + p2 - 2 * p1;
    if (divider === 0) {
        return 0.5;
    } else {
        return (p0 - p1) / divider;
    }
}

function quadraticSubdivide(p0, p1, p2, t, out) {
    var p01 = (p1 - p0) * t + p0;
    var p12 = (p2 - p1) * t + p1;
    var p012 = (p12 - p01) * t + p01;

    out[0] = p0;
    out[1] = p01;
    out[2] = p012;

    out[3] = p012;
    out[4] = p12;
    out[5] = p2;
}

function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
    var t;
    var interval = 0.005;
    var d = Infinity;

    _v0[0] = x;
    _v0[1] = y;

    for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = quadraticAt(x0, x1, x2, _t);
        _v1[1] = quadraticAt(y0, y1, y2, _t);
        var d1 = Object(__WEBPACK_IMPORTED_MODULE_0__vector__["g" /* distSquare */])(_v0, _v1);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    d = Infinity;

    for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
            break;
        }
        var prev = t - interval;
        var next = t + interval;

        _v1[0] = quadraticAt(x0, x1, x2, prev);
        _v1[1] = quadraticAt(y0, y1, y2, prev);

        var d1 = Object(__WEBPACK_IMPORTED_MODULE_0__vector__["g" /* distSquare */])(_v1, _v0);

        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        } else {
            _v2[0] = quadraticAt(x0, x1, x2, next);
            _v2[1] = quadraticAt(y0, y1, y2, next);
            var d2 = Object(__WEBPACK_IMPORTED_MODULE_0__vector__["g" /* distSquare */])(_v2, _v0);
            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            } else {
                interval *= 0.5;
            }
        }
    }

    if (out) {
        out[0] = quadraticAt(x0, x1, x2, t);
        out[1] = quadraticAt(y0, y1, y2, t);
    }

    return mathSqrt(d);
}

/***/ }),

/***/ 226:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/zrender/src/core/guid.js
var guid = __webpack_require__(91);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/env.js
var core_env = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/util.js
var util = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/vector.js
var vector = __webpack_require__(5);

// CONCATENATED MODULE: ./node_modules/zrender/src/mixin/Draggable.js

function Draggable() {

    this.on('mousedown', this._dragStart, this);
    this.on('mousemove', this._drag, this);
    this.on('mouseup', this._dragEnd, this);
    this.on('globalout', this._dragEnd, this);
}

Draggable.prototype = {

    constructor: Draggable,

    _dragStart: function _dragStart(e) {
        var draggingTarget = e.target;
        if (draggingTarget && draggingTarget.draggable) {
            this._draggingTarget = draggingTarget;
            draggingTarget.dragging = true;
            this._x = e.offsetX;
            this._y = e.offsetY;

            this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
        }
    },

    _drag: function _drag(e) {
        var draggingTarget = this._draggingTarget;
        if (draggingTarget) {

            var x = e.offsetX;
            var y = e.offsetY;

            var dx = x - this._x;
            var dy = y - this._y;
            this._x = x;
            this._y = y;

            draggingTarget.drift(dx, dy, e);
            this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);

            var dropTarget = this.findHover(x, y, draggingTarget).target;
            var lastDropTarget = this._dropTarget;
            this._dropTarget = dropTarget;

            if (draggingTarget !== dropTarget) {
                if (lastDropTarget && dropTarget !== lastDropTarget) {
                    this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
                }
                if (dropTarget && dropTarget !== lastDropTarget) {
                    this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
                }
            }
        }
    },

    _dragEnd: function _dragEnd(e) {
        var draggingTarget = this._draggingTarget;

        if (draggingTarget) {
            draggingTarget.dragging = false;
        }

        this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);

        if (this._dropTarget) {
            this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
        }

        this._draggingTarget = null;
        this._dropTarget = null;
    }

};

function param(target, e) {
    return { target: target, topTarget: e && e.topTarget };
}

/* harmony default export */ var mixin_Draggable = (Draggable);
// EXTERNAL MODULE: ./node_modules/zrender/src/mixin/Eventful.js
var Eventful = __webpack_require__(21);

// CONCATENATED MODULE: ./node_modules/zrender/src/Handler.js







var SILENT = 'silent';

function makeEventPacket(eveType, targetInfo, event) {
    return {
        type: eveType,
        event: event,

        target: targetInfo.target,

        topTarget: targetInfo.topTarget,
        cancelBubble: false,
        offsetX: event.zrX,
        offsetY: event.zrY,
        gestureEvent: event.gestureEvent,
        pinchX: event.pinchX,
        pinchY: event.pinchY,
        pinchScale: event.pinchScale,
        wheelDelta: event.zrDelta,
        zrByTouch: event.zrByTouch,
        which: event.which
    };
}

function EmptyProxy() {}
EmptyProxy.prototype.dispose = function () {};

var Handler_handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];

var Handler_Handler = function Handler(storage, painter, proxy, painterRoot) {
    Eventful["a" /* default */].call(this);

    this.storage = storage;

    this.painter = painter;

    this.painterRoot = painterRoot;

    proxy = proxy || new EmptyProxy();

    this.proxy = proxy;

    proxy.handler = this;

    this._hovered = {};

    this._lastTouchMoment;

    this._lastX;

    this._lastY;

    mixin_Draggable.call(this);

    util["i" /* each */](Handler_handlerNames, function (name) {
        proxy.on && proxy.on(name, this[name], this);
    }, this);
};

Handler_Handler.prototype = {

    constructor: Handler_Handler,

    mousemove: function mousemove(event) {
        var x = event.zrX;
        var y = event.zrY;

        var lastHovered = this._hovered;
        var lastHoveredTarget = lastHovered.target;

        if (lastHoveredTarget && !lastHoveredTarget.__zr) {
            lastHovered = this.findHover(lastHovered.x, lastHovered.y);
            lastHoveredTarget = lastHovered.target;
        }

        var hovered = this._hovered = this.findHover(x, y);
        var hoveredTarget = hovered.target;

        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');

        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
            this.dispatchToElement(lastHovered, 'mouseout', event);
        }

        this.dispatchToElement(hovered, 'mousemove', event);

        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
            this.dispatchToElement(hovered, 'mouseover', event);
        }
    },

    mouseout: function mouseout(event) {
        this.dispatchToElement(this._hovered, 'mouseout', event);

        var element = event.toElement || event.relatedTarget;
        var innerDom;
        do {
            element = element && element.parentNode;
        } while (element && element.nodeType != 9 && !(innerDom = element === this.painterRoot));

        !innerDom && this.trigger('globalout', { event: event });
    },

    resize: function resize(event) {
        this._hovered = {};
    },

    dispatch: function dispatch(eventName, eventArgs) {
        var handler = this[eventName];
        handler && handler.call(this, eventArgs);
    },

    dispose: function dispose() {

        this.proxy.dispose();

        this.storage = this.proxy = this.painter = null;
    },

    setCursorStyle: function setCursorStyle(cursorStyle) {
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(cursorStyle);
    },

    dispatchToElement: function dispatchToElement(targetInfo, eventName, event) {
        targetInfo = targetInfo || {};
        var el = targetInfo.target;
        if (el && el.silent) {
            return;
        }
        var eventHandler = 'on' + eventName;
        var eventPacket = makeEventPacket(eventName, targetInfo, event);

        while (el) {
            el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));

            el.trigger(eventName, eventPacket);

            el = el.parent;

            if (eventPacket.cancelBubble) {
                break;
            }
        }

        if (!eventPacket.cancelBubble) {
            this.trigger(eventName, eventPacket);

            this.painter && this.painter.eachOtherLayer(function (layer) {
                if (typeof layer[eventHandler] == 'function') {
                    layer[eventHandler].call(layer, eventPacket);
                }
                if (layer.trigger) {
                    layer.trigger(eventName, eventPacket);
                }
            });
        }
    },

    findHover: function findHover(x, y, exclude) {
        var list = this.storage.getDisplayList();
        var out = { x: x, y: y };

        for (var i = list.length - 1; i >= 0; i--) {
            var hoverCheckResult;
            if (list[i] !== exclude && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
                !out.topTarget && (out.topTarget = list[i]);
                if (hoverCheckResult !== SILENT) {
                    out.target = list[i];
                    break;
                }
            }
        }

        return out;
    }
};

util["i" /* each */](['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
    Handler_Handler.prototype[name] = function (event) {
        var hovered = this.findHover(event.zrX, event.zrY);
        var hoveredTarget = hovered.target;

        if (name === 'mousedown') {
            this._downEl = hoveredTarget;
            this._downPoint = [event.zrX, event.zrY];

            this._upEl = hoveredTarget;
        } else if (name === 'mosueup') {
            this._upEl = hoveredTarget;
        } else if (name === 'click') {
            if (this._downEl !== this._upEl || !this._downPoint || vector["f" /* dist */](this._downPoint, [event.zrX, event.zrY]) > 4) {
                return;
            }
            this._downPoint = null;
        }

        this.dispatchToElement(hovered, name, event);
    };
});

function isHover(displayable, x, y) {
    if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
        var el = displayable;
        var isSilent;
        while (el) {
            if (el.clipPath && !el.clipPath.contain(x, y)) {
                return false;
            }
            if (el.silent) {
                isSilent = true;
            }
            el = el.parent;
        }
        return isSilent ? SILENT : true;
    }

    return false;
}

util["y" /* mixin */](Handler_Handler, Eventful["a" /* default */]);
util["y" /* mixin */](Handler_Handler, mixin_Draggable);

/* harmony default export */ var src_Handler = (Handler_Handler);
// EXTERNAL MODULE: ./node_modules/zrender/src/container/Group.js
var Group = __webpack_require__(39);

// CONCATENATED MODULE: ./node_modules/zrender/src/core/timsort.js

var DEFAULT_MIN_MERGE = 32;

var DEFAULT_MIN_GALLOPING = 7;

var DEFAULT_TMP_STORAGE_LENGTH = 256;

function minRunLength(n) {
    var r = 0;

    while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
    }

    return n + r;
}

function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;

    if (runHi === hi) {
        return 1;
    }

    if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
            runHi++;
        }

        reverseRun(array, lo, runHi);
    } else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
            runHi++;
        }
    }

    return runHi - lo;
}

function reverseRun(array, lo, hi) {
    hi--;

    while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
    }
}

function binaryInsertionSort(array, lo, hi, start, compare) {
    if (start === lo) {
        start++;
    }

    for (; start < hi; start++) {
        var pivot = array[start];

        var left = lo;
        var right = start;
        var mid;

        while (left < right) {
            mid = left + right >>> 1;

            if (compare(pivot, array[mid]) < 0) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        var n = start - left;

        switch (n) {
            case 3:
                array[left + 3] = array[left + 2];

            case 2:
                array[left + 2] = array[left + 1];

            case 1:
                array[left + 1] = array[left];
                break;
            default:
                while (n > 0) {
                    array[left + n] = array[left + n - 1];
                    n--;
                }
        }

        array[left] = pivot;
    }
}

function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;

            if (offset <= 0) {
                offset = maxOffset;
            }
        }

        if (offset > maxOffset) {
            offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
    } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;

            if (offset <= 0) {
                offset = maxOffset;
            }
        }
        if (offset > maxOffset) {
            offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
    }

    lastOffset++;
    while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) > 0) {
            lastOffset = m + 1;
        } else {
            offset = m;
        }
    }
    return offset;
}

function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0;
    var maxOffset = 0;
    var offset = 1;

    if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;

            if (offset <= 0) {
                offset = maxOffset;
            }
        }

        if (offset > maxOffset) {
            offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
    } else {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
            lastOffset = offset;
            offset = (offset << 1) + 1;

            if (offset <= 0) {
                offset = maxOffset;
            }
        }

        if (offset > maxOffset) {
            offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
    }

    lastOffset++;

    while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) < 0) {
            offset = m;
        } else {
            lastOffset = m + 1;
        }
    }

    return offset;
}

function TimSort(array, compare) {
    var minGallop = DEFAULT_MIN_GALLOPING;
    var length = 0;
    var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
    var stackLength = 0;
    var runStart;
    var runLength;
    var stackSize = 0;

    length = array.length;

    if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
        tmpStorageLength = length >>> 1;
    }

    var tmp = [];

    stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;

    runStart = [];
    runLength = [];

    function pushRun(_runStart, _runLength) {
        runStart[stackSize] = _runStart;
        runLength[stackSize] = _runLength;
        stackSize += 1;
    }

    function mergeRuns() {
        while (stackSize > 1) {
            var n = stackSize - 2;

            if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
                if (runLength[n - 1] < runLength[n + 1]) {
                    n--;
                }
            } else if (runLength[n] > runLength[n + 1]) {
                break;
            }
            mergeAt(n);
        }
    }

    function forceMergeRuns() {
        while (stackSize > 1) {
            var n = stackSize - 2;

            if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
                n--;
            }

            mergeAt(n);
        }
    }

    function mergeAt(i) {
        var start1 = runStart[i];
        var length1 = runLength[i];
        var start2 = runStart[i + 1];
        var length2 = runLength[i + 1];

        runLength[i] = length1 + length2;

        if (i === stackSize - 3) {
            runStart[i + 1] = runStart[i + 2];
            runLength[i + 1] = runLength[i + 2];
        }

        stackSize--;

        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;

        if (length1 === 0) {
            return;
        }

        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

        if (length2 === 0) {
            return;
        }

        if (length1 <= length2) {
            mergeLow(start1, length1, start2, length2);
        } else {
            mergeHigh(start1, length1, start2, length2);
        }
    }

    function mergeLow(start1, length1, start2, length2) {
        var i = 0;

        for (i = 0; i < length1; i++) {
            tmp[i] = array[start1 + i];
        }

        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;

        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
            for (i = 0; i < length1; i++) {
                array[dest + i] = tmp[cursor1 + i];
            }
            return;
        }

        if (length1 === 1) {
            for (i = 0; i < length2; i++) {
                array[dest + i] = array[cursor2 + i];
            }
            array[dest + length2] = tmp[cursor1];
            return;
        }

        var _minGallop = minGallop;
        var count1, count2, exit;

        while (1) {
            count1 = 0;
            count2 = 0;
            exit = false;

            do {
                if (compare(array[cursor2], tmp[cursor1]) < 0) {
                    array[dest++] = array[cursor2++];
                    count2++;
                    count1 = 0;

                    if (--length2 === 0) {
                        exit = true;
                        break;
                    }
                } else {
                    array[dest++] = tmp[cursor1++];
                    count1++;
                    count2 = 0;
                    if (--length1 === 1) {
                        exit = true;
                        break;
                    }
                }
            } while ((count1 | count2) < _minGallop);

            if (exit) {
                break;
            }

            do {
                count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

                if (count1 !== 0) {
                    for (i = 0; i < count1; i++) {
                        array[dest + i] = tmp[cursor1 + i];
                    }

                    dest += count1;
                    cursor1 += count1;
                    length1 -= count1;
                    if (length1 <= 1) {
                        exit = true;
                        break;
                    }
                }

                array[dest++] = array[cursor2++];

                if (--length2 === 0) {
                    exit = true;
                    break;
                }

                count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

                if (count2 !== 0) {
                    for (i = 0; i < count2; i++) {
                        array[dest + i] = array[cursor2 + i];
                    }

                    dest += count2;
                    cursor2 += count2;
                    length2 -= count2;

                    if (length2 === 0) {
                        exit = true;
                        break;
                    }
                }
                array[dest++] = tmp[cursor1++];

                if (--length1 === 1) {
                    exit = true;
                    break;
                }

                _minGallop--;
            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

            if (exit) {
                break;
            }

            if (_minGallop < 0) {
                _minGallop = 0;
            }

            _minGallop += 2;
        }

        minGallop = _minGallop;

        minGallop < 1 && (minGallop = 1);

        if (length1 === 1) {
            for (i = 0; i < length2; i++) {
                array[dest + i] = array[cursor2 + i];
            }
            array[dest + length2] = tmp[cursor1];
        } else if (length1 === 0) {
            throw new Error();
        } else {
            for (i = 0; i < length1; i++) {
                array[dest + i] = tmp[cursor1 + i];
            }
        }
    }

    function mergeHigh(start1, length1, start2, length2) {
        var i = 0;

        for (i = 0; i < length2; i++) {
            tmp[i] = array[start2 + i];
        }

        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;

        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
            customCursor = dest - (length2 - 1);

            for (i = 0; i < length2; i++) {
                array[customCursor + i] = tmp[i];
            }

            return;
        }

        if (length2 === 1) {
            dest -= length1;
            cursor1 -= length1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;

            for (i = length1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
            }

            array[dest] = tmp[cursor2];
            return;
        }

        var _minGallop = minGallop;

        while (true) {
            var count1 = 0;
            var count2 = 0;
            var exit = false;

            do {
                if (compare(tmp[cursor2], array[cursor1]) < 0) {
                    array[dest--] = array[cursor1--];
                    count1++;
                    count2 = 0;
                    if (--length1 === 0) {
                        exit = true;
                        break;
                    }
                } else {
                    array[dest--] = tmp[cursor2--];
                    count2++;
                    count1 = 0;
                    if (--length2 === 1) {
                        exit = true;
                        break;
                    }
                }
            } while ((count1 | count2) < _minGallop);

            if (exit) {
                break;
            }

            do {
                count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

                if (count1 !== 0) {
                    dest -= count1;
                    cursor1 -= count1;
                    length1 -= count1;
                    customDest = dest + 1;
                    customCursor = cursor1 + 1;

                    for (i = count1 - 1; i >= 0; i--) {
                        array[customDest + i] = array[customCursor + i];
                    }

                    if (length1 === 0) {
                        exit = true;
                        break;
                    }
                }

                array[dest--] = tmp[cursor2--];

                if (--length2 === 1) {
                    exit = true;
                    break;
                }

                count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

                if (count2 !== 0) {
                    dest -= count2;
                    cursor2 -= count2;
                    length2 -= count2;
                    customDest = dest + 1;
                    customCursor = cursor2 + 1;

                    for (i = 0; i < count2; i++) {
                        array[customDest + i] = tmp[customCursor + i];
                    }

                    if (length2 <= 1) {
                        exit = true;
                        break;
                    }
                }

                array[dest--] = array[cursor1--];

                if (--length1 === 0) {
                    exit = true;
                    break;
                }

                _minGallop--;
            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

            if (exit) {
                break;
            }

            if (_minGallop < 0) {
                _minGallop = 0;
            }

            _minGallop += 2;
        }

        minGallop = _minGallop;

        if (minGallop < 1) {
            minGallop = 1;
        }

        if (length2 === 1) {
            dest -= length1;
            cursor1 -= length1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;

            for (i = length1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
            }

            array[dest] = tmp[cursor2];
        } else if (length2 === 0) {
            throw new Error();
        } else {
            customCursor = dest - (length2 - 1);
            for (i = 0; i < length2; i++) {
                array[customCursor + i] = tmp[i];
            }
        }
    }

    this.mergeRuns = mergeRuns;
    this.forceMergeRuns = forceMergeRuns;
    this.pushRun = pushRun;
}

function sort(array, compare, lo, hi) {
    if (!lo) {
        lo = 0;
    }
    if (!hi) {
        hi = array.length;
    }

    var remaining = hi - lo;

    if (remaining < 2) {
        return;
    }

    var runLength = 0;

    if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
    }

    var ts = new TimSort(array, compare);

    var minRun = minRunLength(remaining);

    do {
        runLength = makeAscendingRun(array, lo, hi, compare);
        if (runLength < minRun) {
            var force = remaining;
            if (force > minRun) {
                force = minRun;
            }

            binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
            runLength = force;
        }

        ts.pushRun(lo, runLength);
        ts.mergeRuns();

        remaining -= runLength;
        lo += runLength;
    } while (remaining !== 0);

    ts.forceMergeRuns();
}
// CONCATENATED MODULE: ./node_modules/zrender/src/Storage.js








function shapeCompareFunc(a, b) {
    if (a.zlevel === b.zlevel) {
        if (a.z === b.z) {
            return a.z2 - b.z2;
        }
        return a.z - b.z;
    }
    return a.zlevel - b.zlevel;
}

var Storage = function Storage() {
    this._roots = [];

    this._displayList = [];

    this._displayListLen = 0;
};

Storage.prototype = {

    constructor: Storage,

    traverse: function traverse(cb, context) {
        for (var i = 0; i < this._roots.length; i++) {
            this._roots[i].traverse(cb, context);
        }
    },

    getDisplayList: function getDisplayList(update, includeIgnore) {
        includeIgnore = includeIgnore || false;
        if (update) {
            this.updateDisplayList(includeIgnore);
        }
        return this._displayList;
    },

    updateDisplayList: function updateDisplayList(includeIgnore) {
        this._displayListLen = 0;
        var roots = this._roots;
        var displayList = this._displayList;
        for (var i = 0, len = roots.length; i < len; i++) {
            this._updateAndAddDisplayable(roots[i], null, includeIgnore);
        }
        displayList.length = this._displayListLen;

        core_env["a" /* default */].canvasSupported && sort(displayList, shapeCompareFunc);
    },

    _updateAndAddDisplayable: function _updateAndAddDisplayable(el, clipPaths, includeIgnore) {

        if (el.ignore && !includeIgnore) {
            return;
        }

        el.beforeUpdate();

        if (el.__dirty) {

            el.update();
        }

        el.afterUpdate();

        var userSetClipPath = el.clipPath;
        if (userSetClipPath) {
            if (clipPaths) {
                clipPaths = clipPaths.slice();
            } else {
                clipPaths = [];
            }

            var currentClipPath = userSetClipPath;
            var parentClipPath = el;

            while (currentClipPath) {
                currentClipPath.parent = parentClipPath;
                currentClipPath.updateTransform();

                clipPaths.push(currentClipPath);

                parentClipPath = currentClipPath;
                currentClipPath = currentClipPath.clipPath;
            }
        }

        if (el.isGroup) {
            var children = el._children;

            for (var i = 0; i < children.length; i++) {
                var child = children[i];

                if (el.__dirty) {
                    child.__dirty = true;
                }

                this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
            }

            el.__dirty = false;
        } else {
            el.__clipPaths = clipPaths;

            this._displayList[this._displayListLen++] = el;
        }
    },

    addRoot: function addRoot(el) {
        if (el.__storage === this) {
            return;
        }

        if (el instanceof Group["a" /* default */]) {
            el.addChildrenToStorage(this);
        }

        this.addToStorage(el);
        this._roots.push(el);
    },

    delRoot: function delRoot(el) {
        if (el == null) {
            for (var i = 0; i < this._roots.length; i++) {
                var root = this._roots[i];
                if (root instanceof Group["a" /* default */]) {
                    root.delChildrenFromStorage(this);
                }
            }

            this._roots = [];
            this._displayList = [];
            this._displayListLen = 0;

            return;
        }

        if (el instanceof Array) {
            for (var i = 0, l = el.length; i < l; i++) {
                this.delRoot(el[i]);
            }
            return;
        }

        var idx = util["n" /* indexOf */](this._roots, el);
        if (idx >= 0) {
            this.delFromStorage(el);
            this._roots.splice(idx, 1);
            if (el instanceof Group["a" /* default */]) {
                el.delChildrenFromStorage(this);
            }
        }
    },

    addToStorage: function addToStorage(el) {
        el.__storage = this;
        el.dirty(false);

        return this;
    },

    delFromStorage: function delFromStorage(el) {
        if (el) {
            el.__storage = null;
        }

        return this;
    },

    dispose: function dispose() {
        this._renderList = this._roots = null;
    },

    displayableSortFunc: shapeCompareFunc
};

/* harmony default export */ var src_Storage = (Storage);
// EXTERNAL MODULE: ./node_modules/zrender/src/config.js
var src_config = __webpack_require__(41);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/log.js
var log = __webpack_require__(96);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/BoundingRect.js
var BoundingRect = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Style.js
var Style = __webpack_require__(97);

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Pattern.js
var Pattern = __webpack_require__(98);

// CONCATENATED MODULE: ./node_modules/zrender/src/Layer.js







function returnFalse() {
    return false;
}

function createDom(id, painter, dpr) {
    var newDom = util["e" /* createCanvas */]();
    var width = painter.getWidth();
    var height = painter.getHeight();

    var newDomStyle = newDom.style;

    newDomStyle.position = 'absolute';
    newDomStyle.left = 0;
    newDomStyle.top = 0;
    newDomStyle.width = width + 'px';
    newDomStyle.height = height + 'px';
    newDom.width = width * dpr;
    newDom.height = height * dpr;

    newDom.setAttribute('data-zr-dom-id', id);
    return newDom;
}

var Layer_Layer = function Layer(id, painter, dpr) {
    var dom;
    dpr = dpr || src_config["b" /* devicePixelRatio */];
    if (typeof id === 'string') {
        dom = createDom(id, painter, dpr);
    } else if (util["t" /* isObject */](id)) {
            dom = id;
            id = dom.id;
        }
    this.id = id;
    this.dom = dom;

    var domStyle = dom.style;
    if (domStyle) {
        dom.onselectstart = returnFalse;
        domStyle['-webkit-user-select'] = 'none';
        domStyle['user-select'] = 'none';
        domStyle['-webkit-touch-callout'] = 'none';
        domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
        domStyle['padding'] = 0;
        domStyle['margin'] = 0;
        domStyle['border-width'] = 0;
    }

    this.domBack = null;
    this.ctxBack = null;

    this.painter = painter;

    this.config = null;

    this.clearColor = 0;

    this.motionBlur = false;

    this.lastFrameAlpha = 0.7;

    this.dpr = dpr;
};

Layer_Layer.prototype = {

    constructor: Layer_Layer,

    elCount: 0,

    __dirty: true,

    initContext: function initContext() {
        this.ctx = this.dom.getContext('2d');
        this.ctx.__currentValues = {};
        this.ctx.dpr = this.dpr;
    },

    createBackBuffer: function createBackBuffer() {
        var dpr = this.dpr;

        this.domBack = createDom('back-' + this.id, this.painter, dpr);
        this.ctxBack = this.domBack.getContext('2d');
        this.ctxBack.__currentValues = {};

        if (dpr != 1) {
            this.ctxBack.scale(dpr, dpr);
        }
    },

    resize: function resize(width, height) {
        var dpr = this.dpr;

        var dom = this.dom;
        var domStyle = dom.style;
        var domBack = this.domBack;

        domStyle.width = width + 'px';
        domStyle.height = height + 'px';

        dom.width = width * dpr;
        dom.height = height * dpr;

        if (domBack) {
            domBack.width = width * dpr;
            domBack.height = height * dpr;

            if (dpr != 1) {
                this.ctxBack.scale(dpr, dpr);
            }
        }
    },

    clear: function clear(clearAll) {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;

        var clearColor = this.clearColor;
        var haveMotionBLur = this.motionBlur && !clearAll;
        var lastFrameAlpha = this.lastFrameAlpha;

        var dpr = this.dpr;

        if (haveMotionBLur) {
            if (!this.domBack) {
                this.createBackBuffer();
            }

            this.ctxBack.globalCompositeOperation = 'copy';
            this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
        }

        ctx.clearRect(0, 0, width, height);
        if (clearColor) {
            var clearColorGradientOrPattern;

            if (clearColor.colorStops) {
                clearColorGradientOrPattern = clearColor.__canvasGradient || Style["a" /* default */].getGradient(ctx, clearColor, {
                    x: 0,
                    y: 0,
                    width: width,
                    height: height
                });

                clearColor.__canvasGradient = clearColorGradientOrPattern;
            } else if (clearColor.image) {
                    clearColorGradientOrPattern = Pattern["a" /* default */].prototype.getCanvasPattern.call(clearColor, ctx);
                }
            ctx.save();
            ctx.fillStyle = clearColorGradientOrPattern || clearColor;
            ctx.fillRect(0, 0, width, height);
            ctx.restore();
        }

        if (haveMotionBLur) {
            var domBack = this.domBack;
            ctx.save();
            ctx.globalAlpha = lastFrameAlpha;
            ctx.drawImage(domBack, 0, 0, width, height);
            ctx.restore();
        }
    }
};

/* harmony default export */ var src_Layer = (Layer_Layer);
// CONCATENATED MODULE: ./node_modules/zrender/src/animation/requestAnimationFrame.js

/* harmony default export */ var requestAnimationFrame = (typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
    setTimeout(func, 16);
});
// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Image.js
var Image = __webpack_require__(99);

// CONCATENATED MODULE: ./node_modules/zrender/src/Painter.js











var MAX_PROGRESSIVE_LAYER_NUMBER = 5;

function parseInt10(val) {
    return parseInt(val, 10);
}

function isLayerValid(layer) {
    if (!layer) {
        return false;
    }

    if (layer.__builtin__) {
        return true;
    }

    if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
        return false;
    }

    return true;
}

function preProcessLayer(layer) {
    layer.__unusedCount++;
}

function postProcessLayer(layer) {
    if (layer.__unusedCount == 1) {
        layer.clear();
    }
}

var tmpRect = new BoundingRect["a" /* default */](0, 0, 0, 0);
var viewRect = new BoundingRect["a" /* default */](0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
    tmpRect.copy(el.getBoundingRect());
    if (el.transform) {
        tmpRect.applyTransform(el.transform);
    }
    viewRect.width = width;
    viewRect.height = height;
    return !tmpRect.intersect(viewRect);
}

function isClipPathChanged(clipPaths, prevClipPaths) {
    if (clipPaths == prevClipPaths) {
        return false;
    }

    if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
        return true;
    }
    for (var i = 0; i < clipPaths.length; i++) {
        if (clipPaths[i] !== prevClipPaths[i]) {
            return true;
        }
    }
}

function doClip(clipPaths, ctx) {
    for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];

        clipPath.setTransform(ctx);
        ctx.beginPath();
        clipPath.buildPath(ctx, clipPath.shape);
        ctx.clip();

        clipPath.restoreTransform(ctx);
    }
}

function createRoot(width, height) {
    var domRoot = document.createElement('div');

    domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';

    return domRoot;
}

var Painter_Painter = function Painter(root, storage, opts) {

    this.type = 'canvas';

    var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';

    this._opts = opts = util["k" /* extend */]({}, opts || {});

    this.dpr = opts.devicePixelRatio || src_config["b" /* devicePixelRatio */];

    this._singleCanvas = singleCanvas;

    this.root = root;

    var rootStyle = root.style;

    if (rootStyle) {
        rootStyle['-webkit-tap-highlight-color'] = 'transparent';
        rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';

        root.innerHTML = '';
    }

    this.storage = storage;

    var zlevelList = this._zlevelList = [];

    var layers = this._layers = {};

    this._layerConfig = {};

    if (!singleCanvas) {
        this._width = this._getSize(0);
        this._height = this._getSize(1);

        var domRoot = this._domRoot = createRoot(this._width, this._height);
        root.appendChild(domRoot);
    } else {
        if (opts.width != null) {
            root.width = opts.width;
        }
        if (opts.height != null) {
            root.height = opts.height;
        }

        var width = root.width;
        var height = root.height;
        this._width = width;
        this._height = height;

        var mainLayer = new src_Layer(root, this, 1);
        mainLayer.initContext();

        layers[0] = mainLayer;
        zlevelList.push(0);

        this._domRoot = root;
    }

    this._progressiveLayers = [];

    this._hoverlayer;

    this._hoverElements = [];
};

Painter_Painter.prototype = {

    constructor: Painter_Painter,

    getType: function getType() {
        return 'canvas';
    },

    isSingleCanvas: function isSingleCanvas() {
        return this._singleCanvas;
    },

    getViewportRoot: function getViewportRoot() {
        return this._domRoot;
    },

    getViewportRootOffset: function getViewportRootOffset() {
        var viewportRoot = this.getViewportRoot();
        if (viewportRoot) {
            return {
                offsetLeft: viewportRoot.offsetLeft || 0,
                offsetTop: viewportRoot.offsetTop || 0
            };
        }
    },

    refresh: function refresh(paintAll) {

        var list = this.storage.getDisplayList(true);

        var zlevelList = this._zlevelList;

        this._paintList(list, paintAll);

        for (var i = 0; i < zlevelList.length; i++) {
            var z = zlevelList[i];
            var layer = this._layers[z];
            if (!layer.__builtin__ && layer.refresh) {
                layer.refresh();
            }
        }

        this.refreshHover();

        if (this._progressiveLayers.length) {
            this._startProgessive();
        }

        return this;
    },

    addHover: function addHover(el, hoverStyle) {
        if (el.__hoverMir) {
            return;
        }
        var elMirror = new el.constructor({
            style: el.style,
            shape: el.shape
        });
        elMirror.__from = el;
        el.__hoverMir = elMirror;
        elMirror.setStyle(hoverStyle);
        this._hoverElements.push(elMirror);
    },

    removeHover: function removeHover(el) {
        var elMirror = el.__hoverMir;
        var hoverElements = this._hoverElements;
        var idx = util["n" /* indexOf */](hoverElements, elMirror);
        if (idx >= 0) {
            hoverElements.splice(idx, 1);
        }
        el.__hoverMir = null;
    },

    clearHover: function clearHover(el) {
        var hoverElements = this._hoverElements;
        for (var i = 0; i < hoverElements.length; i++) {
            var from = hoverElements[i].__from;
            if (from) {
                from.__hoverMir = null;
            }
        }
        hoverElements.length = 0;
    },

    refreshHover: function refreshHover() {
        var hoverElements = this._hoverElements;
        var len = hoverElements.length;
        var hoverLayer = this._hoverlayer;
        hoverLayer && hoverLayer.clear();

        if (!len) {
            return;
        }
        sort(hoverElements, this.storage.displayableSortFunc);

        if (!hoverLayer) {
            hoverLayer = this._hoverlayer = this.getLayer(1e5);
        }

        var scope = {};
        hoverLayer.ctx.save();
        for (var i = 0; i < len;) {
            var el = hoverElements[i];
            var originalEl = el.__from;

            if (!(originalEl && originalEl.__zr)) {
                hoverElements.splice(i, 1);
                originalEl.__hoverMir = null;
                len--;
                continue;
            }
            i++;

            if (!originalEl.invisible) {
                el.transform = originalEl.transform;
                el.invTransform = originalEl.invTransform;
                el.__clipPaths = originalEl.__clipPaths;

                this._doPaintEl(el, hoverLayer, true, scope);
            }
        }
        hoverLayer.ctx.restore();
    },

    _startProgessive: function _startProgessive() {
        var self = this;

        if (!self._furtherProgressive) {
            return;
        }

        var token = self._progressiveToken = +new Date();

        self._progress++;
        requestAnimationFrame(step);

        function step() {
            if (token === self._progressiveToken && self.storage) {

                self._doPaintList(self.storage.getDisplayList());

                if (self._furtherProgressive) {
                    self._progress++;
                    requestAnimationFrame(step);
                } else {
                    self._progressiveToken = -1;
                }
            }
        }
    },

    _clearProgressive: function _clearProgressive() {
        this._progressiveToken = -1;
        this._progress = 0;
        util["i" /* each */](this._progressiveLayers, function (layer) {
            layer.__dirty && layer.clear();
        });
    },

    _paintList: function _paintList(list, paintAll) {

        if (paintAll == null) {
            paintAll = false;
        }

        this._updateLayerStatus(list);

        this._clearProgressive();

        this.eachBuiltinLayer(preProcessLayer);

        this._doPaintList(list, paintAll);

        this.eachBuiltinLayer(postProcessLayer);
    },

    _doPaintList: function _doPaintList(list, paintAll) {
        var currentLayer;
        var currentZLevel;
        var ctx;

        var scope;

        var progressiveLayerIdx = 0;
        var currentProgressiveLayer;

        var width = this._width;
        var height = this._height;
        var layerProgress;
        var frame = this._progress;
        function flushProgressiveLayer(layer) {
            var dpr = ctx.dpr || 1;
            ctx.save();
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            currentLayer.__dirty = true;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
            ctx.restore();
        }

        for (var i = 0, l = list.length; i < l; i++) {
            var el = list[i];
            var elZLevel = this._singleCanvas ? 0 : el.zlevel;

            var elFrame = el.__frame;

            if (elFrame < 0 && currentProgressiveLayer) {
                flushProgressiveLayer(currentProgressiveLayer);
                currentProgressiveLayer = null;
            }

            if (currentZLevel !== elZLevel) {
                if (ctx) {
                    ctx.restore();
                }

                scope = {};

                currentZLevel = elZLevel;
                currentLayer = this.getLayer(currentZLevel);

                if (!currentLayer.__builtin__) {
                    Object(log["a" /* default */])('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
                }

                ctx = currentLayer.ctx;
                ctx.save();

                currentLayer.__unusedCount = 0;

                if (currentLayer.__dirty || paintAll) {
                    currentLayer.clear();
                }
            }

            if (!(currentLayer.__dirty || paintAll)) {
                continue;
            }

            if (elFrame >= 0) {
                if (!currentProgressiveLayer) {
                    currentProgressiveLayer = this._progressiveLayers[Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)];

                    currentProgressiveLayer.ctx.save();
                    currentProgressiveLayer.renderScope = {};

                    if (currentProgressiveLayer && currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) {
                        i = currentProgressiveLayer.__nextIdxNotProg - 1;

                        continue;
                    }

                    layerProgress = currentProgressiveLayer.__progress;

                    if (!currentProgressiveLayer.__dirty) {
                        frame = layerProgress;
                    }

                    currentProgressiveLayer.__progress = frame + 1;
                }

                if (elFrame === frame) {
                    this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
                }
            } else {
                this._doPaintEl(el, currentLayer, paintAll, scope);
            }

            el.__dirty = false;
        }

        if (currentProgressiveLayer) {
            flushProgressiveLayer(currentProgressiveLayer);
        }

        ctx && ctx.restore();


        this._furtherProgressive = false;
        util["i" /* each */](this._progressiveLayers, function (layer) {
            if (layer.__maxProgress >= layer.__progress) {
                this._furtherProgressive = true;
            }
        }, this);
    },

    _doPaintEl: function _doPaintEl(el, currentLayer, forcePaint, scope) {
        var ctx = currentLayer.ctx;
        var m = el.transform;
        if ((currentLayer.__dirty || forcePaint) && !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {

            var clipPaths = el.__clipPaths;

            if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
                if (scope.prevElClipPaths) {
                    scope.prevClipLayer.ctx.restore();
                    scope.prevClipLayer = scope.prevElClipPaths = null;

                    scope.prevEl = null;
                }

                if (clipPaths) {
                    ctx.save();
                    doClip(clipPaths, ctx);
                    scope.prevClipLayer = currentLayer;
                    scope.prevElClipPaths = clipPaths;
                }
            }
            el.beforeBrush && el.beforeBrush(ctx);

            el.brush(ctx, scope.prevEl || null);
            scope.prevEl = el;

            el.afterBrush && el.afterBrush(ctx);
        }
    },

    getLayer: function getLayer(zlevel) {
        if (this._singleCanvas) {
            return this._layers[0];
        }

        var layer = this._layers[zlevel];
        if (!layer) {
            layer = new src_Layer('zr_' + zlevel, this, this.dpr);
            layer.__builtin__ = true;

            if (this._layerConfig[zlevel]) {
                util["w" /* merge */](layer, this._layerConfig[zlevel], true);
            }

            this.insertLayer(zlevel, layer);

            layer.initContext();
        }

        return layer;
    },

    insertLayer: function insertLayer(zlevel, layer) {

        var layersMap = this._layers;
        var zlevelList = this._zlevelList;
        var len = zlevelList.length;
        var prevLayer = null;
        var i = -1;
        var domRoot = this._domRoot;

        if (layersMap[zlevel]) {
            Object(log["a" /* default */])('ZLevel ' + zlevel + ' has been used already');
            return;
        }

        if (!isLayerValid(layer)) {
            Object(log["a" /* default */])('Layer of zlevel ' + zlevel + ' is not valid');
            return;
        }

        if (len > 0 && zlevel > zlevelList[0]) {
            for (i = 0; i < len - 1; i++) {
                if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
                    break;
                }
            }
            prevLayer = layersMap[zlevelList[i]];
        }
        zlevelList.splice(i + 1, 0, zlevel);

        layersMap[zlevel] = layer;

        if (!layer.virtual) {
            if (prevLayer) {
                var prevDom = prevLayer.dom;
                if (prevDom.nextSibling) {
                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);
                } else {
                    domRoot.appendChild(layer.dom);
                }
            } else {
                if (domRoot.firstChild) {
                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
                } else {
                    domRoot.appendChild(layer.dom);
                }
            }
        }
    },

    eachLayer: function eachLayer(cb, context) {
        var zlevelList = this._zlevelList;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
            z = zlevelList[i];
            cb.call(context, this._layers[z], z);
        }
    },

    eachBuiltinLayer: function eachBuiltinLayer(cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
            z = zlevelList[i];
            layer = this._layers[z];
            if (layer.__builtin__) {
                cb.call(context, layer, z);
            }
        }
    },

    eachOtherLayer: function eachOtherLayer(cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
            z = zlevelList[i];
            layer = this._layers[z];
            if (!layer.__builtin__) {
                cb.call(context, layer, z);
            }
        }
    },

    getLayers: function getLayers() {
        return this._layers;
    },

    _updateLayerStatus: function _updateLayerStatus(list) {

        var layers = this._layers;
        var progressiveLayers = this._progressiveLayers;

        var elCountsLastFrame = {};
        var progressiveElCountsLastFrame = {};

        this.eachBuiltinLayer(function (layer, z) {
            elCountsLastFrame[z] = layer.elCount;
            layer.elCount = 0;
            layer.__dirty = false;
        });

        util["i" /* each */](progressiveLayers, function (layer, idx) {
            progressiveElCountsLastFrame[idx] = layer.elCount;
            layer.elCount = 0;
            layer.__dirty = false;
        });

        var progressiveLayerCount = 0;
        var currentProgressiveLayer;
        var lastProgressiveKey;
        var frameCount = 0;
        for (var i = 0, l = list.length; i < l; i++) {
            var el = list[i];
            var zlevel = this._singleCanvas ? 0 : el.zlevel;
            var layer = layers[zlevel];
            var elProgress = el.progressive;
            if (layer) {
                layer.elCount++;
                layer.__dirty = layer.__dirty || el.__dirty;
            }

            if (elProgress >= 0) {
                if (lastProgressiveKey !== elProgress) {
                    lastProgressiveKey = elProgress;
                    frameCount++;
                }
                var elFrame = el.__frame = frameCount - 1;
                if (!currentProgressiveLayer) {
                    var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
                    currentProgressiveLayer = progressiveLayers[idx];
                    if (!currentProgressiveLayer) {
                        currentProgressiveLayer = progressiveLayers[idx] = new src_Layer('progressive', this, this.dpr);
                        currentProgressiveLayer.initContext();
                    }
                    currentProgressiveLayer.__maxProgress = 0;
                }
                currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
                currentProgressiveLayer.elCount++;

                currentProgressiveLayer.__maxProgress = Math.max(currentProgressiveLayer.__maxProgress, elFrame);

                if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
                    layer.__dirty = true;
                }
            } else {
                el.__frame = -1;

                if (currentProgressiveLayer) {
                    currentProgressiveLayer.__nextIdxNotProg = i;
                    progressiveLayerCount++;
                    currentProgressiveLayer = null;
                }
            }
        }

        if (currentProgressiveLayer) {
            progressiveLayerCount++;
            currentProgressiveLayer.__nextIdxNotProg = i;
        }

        this.eachBuiltinLayer(function (layer, z) {
            if (elCountsLastFrame[z] !== layer.elCount) {
                layer.__dirty = true;
            }
        });

        progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
        util["i" /* each */](progressiveLayers, function (layer, idx) {
            if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
                el.__dirty = true;
            }
            if (layer.__dirty) {
                layer.__progress = 0;
            }
        });
    },

    clear: function clear() {
        this.eachBuiltinLayer(this._clearLayer);
        return this;
    },

    _clearLayer: function _clearLayer(layer) {
        layer.clear();
    },

    configLayer: function configLayer(zlevel, config) {
        if (config) {
            var layerConfig = this._layerConfig;
            if (!layerConfig[zlevel]) {
                layerConfig[zlevel] = config;
            } else {
                util["w" /* merge */](layerConfig[zlevel], config, true);
            }

            var layer = this._layers[zlevel];

            if (layer) {
                util["w" /* merge */](layer, layerConfig[zlevel], true);
            }
        }
    },

    delLayer: function delLayer(zlevel) {
        var layers = this._layers;
        var zlevelList = this._zlevelList;
        var layer = layers[zlevel];
        if (!layer) {
            return;
        }
        layer.dom.parentNode.removeChild(layer.dom);
        delete layers[zlevel];

        zlevelList.splice(util["n" /* indexOf */](zlevelList, zlevel), 1);
    },

    resize: function resize(width, height) {
        var domRoot = this._domRoot;

        domRoot.style.display = 'none';

        var opts = this._opts;
        width != null && (opts.width = width);
        height != null && (opts.height = height);

        width = this._getSize(0);
        height = this._getSize(1);

        domRoot.style.display = '';

        if (this._width != width || height != this._height) {
            domRoot.style.width = width + 'px';
            domRoot.style.height = height + 'px';

            for (var id in this._layers) {
                if (this._layers.hasOwnProperty(id)) {
                    this._layers[id].resize(width, height);
                }
            }
            util["i" /* each */](this._progressiveLayers, function (layer) {
                layer.resize(width, height);
            });

            this.refresh(true);
        }

        this._width = width;
        this._height = height;

        return this;
    },

    clearLayer: function clearLayer(zlevel) {
        var layer = this._layers[zlevel];
        if (layer) {
            layer.clear();
        }
    },

    dispose: function dispose() {
        this.root.innerHTML = '';

        this.root = this.storage = this._domRoot = this._layers = null;
    },

    getRenderedCanvas: function getRenderedCanvas(opts) {
        opts = opts || {};
        if (this._singleCanvas) {
            return this._layers[0].dom;
        }

        var imageLayer = new src_Layer('image', this, opts.pixelRatio || this.dpr);
        imageLayer.initContext();

        imageLayer.clearColor = opts.backgroundColor;
        imageLayer.clear();

        var displayList = this.storage.getDisplayList(true);

        var scope = {};
        var zlevel;

        var self = this;
        function findAndDrawOtherLayer(smaller, larger) {
            var zlevelList = self._zlevelList;
            if (smaller == null) {
                smaller = -Infinity;
            }
            var intermediateLayer;
            for (var i = 0; i < zlevelList.length; i++) {
                var z = zlevelList[i];
                var layer = self._layers[z];
                if (!layer.__builtin__ && z > smaller && z < larger) {
                    intermediateLayer = layer;
                    break;
                }
            }
            if (intermediateLayer && intermediateLayer.renderToCanvas) {
                imageLayer.ctx.save();
                intermediateLayer.renderToCanvas(imageLayer.ctx);
                imageLayer.ctx.restore();
            }
        }
        for (var i = 0; i < displayList.length; i++) {
            var el = displayList[i];

            if (el.zlevel !== zlevel) {
                findAndDrawOtherLayer(zlevel, el.zlevel);
                zlevel = el.zlevel;
            }
            this._doPaintEl(el, imageLayer, true, scope);
        }

        findAndDrawOtherLayer(zlevel, Infinity);

        return imageLayer.dom;
    },

    getWidth: function getWidth() {
        return this._width;
    },

    getHeight: function getHeight() {
        return this._height;
    },

    _getSize: function _getSize(whIdx) {
        var opts = this._opts;
        var wh = ['width', 'height'][whIdx];
        var cwh = ['clientWidth', 'clientHeight'][whIdx];
        var plt = ['paddingLeft', 'paddingTop'][whIdx];
        var prb = ['paddingRight', 'paddingBottom'][whIdx];

        if (opts[wh] != null && opts[wh] !== 'auto') {
            return parseFloat(opts[wh]);
        }

        var root = this.root;

        var stl = document.defaultView.getComputedStyle(root);

        return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
    },

    pathToImage: function pathToImage(path, dpr) {
        dpr = dpr || this.dpr;

        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var rect = path.getBoundingRect();
        var style = path.style;
        var shadowBlurSize = style.shadowBlur;
        var shadowOffsetX = style.shadowOffsetX;
        var shadowOffsetY = style.shadowOffsetY;
        var lineWidth = style.hasStroke() ? style.lineWidth : 0;

        var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
        var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
        var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
        var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
        var width = rect.width + leftMargin + rightMargin;
        var height = rect.height + topMargin + bottomMargin;

        canvas.width = width * dpr;
        canvas.height = height * dpr;

        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);
        ctx.dpr = dpr;

        var pathTransform = {
            position: path.position,
            rotation: path.rotation,
            scale: path.scale
        };
        path.position = [leftMargin - rect.x, topMargin - rect.y];
        path.rotation = 0;
        path.scale = [1, 1];
        path.updateTransform();
        if (path) {
            path.brush(ctx);
        }

        var ImageShape = Image["a" /* default */];
        var imgShape = new ImageShape({
            style: {
                x: 0,
                y: 0,
                image: canvas
            }
        });

        if (pathTransform.position != null) {
            imgShape.position = path.position = pathTransform.position;
        }

        if (pathTransform.rotation != null) {
            imgShape.rotation = path.rotation = pathTransform.rotation;
        }

        if (pathTransform.scale != null) {
            imgShape.scale = path.scale = pathTransform.scale;
        }

        return imgShape;
    }
};

/* harmony default export */ var src_Painter = (Painter_Painter);
// CONCATENATED MODULE: ./node_modules/zrender/src/core/event.js





var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;

var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;

function getBoundingClientRect(el) {
    return el.getBoundingClientRect ? el.getBoundingClientRect() : { left: 0, top: 0 };
}

function clientToLocal(el, e, out, calculate) {
    out = out || {};

    if (calculate || !core_env["a" /* default */].canvasSupported) {
        defaultGetZrXY(el, e, out);
    } else if (core_env["a" /* default */].browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
            out.zrX = e.layerX;
            out.zrY = e.layerY;
        } else if (e.offsetX != null) {
                out.zrX = e.offsetX;
                out.zrY = e.offsetY;
            } else {
                    defaultGetZrXY(el, e, out);
                }

    return out;
}

function defaultGetZrXY(el, e, out) {
    var box = getBoundingClientRect(el);
    out.zrX = e.clientX - box.left;
    out.zrY = e.clientY - box.top;
}

function normalizeEvent(el, e, calculate) {

    e = e || window.event;

    if (e.zrX != null) {
        return e;
    }

    var eventType = e.type;
    var isTouch = eventType && eventType.indexOf('touch') >= 0;

    if (!isTouch) {
        clientToLocal(el, e, e, calculate);
        e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
    } else {
        var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
        touch && clientToLocal(el, touch, e, calculate);
    }

    var button = e.button;
    if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
        e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
    }

    return e;
}

function addEventListener(el, name, handler) {
    if (isDomLevel2) {
        el.addEventListener(name, handler);
    } else {
        el.attachEvent('on' + name, handler);
    }
}

function removeEventListener(el, name, handler) {
    if (isDomLevel2) {
        el.removeEventListener(name, handler);
    } else {
        el.detachEvent('on' + name, handler);
    }
}

var stop = isDomLevel2 ? function (e) {
    e.preventDefault();
    e.stopPropagation();
    e.cancelBubble = true;
} : function (e) {
    e.returnValue = false;
    e.cancelBubble = true;
};

function notLeftMouse(e) {
    return e.which > 1;
}


// EXTERNAL MODULE: ./node_modules/zrender/src/animation/Animator.js + 2 modules
var Animator = __webpack_require__(94);

// CONCATENATED MODULE: ./node_modules/zrender/src/animation/Animation.js







var Animation_Animation = function Animation(options) {

    options = options || {};

    this.stage = options.stage || {};

    this.onframe = options.onframe || function () {};

    this._clips = [];

    this._running = false;

    this._time;

    this._pausedTime;

    this._pauseStart;

    this._paused = false;

    Eventful["a" /* default */].call(this);
};

Animation_Animation.prototype = {

    constructor: Animation_Animation,

    addClip: function addClip(clip) {
        this._clips.push(clip);
    },

    addAnimator: function addAnimator(animator) {
        animator.animation = this;
        var clips = animator.getClips();
        for (var i = 0; i < clips.length; i++) {
            this.addClip(clips[i]);
        }
    },

    removeClip: function removeClip(clip) {
        var idx = util["n" /* indexOf */](this._clips, clip);
        if (idx >= 0) {
            this._clips.splice(idx, 1);
        }
    },

    removeAnimator: function removeAnimator(animator) {
        var clips = animator.getClips();
        for (var i = 0; i < clips.length; i++) {
            this.removeClip(clips[i]);
        }
        animator.animation = null;
    },

    _update: function _update() {

        var time = new Date().getTime() - this._pausedTime;
        var delta = time - this._time;
        var clips = this._clips;
        var len = clips.length;

        var deferredEvents = [];
        var deferredClips = [];
        for (var i = 0; i < len; i++) {
            var clip = clips[i];
            var e = clip.step(time, delta);

            if (e) {
                deferredEvents.push(e);
                deferredClips.push(clip);
            }
        }

        for (var i = 0; i < len;) {
            if (clips[i]._needsRemove) {
                clips[i] = clips[len - 1];
                clips.pop();
                len--;
            } else {
                i++;
            }
        }

        len = deferredEvents.length;
        for (var i = 0; i < len; i++) {
            deferredClips[i].fire(deferredEvents[i]);
        }

        this._time = time;

        this.onframe(delta);

        this.trigger('frame', delta);

        if (this.stage.update) {
            this.stage.update();
        }
    },

    _startLoop: function _startLoop() {
        var self = this;

        this._running = true;

        function step() {
            if (self._running) {

                requestAnimationFrame(step);

                !self._paused && self._update();
            }
        }

        requestAnimationFrame(step);
    },

    start: function start() {

        this._time = new Date().getTime();
        this._pausedTime = 0;

        this._startLoop();
    },

    stop: function stop() {
        this._running = false;
    },

    pause: function pause() {
        if (!this._paused) {
            this._pauseStart = new Date().getTime();
            this._paused = true;
        }
    },

    resume: function resume() {
        if (this._paused) {
            this._pausedTime += new Date().getTime() - this._pauseStart;
            this._paused = false;
        }
    },

    clear: function clear() {
        this._clips = [];
    },

    animate: function animate(target, options) {
        options = options || {};

        var animator = new Animator["a" /* default */](target, options.loop, options.getter, options.setter);

        this.addAnimator(animator);

        return animator;
    }
};

util["y" /* mixin */](Animation_Animation, Eventful["a" /* default */]);

/* harmony default export */ var animation_Animation = (Animation_Animation);
// CONCATENATED MODULE: ./node_modules/zrender/src/core/GestureMgr.js




var GestureMgr = function GestureMgr() {
    this._track = [];
};

GestureMgr.prototype = {

    constructor: GestureMgr,

    recognize: function recognize(event, target, root) {
        this._doTrack(event, target, root);
        return this._recognize(event);
    },

    clear: function clear() {
        this._track.length = 0;
        return this;
    },

    _doTrack: function _doTrack(event, target, root) {
        var touches = event.touches;

        if (!touches) {
            return;
        }

        var trackItem = {
            points: [],
            touches: [],
            target: target,
            event: event
        };

        for (var i = 0, len = touches.length; i < len; i++) {
            var touch = touches[i];
            var pos = clientToLocal(root, touch, {});
            trackItem.points.push([pos.zrX, pos.zrY]);
            trackItem.touches.push(touch);
        }

        this._track.push(trackItem);
    },

    _recognize: function _recognize(event) {
        for (var eventName in recognizers) {
            if (recognizers.hasOwnProperty(eventName)) {
                var gestureInfo = recognizers[eventName](this._track, event);
                if (gestureInfo) {
                    return gestureInfo;
                }
            }
        }
    }
};

function dist(pointPair) {
    var dx = pointPair[1][0] - pointPair[0][0];
    var dy = pointPair[1][1] - pointPair[0][1];

    return Math.sqrt(dx * dx + dy * dy);
}

function center(pointPair) {
    return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
}

var recognizers = {

    pinch: function pinch(track, event) {
        var trackLen = track.length;

        if (!trackLen) {
            return;
        }

        var pinchEnd = (track[trackLen - 1] || {}).points;
        var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

        if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
            var pinchScale = dist(pinchEnd) / dist(pinchPre);
            !isFinite(pinchScale) && (pinchScale = 1);

            event.pinchScale = pinchScale;

            var pinchCenter = center(pinchEnd);
            event.pinchX = pinchCenter[0];
            event.pinchY = pinchCenter[1];

            return {
                type: 'pinch',
                target: track[0].target,
                event: event
            };
        }
    }

};

/* harmony default export */ var core_GestureMgr = (GestureMgr);
// CONCATENATED MODULE: ./node_modules/zrender/src/dom/HandlerProxy.js







var TOUCH_CLICK_DELAY = 300;

var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];

var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];

var pointerEventNames = {
    pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1
};

var pointerHandlerNames = util["v" /* map */](mouseHandlerNames, function (name) {
    var nm = name.replace('mouse', 'pointer');
    return pointerEventNames[nm] ? nm : name;
});

function eventNameFix(name) {
    return name === 'mousewheel' && core_env["a" /* default */].browser.firefox ? 'DOMMouseScroll' : name;
}

function processGesture(proxy, event, stage) {
    var gestureMgr = proxy._gestureMgr;

    stage === 'start' && gestureMgr.clear();

    var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);

    stage === 'end' && gestureMgr.clear();

    if (gestureInfo) {
        var type = gestureInfo.type;
        event.gestureEvent = type;

        proxy.handler.dispatchToElement({ target: gestureInfo.target }, type, gestureInfo.event);
    }
}

function setTouchTimer(instance) {
    instance._touching = true;
    clearTimeout(instance._touchTimer);
    instance._touchTimer = setTimeout(function () {
        instance._touching = false;
    }, 700);
}

var domHandlers = {
    mousemove: function mousemove(event) {
        event = normalizeEvent(this.dom, event);

        this.trigger('mousemove', event);
    },

    mouseout: function mouseout(event) {
        event = normalizeEvent(this.dom, event);

        var element = event.toElement || event.relatedTarget;
        if (element != this.dom) {
            while (element && element.nodeType != 9) {
                if (element === this.dom) {
                    return;
                }

                element = element.parentNode;
            }
        }

        this.trigger('mouseout', event);
    },

    touchstart: function touchstart(event) {
        event = normalizeEvent(this.dom, event);

        event.zrByTouch = true;

        this._lastTouchMoment = new Date();

        processGesture(this, event, 'start');

        domHandlers.mousemove.call(this, event);

        domHandlers.mousedown.call(this, event);

        setTouchTimer(this);
    },

    touchmove: function touchmove(event) {

        event = normalizeEvent(this.dom, event);

        event.zrByTouch = true;

        processGesture(this, event, 'change');

        domHandlers.mousemove.call(this, event);

        setTouchTimer(this);
    },

    touchend: function touchend(event) {

        event = normalizeEvent(this.dom, event);

        event.zrByTouch = true;

        processGesture(this, event, 'end');

        domHandlers.mouseup.call(this, event);

        if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
            domHandlers.click.call(this, event);
        }

        setTouchTimer(this);
    },

    pointerdown: function pointerdown(event) {
        domHandlers.mousedown.call(this, event);
    },

    pointermove: function pointermove(event) {
        if (!isPointerFromTouch(event)) {
            domHandlers.mousemove.call(this, event);
        }
    },

    pointerup: function pointerup(event) {
        domHandlers.mouseup.call(this, event);
    },

    pointerout: function pointerout(event) {
        if (!isPointerFromTouch(event)) {
            domHandlers.mouseout.call(this, event);
        }
    }
};

function isPointerFromTouch(event) {
    var pointerType = event.pointerType;
    return pointerType === 'pen' || pointerType === 'touch';
}

util["i" /* each */](['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
    domHandlers[name] = function (event) {
        event = normalizeEvent(this.dom, event);
        this.trigger(name, event);
    };
});

function initDomHandler(instance) {
    util["i" /* each */](touchHandlerNames, function (name) {
        instance._handlers[name] = util["c" /* bind */](domHandlers[name], instance);
    });

    util["i" /* each */](pointerHandlerNames, function (name) {
        instance._handlers[name] = util["c" /* bind */](domHandlers[name], instance);
    });

    util["i" /* each */](mouseHandlerNames, function (name) {
        instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
    });

    function makeMouseHandler(fn, instance) {
        return function () {
            if (instance._touching) {
                return;
            }
            return fn.apply(instance, arguments);
        };
    }
}

function HandlerDomProxy(dom) {
    Eventful["a" /* default */].call(this);

    this.dom = dom;

    this._touching = false;

    this._touchTimer;

    this._gestureMgr = new core_GestureMgr();

    this._handlers = {};

    initDomHandler(this);

    if (core_env["a" /* default */].pointerEventsSupported) {
        mountHandlers(pointerHandlerNames, this);
    } else {
        if (core_env["a" /* default */].touchEventsSupported) {
            mountHandlers(touchHandlerNames, this);
        }

        mountHandlers(mouseHandlerNames, this);
    }

    function mountHandlers(handlerNames, instance) {
        util["i" /* each */](handlerNames, function (name) {
            addEventListener(dom, eventNameFix(name), instance._handlers[name]);
        }, instance);
    }
}

var handlerDomProxyProto = HandlerDomProxy.prototype;
handlerDomProxyProto.dispose = function () {
    var handlerNames = mouseHandlerNames.concat(touchHandlerNames);

    for (var i = 0; i < handlerNames.length; i++) {
        var name = handlerNames[i];
        removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
    }
};

handlerDomProxyProto.setCursor = function (cursorStyle) {
    this.dom.style.cursor = cursorStyle || 'default';
};

util["y" /* mixin */](HandlerDomProxy, Eventful["a" /* default */]);

/* harmony default export */ var HandlerProxy = (HandlerDomProxy);
// CONCATENATED MODULE: ./node_modules/zrender/src/zrender.js











var useVML = !core_env["a" /* default */].canvasSupported;

var painterCtors = {
    canvas: src_Painter
};

var instances = {};
var version = '3.7.2';

function zrender_init(dom, opts) {
    var zr = new zrender_ZRender(Object(guid["a" /* default */])(), dom, opts);
    instances[zr.id] = zr;
    return zr;
}

function zrender_dispose(zr) {
    if (zr) {
        zr.dispose();
    } else {
        for (var key in instances) {
            if (instances.hasOwnProperty(key)) {
                instances[key].dispose();
            }
        }
        instances = {};
    }

    return this;
}

function getInstance(id) {
    return instances[id];
}

function registerPainter(name, Ctor) {
    painterCtors[name] = Ctor;
}

function delInstance(id) {
    delete instances[id];
}

var zrender_ZRender = function ZRender(id, dom, opts) {

    opts = opts || {};

    this.dom = dom;

    this.id = id;

    var self = this;
    var storage = new src_Storage();

    var rendererType = opts.renderer;

    if (useVML) {
        if (!painterCtors.vml) {
            throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
        }
        rendererType = 'vml';
    } else if (!rendererType || !painterCtors[rendererType]) {
        rendererType = 'canvas';
    }
    var painter = new painterCtors[rendererType](dom, storage, opts);

    this.storage = storage;
    this.painter = painter;

    var handerProxy = !core_env["a" /* default */].node ? new HandlerProxy(painter.getViewportRoot()) : null;
    this.handler = new src_Handler(storage, painter, handerProxy, painter.root);

    this.animation = new animation_Animation({
        stage: {
            update: util["c" /* bind */](this.flush, this)
        }
    });
    this.animation.start();

    this._needsRefresh;

    var oldDelFromStorage = storage.delFromStorage;
    var oldAddToStorage = storage.addToStorage;

    storage.delFromStorage = function (el) {
        oldDelFromStorage.call(storage, el);

        el && el.removeSelfFromZr(self);
    };

    storage.addToStorage = function (el) {
        oldAddToStorage.call(storage, el);

        el.addSelfToZr(self);
    };
};

zrender_ZRender.prototype = {

    constructor: zrender_ZRender,

    getId: function getId() {
        return this.id;
    },

    add: function add(el) {
        this.storage.addRoot(el);
        this._needsRefresh = true;
    },

    remove: function remove(el) {
        this.storage.delRoot(el);
        this._needsRefresh = true;
    },

    configLayer: function configLayer(zLevel, config) {
        this.painter.configLayer(zLevel, config);
        this._needsRefresh = true;
    },

    refreshImmediately: function refreshImmediately() {
        this._needsRefresh = false;
        this.painter.refresh();

        this._needsRefresh = false;
    },

    refresh: function refresh() {
        this._needsRefresh = true;
    },

    flush: function flush() {
        if (this._needsRefresh) {
            this.refreshImmediately();
        }
        if (this._needsRefreshHover) {
            this.refreshHoverImmediately();
        }
    },

    addHover: function addHover(el, style) {
        if (this.painter.addHover) {
            this.painter.addHover(el, style);
            this.refreshHover();
        }
    },

    removeHover: function removeHover(el) {
        if (this.painter.removeHover) {
            this.painter.removeHover(el);
            this.refreshHover();
        }
    },

    clearHover: function clearHover() {
        if (this.painter.clearHover) {
            this.painter.clearHover();
            this.refreshHover();
        }
    },

    refreshHover: function refreshHover() {
        this._needsRefreshHover = true;
    },

    refreshHoverImmediately: function refreshHoverImmediately() {
        this._needsRefreshHover = false;
        this.painter.refreshHover && this.painter.refreshHover();
    },

    resize: function resize(opts) {
        opts = opts || {};
        this.painter.resize(opts.width, opts.height);
        this.handler.resize();
    },

    clearAnimation: function clearAnimation() {
        this.animation.clear();
    },

    getWidth: function getWidth() {
        return this.painter.getWidth();
    },

    getHeight: function getHeight() {
        return this.painter.getHeight();
    },

    pathToImage: function pathToImage(e, dpr) {
        return this.painter.pathToImage(e, dpr);
    },

    setCursorStyle: function setCursorStyle(cursorStyle) {
        this.handler.setCursorStyle(cursorStyle);
    },

    findHover: function findHover(x, y) {
        return this.handler.findHover(x, y);
    },

    on: function on(eventName, eventHandler, context) {
        this.handler.on(eventName, eventHandler, context);
    },

    off: function off(eventName, eventHandler) {
        this.handler.off(eventName, eventHandler);
    },

    trigger: function trigger(eventName, event) {
        this.handler.trigger(eventName, event);
    },

    clear: function clear() {
        this.storage.delRoot();
        this.painter.clear();
    },

    dispose: function dispose() {
        this.animation.stop();

        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();

        this.animation = this.storage = this.painter = this.handler = null;

        delInstance(this.id);
    }
};
// EXTERNAL MODULE: ./node_modules/zrender/src/tool/color.js
var tool_color = __webpack_require__(40);

// EXTERNAL MODULE: ./node_modules/echarts/src/util/model.js
var util_model = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/echarts/src/model/Model.js + 4 modules
var Model = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/echarts/src/util/clazz.js
var clazz = __webpack_require__(15);

// CONCATENATED MODULE: ./node_modules/echarts/src/util/component.js



var base = 0;

var DELIMITER = '_';

function getUID(type) {
    return [type || '', base++, Math.random()].join(DELIMITER);
}

function enableSubTypeDefaulter(entity) {

    var subTypeDefaulters = {};

    entity.registerSubTypeDefaulter = function (componentType, defaulter) {
        componentType = Object(clazz["e" /* parseClassType */])(componentType);
        subTypeDefaulters[componentType.main] = defaulter;
    };

    entity.determineSubType = function (componentType, option) {
        var type = option.type;
        if (!type) {
            var componentTypeMain = Object(clazz["e" /* parseClassType */])(componentType).main;
            if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
                type = subTypeDefaulters[componentTypeMain](option);
            }
        }
        return type;
    };

    return entity;
}

function enableTopologicalTravel(entity, dependencyGetter) {
    entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
        if (!targetNameList.length) {
            return;
        }

        var result = makeDepndencyGraph(fullNameList);
        var graph = result.graph;
        var stack = result.noEntryList;

        var targetNameSet = {};
        util["i" /* each */](targetNameList, function (name) {
            targetNameSet[name] = true;
        });

        while (stack.length) {
            var currComponentType = stack.pop();
            var currVertex = graph[currComponentType];
            var isInTargetNameSet = !!targetNameSet[currComponentType];
            if (isInTargetNameSet) {
                callback.call(context, currComponentType, currVertex.originalDeps.slice());
                delete targetNameSet[currComponentType];
            }
            util["i" /* each */](currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
        }

        util["i" /* each */](targetNameSet, function () {
            throw new Error('Circle dependency may exists');
        });

        function removeEdge(succComponentType) {
            graph[succComponentType].entryCount--;
            if (graph[succComponentType].entryCount === 0) {
                stack.push(succComponentType);
            }
        }

        function removeEdgeAndAdd(succComponentType) {
            targetNameSet[succComponentType] = true;
            removeEdge(succComponentType);
        }
    };

    function makeDepndencyGraph(fullNameList) {
        var graph = {};
        var noEntryList = [];

        util["i" /* each */](fullNameList, function (name) {

            var thisItem = createDependencyGraphItem(graph, name);
            var originalDeps = thisItem.originalDeps = dependencyGetter(name);

            var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
            thisItem.entryCount = availableDeps.length;
            if (thisItem.entryCount === 0) {
                noEntryList.push(name);
            }

            util["i" /* each */](availableDeps, function (dependentName) {
                if (util["n" /* indexOf */](thisItem.predecessor, dependentName) < 0) {
                    thisItem.predecessor.push(dependentName);
                }
                var thatItem = createDependencyGraphItem(graph, dependentName);
                if (util["n" /* indexOf */](thatItem.successor, dependentName) < 0) {
                    thatItem.successor.push(name);
                }
            });
        });

        return { graph: graph, noEntryList: noEntryList };
    }

    function createDependencyGraphItem(graph, name) {
        if (!graph[name]) {
            graph[name] = { predecessor: [], successor: [] };
        }
        return graph[name];
    }

    function getAvailableDependencies(originalDeps, fullNameList) {
        var availableDeps = [];
        util["i" /* each */](originalDeps, function (dep) {
            util["n" /* indexOf */](fullNameList, dep) >= 0 && availableDeps.push(dep);
        });
        return availableDeps;
    }
}
// EXTERNAL MODULE: ./node_modules/echarts/src/util/number.js
var number = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/echarts/src/util/format.js
var format = __webpack_require__(12);

// CONCATENATED MODULE: ./node_modules/echarts/src/util/layout.js







var each = util["i" /* each */];

var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];

var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];

function boxLayout(orient, group, gap, maxWidth, maxHeight) {
    var x = 0;
    var y = 0;

    if (maxWidth == null) {
        maxWidth = Infinity;
    }
    if (maxHeight == null) {
        maxHeight = Infinity;
    }
    var currentLineMaxSize = 0;

    group.eachChild(function (child, idx) {
        var position = child.position;
        var rect = child.getBoundingRect();
        var nextChild = group.childAt(idx + 1);
        var nextChildRect = nextChild && nextChild.getBoundingRect();
        var nextX;
        var nextY;

        if (orient === 'horizontal') {
            var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
            nextX = x + moveX;

            if (nextX > maxWidth || child.newline) {
                x = 0;
                nextX = moveX;
                y += currentLineMaxSize + gap;
                currentLineMaxSize = rect.height;
            } else {
                currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
            }
        } else {
            var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
            nextY = y + moveY;

            if (nextY > maxHeight || child.newline) {
                x += currentLineMaxSize + gap;
                y = 0;
                nextY = moveY;
                currentLineMaxSize = rect.width;
            } else {
                currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
            }
        }

        if (child.newline) {
            return;
        }

        position[0] = x;
        position[1] = y;

        orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;
    });
}

var box = boxLayout;

var vbox = util["g" /* curry */](boxLayout, 'vertical');

var hbox = util["g" /* curry */](boxLayout, 'horizontal');

function getAvailableSize(positionInfo, containerRect, margin) {
    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;

    var x = Object(number["h" /* parsePercent */])(positionInfo.x, containerWidth);
    var y = Object(number["h" /* parsePercent */])(positionInfo.y, containerHeight);
    var x2 = Object(number["h" /* parsePercent */])(positionInfo.x2, containerWidth);
    var y2 = Object(number["h" /* parsePercent */])(positionInfo.y2, containerHeight);

    (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
    (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
    (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
    (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);

    margin = format["g" /* normalizeCssArray */](margin || 0);

    return {
        width: Math.max(x2 - x - margin[1] - margin[3], 0),
        height: Math.max(y2 - y - margin[0] - margin[2], 0)
    };
}

function getLayoutRect(positionInfo, containerRect, margin) {
    margin = format["g" /* normalizeCssArray */](margin || 0);

    var containerWidth = containerRect.width;
    var containerHeight = containerRect.height;

    var left = Object(number["h" /* parsePercent */])(positionInfo.left, containerWidth);
    var top = Object(number["h" /* parsePercent */])(positionInfo.top, containerHeight);
    var right = Object(number["h" /* parsePercent */])(positionInfo.right, containerWidth);
    var bottom = Object(number["h" /* parsePercent */])(positionInfo.bottom, containerHeight);
    var width = Object(number["h" /* parsePercent */])(positionInfo.width, containerWidth);
    var height = Object(number["h" /* parsePercent */])(positionInfo.height, containerHeight);

    var verticalMargin = margin[2] + margin[0];
    var horizontalMargin = margin[1] + margin[3];
    var aspect = positionInfo.aspect;

    if (isNaN(width)) {
        width = containerWidth - right - horizontalMargin - left;
    }
    if (isNaN(height)) {
        height = containerHeight - bottom - verticalMargin - top;
    }

    if (aspect != null) {
        if (isNaN(width) && isNaN(height)) {
            if (aspect > containerWidth / containerHeight) {
                width = containerWidth * 0.8;
            } else {
                height = containerHeight * 0.8;
            }
        }

        if (isNaN(width)) {
            width = aspect * height;
        }
        if (isNaN(height)) {
            height = width / aspect;
        }
    }

    if (isNaN(left)) {
        left = containerWidth - right - width - horizontalMargin;
    }
    if (isNaN(top)) {
        top = containerHeight - bottom - height - verticalMargin;
    }

    switch (positionInfo.left || positionInfo.right) {
        case 'center':
            left = containerWidth / 2 - width / 2 - margin[3];
            break;
        case 'right':
            left = containerWidth - width - horizontalMargin;
            break;
    }
    switch (positionInfo.top || positionInfo.bottom) {
        case 'middle':
        case 'center':
            top = containerHeight / 2 - height / 2 - margin[0];
            break;
        case 'bottom':
            top = containerHeight - height - verticalMargin;
            break;
    }

    left = left || 0;
    top = top || 0;
    if (isNaN(width)) {
        width = containerWidth - horizontalMargin - left - (right || 0);
    }
    if (isNaN(height)) {
        height = containerHeight - verticalMargin - top - (bottom || 0);
    }

    var rect = new BoundingRect["a" /* default */](left + margin[3], top + margin[0], width, height);
    rect.margin = margin;
    return rect;
}

function positionElement(el, positionInfo, containerRect, margin, opt) {
    var h = !opt || !opt.hv || opt.hv[0];
    var v = !opt || !opt.hv || opt.hv[1];
    var boundingMode = opt && opt.boundingMode || 'all';

    if (!h && !v) {
        return;
    }

    var rect;
    if (boundingMode === 'raw') {
        rect = el.type === 'group' ? new BoundingRect["a" /* default */](0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
    } else {
        rect = el.getBoundingRect();
        if (el.needLocalTransform()) {
            var transform = el.getLocalTransform();

            rect = rect.clone();
            rect.applyTransform(transform);
        }
    }

    positionInfo = getLayoutRect(util["h" /* defaults */]({ width: rect.width, height: rect.height }, positionInfo), containerRect, margin);

    var elPos = el.position;
    var dx = h ? positionInfo.x - rect.x : 0;
    var dy = v ? positionInfo.y - rect.y : 0;

    el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
}

function sizeCalculable(option, hvIdx) {
    return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}

function mergeLayoutParam(targetOption, newOption, opt) {
    !util["t" /* isObject */](opt) && (opt = {});

    var ignoreSize = opt.ignoreSize;
    !util["p" /* isArray */](ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);

    var hResult = merge(HV_NAMES[0], 0);
    var vResult = merge(HV_NAMES[1], 1);

    copy(HV_NAMES[0], targetOption, hResult);
    copy(HV_NAMES[1], targetOption, vResult);

    function merge(names, hvIdx) {
        var newParams = {};
        var newValueCount = 0;
        var merged = {};
        var mergedValueCount = 0;
        var enoughParamNumber = 2;

        each(names, function (name) {
            merged[name] = targetOption[name];
        });
        each(names, function (name) {
            hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
            hasValue(newParams, name) && newValueCount++;
            hasValue(merged, name) && mergedValueCount++;
        });

        if (ignoreSize[hvIdx]) {
            if (hasValue(newOption, names[1])) {
                merged[names[2]] = null;
            } else if (hasValue(newOption, names[2])) {
                merged[names[1]] = null;
            }
            return merged;
        }

        if (mergedValueCount === enoughParamNumber || !newValueCount) {
            return merged;
        } else if (newValueCount >= enoughParamNumber) {
                return newParams;
            } else {
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
                        newParams[name] = targetOption[name];
                        break;
                    }
                }
                return newParams;
            }
    }

    function hasProp(obj, name) {
        return obj.hasOwnProperty(name);
    }

    function hasValue(obj, name) {
        return obj[name] != null && obj[name] !== 'auto';
    }

    function copy(names, target, source) {
        each(names, function (name) {
            target[name] = source[name];
        });
    }
}

function getLayoutParams(source) {
    return copyLayoutParams({}, source);
}

function copyLayoutParams(target, source) {
    source && target && each(LOCATION_PARAMS, function (name) {
        source.hasOwnProperty(name) && (target[name] = source[name]);
    });
    return target;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/model/mixin/boxLayout.js

/* harmony default export */ var mixin_boxLayout = ({
    getBoxLayoutParams: function getBoxLayoutParams() {
        return {
            left: this.get('left'),
            top: this.get('top'),
            right: this.get('right'),
            bottom: this.get('bottom'),
            width: this.get('width'),
            height: this.get('height')
        };
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/model/Component.js









var arrayPush = Array.prototype.push;

var ComponentModel = Model["a" /* default */].extend({

    type: 'component',

    id: '',

    name: '',

    mainType: '',

    subType: '',

    componentIndex: 0,

    defaultOption: null,

    ecModel: null,

    dependentModels: [],

    uid: null,

    layoutMode: null,

    $constructor: function $constructor(option, parentModel, ecModel, extraOpt) {
        Model["a" /* default */].call(this, option, parentModel, ecModel, extraOpt);

        this.uid = getUID('componentModel');
    },

    init: function init(option, parentModel, ecModel, extraOpt) {
        this.mergeDefaultAndTheme(option, ecModel);
    },

    mergeDefaultAndTheme: function mergeDefaultAndTheme(option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};

        var themeModel = ecModel.getTheme();
        util["w" /* merge */](option, themeModel.get(this.mainType));
        util["w" /* merge */](option, this.getDefaultOption());

        if (layoutMode) {
            mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
    },

    mergeOption: function mergeOption(option, extraOpt) {
        util["w" /* merge */](this.option, option, true);

        var layoutMode = this.layoutMode;
        if (layoutMode) {
            mergeLayoutParam(this.option, option, layoutMode);
        }
    },

    optionUpdated: function optionUpdated(newCptOption, isInit) {},

    getDefaultOption: function getDefaultOption() {
        if (!clazz["d" /* hasOwn */](this, '__defaultOption')) {
            var optList = [];
            var Class = this.constructor;
            while (Class) {
                var opt = Class.prototype.defaultOption;
                opt && optList.push(opt);
                Class = Class.superClass;
            }

            var defaultOption = {};
            for (var i = optList.length - 1; i >= 0; i--) {
                defaultOption = util["w" /* merge */](defaultOption, optList[i], true);
            }
            clazz["f" /* set */](this, '__defaultOption', defaultOption);
        }
        return clazz["c" /* get */](this, '__defaultOption');
    },

    getReferringComponents: function getReferringComponents(mainType) {
        return this.ecModel.queryComponents({
            mainType: mainType,
            index: this.get(mainType + 'Index', true),
            id: this.get(mainType + 'Id', true)
        });
    }

});

clazz["b" /* enableClassManagement */](ComponentModel, { registerWhenExtend: true });
enableSubTypeDefaulter(ComponentModel);

enableTopologicalTravel(ComponentModel, getDependencies);

function getDependencies(componentType) {
    var deps = [];
    util["i" /* each */](ComponentModel.getClassesByMainType(componentType), function (Clazz) {
        arrayPush.apply(deps, Clazz.prototype.dependencies || []);
    });

    return util["v" /* map */](deps, function (type) {
        return clazz["e" /* parseClassType */](type).main;
    });
}

util["y" /* mixin */](ComponentModel, mixin_boxLayout);

/* harmony default export */ var model_Component = (ComponentModel);
// CONCATENATED MODULE: ./node_modules/echarts/src/model/globalDefault.js

var platform = '';

if (typeof navigator !== 'undefined') {
    platform = navigator.platform || '';
}

/* harmony default export */ var globalDefault = ({
    color: ['#c23531', '#2f4554', '#61a0a8', '#d48265', '#91c7ae', '#749f83', '#ca8622', '#bda29a', '#6e7074', '#546570', '#c4ccd3'],

    textStyle: {
        fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',

        fontSize: 12,
        fontStyle: 'normal',
        fontWeight: 'normal'
    },

    blendMode: null,

    animation: 'auto',
    animationDuration: 1000,
    animationDurationUpdate: 300,
    animationEasing: 'exponentialOut',
    animationEasingUpdate: 'cubicOut',

    animationThreshold: 2000,

    progressiveThreshold: 3000,
    progressive: 400,

    hoverLayerThreshold: 3000,

    useUTC: false
});
// CONCATENATED MODULE: ./node_modules/echarts/src/model/mixin/colorPalette.js


/* harmony default export */ var mixin_colorPalette = ({
    clearColorPalette: function clearColorPalette() {
        Object(clazz["f" /* set */])(this, 'colorIdx', 0);
        Object(clazz["f" /* set */])(this, 'colorNameMap', {});
    },

    getColorFromPalette: function getColorFromPalette(name, scope) {
        scope = scope || this;
        var colorIdx = Object(clazz["c" /* get */])(scope, 'colorIdx') || 0;
        var colorNameMap = Object(clazz["c" /* get */])(scope, 'colorNameMap') || Object(clazz["f" /* set */])(scope, 'colorNameMap', {});

        if (colorNameMap.hasOwnProperty(name)) {
            return colorNameMap[name];
        }
        var colorPalette = this.get('color', true) || [];
        if (!colorPalette.length) {
            return;
        }

        var color = colorPalette[colorIdx];
        if (name) {
            colorNameMap[name] = color;
        }
        Object(clazz["f" /* set */])(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);

        return color;
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/model/Global.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };








var Global_each = util["i" /* each */];
var filter = util["l" /* filter */];
var Global_map = util["v" /* map */];
var isArray = util["p" /* isArray */];
var indexOf = util["n" /* indexOf */];
var isObject = util["t" /* isObject */];

var OPTION_INNER_KEY = '\0_ec_inner';

var GlobalModel = Model["a" /* default */].extend({

    constructor: GlobalModel,

    init: function init(option, parentModel, theme, optionManager) {
        theme = theme || {};

        this.option = null;
        this._theme = new Model["a" /* default */](theme);

        this._optionManager = optionManager;
    },

    setOption: function setOption(option, optionPreprocessorFuncs) {
        util["b" /* assert */](!(OPTION_INNER_KEY in option), 'please use chart.getOption()');

        this._optionManager.setOption(option, optionPreprocessorFuncs);

        this.resetOption(null);
    },

    resetOption: function resetOption(type) {
        var optionChanged = false;
        var optionManager = this._optionManager;

        if (!type || type === 'recreate') {
            var baseOption = optionManager.mountOption(type === 'recreate');

            if (!this.option || type === 'recreate') {
                initBase.call(this, baseOption);
            } else {
                this.restoreData();
                this.mergeOption(baseOption);
            }
            optionChanged = true;
        }

        if (type === 'timeline' || type === 'media') {
            this.restoreData();
        }

        if (!type || type === 'recreate' || type === 'timeline') {
            var timelineOption = optionManager.getTimelineOption(this);
            timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
        }

        if (!type || type === 'recreate' || type === 'media') {
            var mediaOptions = optionManager.getMediaOption(this, this._api);
            if (mediaOptions.length) {
                Global_each(mediaOptions, function (mediaOption) {
                    this.mergeOption(mediaOption, optionChanged = true);
                }, this);
            }
        }

        return optionChanged;
    },

    mergeOption: function mergeOption(newOption) {
        var option = this.option;
        var componentsMap = this._componentsMap;
        var newCptTypes = [];

        Global_each(newOption, function (componentOption, mainType) {
            if (componentOption == null) {
                return;
            }

            if (!model_Component.hasClass(mainType)) {
                option[mainType] = option[mainType] == null ? util["d" /* clone */](componentOption) : util["w" /* merge */](option[mainType], componentOption, true);
            } else {
                newCptTypes.push(mainType);
            }
        });

        model_Component.topologicalTravel(newCptTypes, model_Component.getAllClassMainTypes(), visitComponent, this);

        this._seriesIndices = this._seriesIndices || [];

        function visitComponent(mainType, dependencies) {
            var newCptOptionList = util_model["m" /* normalizeToArray */](newOption[mainType]);

            var mapResult = util_model["l" /* mappingToExists */](componentsMap.get(mainType), newCptOptionList);

            util_model["k" /* makeIdAndName */](mapResult);

            Global_each(mapResult, function (item, index) {
                var opt = item.option;
                if (isObject(opt)) {
                    item.keyInfo.mainType = mainType;
                    item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
                }
            });

            var dependentModels = getComponentsByTypes(componentsMap, dependencies);

            option[mainType] = [];
            componentsMap.set(mainType, []);

            Global_each(mapResult, function (resultItem, index) {
                var componentModel = resultItem.exist;
                var newCptOption = resultItem.option;

                util["b" /* assert */](isObject(newCptOption) || componentModel, 'Empty component definition');

                if (!newCptOption) {
                    componentModel.mergeOption({}, this);
                    componentModel.optionUpdated({}, false);
                } else {
                    var ComponentModelClass = model_Component.getClass(mainType, resultItem.keyInfo.subType, true);

                    if (componentModel && componentModel instanceof ComponentModelClass) {
                        componentModel.name = resultItem.keyInfo.name;
                        componentModel.mergeOption(newCptOption, this);
                        componentModel.optionUpdated(newCptOption, false);
                    } else {
                        var extraOpt = util["k" /* extend */]({
                            dependentModels: dependentModels,
                            componentIndex: index
                        }, resultItem.keyInfo);
                        componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
                        util["k" /* extend */](componentModel, extraOpt);
                        componentModel.init(newCptOption, this, this, extraOpt);

                        componentModel.optionUpdated(null, true);
                    }
                }

                componentsMap.get(mainType)[index] = componentModel;
                option[mainType][index] = componentModel.option;
            }, this);

            if (mainType === 'series') {
                this._seriesIndices = createSeriesIndices(componentsMap.get('series'));
            }
        }
    },

    getOption: function getOption() {
        var option = util["d" /* clone */](this.option);

        Global_each(option, function (opts, mainType) {
            if (model_Component.hasClass(mainType)) {
                var opts = util_model["m" /* normalizeToArray */](opts);
                for (var i = opts.length - 1; i >= 0; i--) {
                    if (util_model["i" /* isIdInner */](opts[i])) {
                        opts.splice(i, 1);
                    }
                }
                option[mainType] = opts;
            }
        });

        delete option[OPTION_INNER_KEY];

        return option;
    },

    getTheme: function getTheme() {
        return this._theme;
    },

    getComponent: function getComponent(mainType, idx) {
        var list = this._componentsMap.get(mainType);
        if (list) {
            return list[idx || 0];
        }
    },

    queryComponents: function queryComponents(condition) {
        var mainType = condition.mainType;
        if (!mainType) {
            return [];
        }

        var index = condition.index;
        var id = condition.id;
        var name = condition.name;

        var cpts = this._componentsMap.get(mainType);

        if (!cpts || !cpts.length) {
            return [];
        }

        var result;

        if (index != null) {
            if (!isArray(index)) {
                index = [index];
            }
            result = filter(Global_map(index, function (idx) {
                return cpts[idx];
            }), function (val) {
                return !!val;
            });
        } else if (id != null) {
            var isIdArray = isArray(id);
            result = filter(cpts, function (cpt) {
                return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
            });
        } else if (name != null) {
            var isNameArray = isArray(name);
            result = filter(cpts, function (cpt) {
                return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;
            });
        } else {
            result = cpts.slice();
        }

        return filterBySubType(result, condition);
    },

    findComponents: function findComponents(condition) {
        var query = condition.query;
        var mainType = condition.mainType;

        var queryCond = getQueryCond(query);
        var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);

        return doFilter(filterBySubType(result, condition));

        function getQueryCond(q) {
            var indexAttr = mainType + 'Index';
            var idAttr = mainType + 'Id';
            var nameAttr = mainType + 'Name';
            return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
                mainType: mainType,

                index: q[indexAttr],
                id: q[idAttr],
                name: q[nameAttr]
            } : null;
        }

        function doFilter(res) {
            return condition.filter ? filter(res, condition.filter) : res;
        }
    },

    eachComponent: function eachComponent(mainType, cb, context) {
        var componentsMap = this._componentsMap;

        if (typeof mainType === 'function') {
            context = cb;
            cb = mainType;
            componentsMap.each(function (components, componentType) {
                Global_each(components, function (component, index) {
                    cb.call(context, componentType, component, index);
                });
            });
        } else if (util["u" /* isString */](mainType)) {
            Global_each(componentsMap.get(mainType), cb, context);
        } else if (isObject(mainType)) {
            var queryResult = this.findComponents(mainType);
            Global_each(queryResult, cb, context);
        }
    },

    getSeriesByName: function getSeriesByName(name) {
        var series = this._componentsMap.get('series');
        return filter(series, function (oneSeries) {
            return oneSeries.name === name;
        });
    },

    getSeriesByIndex: function getSeriesByIndex(seriesIndex) {
        return this._componentsMap.get('series')[seriesIndex];
    },

    getSeriesByType: function getSeriesByType(subType) {
        var series = this._componentsMap.get('series');
        return filter(series, function (oneSeries) {
            return oneSeries.subType === subType;
        });
    },

    getSeries: function getSeries() {
        return this._componentsMap.get('series').slice();
    },

    eachSeries: function eachSeries(cb, context) {
        assertSeriesInitialized(this);
        Global_each(this._seriesIndices, function (rawSeriesIndex) {
            var series = this._componentsMap.get('series')[rawSeriesIndex];
            cb.call(context, series, rawSeriesIndex);
        }, this);
    },

    eachRawSeries: function eachRawSeries(cb, context) {
        Global_each(this._componentsMap.get('series'), cb, context);
    },

    eachSeriesByType: function eachSeriesByType(subType, cb, context) {
        assertSeriesInitialized(this);
        Global_each(this._seriesIndices, function (rawSeriesIndex) {
            var series = this._componentsMap.get('series')[rawSeriesIndex];
            if (series.subType === subType) {
                cb.call(context, series, rawSeriesIndex);
            }
        }, this);
    },

    eachRawSeriesByType: function eachRawSeriesByType(subType, cb, context) {
        return Global_each(this.getSeriesByType(subType), cb, context);
    },

    isSeriesFiltered: function isSeriesFiltered(seriesModel) {
        assertSeriesInitialized(this);
        return util["n" /* indexOf */](this._seriesIndices, seriesModel.componentIndex) < 0;
    },

    getCurrentSeriesIndices: function getCurrentSeriesIndices() {
        return (this._seriesIndices || []).slice();
    },

    filterSeries: function filterSeries(cb, context) {
        assertSeriesInitialized(this);
        var filteredSeries = filter(this._componentsMap.get('series'), cb, context);
        this._seriesIndices = createSeriesIndices(filteredSeries);
    },

    restoreData: function restoreData() {
        var componentsMap = this._componentsMap;

        this._seriesIndices = createSeriesIndices(componentsMap.get('series'));

        var componentTypes = [];
        componentsMap.each(function (components, componentType) {
            componentTypes.push(componentType);
        });

        model_Component.topologicalTravel(componentTypes, model_Component.getAllClassMainTypes(), function (componentType, dependencies) {
            Global_each(componentsMap.get(componentType), function (component) {
                component.restoreData();
            });
        });
    }

});

function mergeTheme(option, theme) {
    util["i" /* each */](theme, function (themeItem, name) {
        if (!model_Component.hasClass(name)) {
            if ((typeof themeItem === 'undefined' ? 'undefined' : _typeof(themeItem)) === 'object') {
                option[name] = !option[name] ? util["d" /* clone */](themeItem) : util["w" /* merge */](option[name], themeItem, false);
            } else {
                if (option[name] == null) {
                    option[name] = themeItem;
                }
            }
        }
    });
}

function initBase(baseOption) {
    baseOption = baseOption;

    this.option = {};
    this.option[OPTION_INNER_KEY] = 1;

    this._componentsMap = util["f" /* createHashMap */]({ series: [] });

    this._seriesIndices = null;

    mergeTheme(baseOption, this._theme.option);

    util["w" /* merge */](baseOption, globalDefault, false);

    this.mergeOption(baseOption);
}

function getComponentsByTypes(componentsMap, types) {
    if (!util["p" /* isArray */](types)) {
        types = types ? [types] : [];
    }

    var ret = {};
    Global_each(types, function (type) {
        ret[type] = (componentsMap.get(type) || []).slice();
    });

    return ret;
}

function determineSubType(mainType, newCptOption, existComponent) {
    var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : model_Component.determineSubType(mainType, newCptOption);

    return subType;
}

function createSeriesIndices(seriesModels) {
    return Global_map(seriesModels, function (series) {
        return series.componentIndex;
    }) || [];
}

function filterBySubType(components, condition) {
    return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {
        return cpt.subType === condition.subType;
    }) : components;
}

function assertSeriesInitialized(ecModel) {
    if (false) {
        if (!ecModel._seriesIndices) {
            throw new Error('Option should contains series.');
        }
    }
}

util["y" /* mixin */](GlobalModel, mixin_colorPalette);

/* harmony default export */ var Global = (GlobalModel);
// CONCATENATED MODULE: ./node_modules/echarts/src/ExtensionAPI.js


var echartsAPIList = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel'];


function ExtensionAPI(chartInstance) {
    util["i" /* each */](echartsAPIList, function (name) {
        this[name] = util["c" /* bind */](chartInstance[name], chartInstance);
    }, this);
}

/* harmony default export */ var src_ExtensionAPI = (ExtensionAPI);
// CONCATENATED MODULE: ./node_modules/echarts/src/CoordinateSystem.js


var coordinateSystemCreators = {};

function CoordinateSystemManager() {

    this._coordinateSystems = [];
}

CoordinateSystemManager.prototype = {

    constructor: CoordinateSystemManager,

    create: function create(ecModel, api) {
        var coordinateSystems = [];
        util["i" /* each */](coordinateSystemCreators, function (creater, type) {
            var list = creater.create(ecModel, api);
            coordinateSystems = coordinateSystems.concat(list || []);
        });

        this._coordinateSystems = coordinateSystems;
    },

    update: function update(ecModel, api) {
        util["i" /* each */](this._coordinateSystems, function (coordSys) {
            coordSys.update && coordSys.update(ecModel, api);
        });
    },

    getCoordinateSystems: function getCoordinateSystems() {
        return this._coordinateSystems.slice();
    }
};

CoordinateSystemManager.register = function (type, coordinateSystemCreator) {
    coordinateSystemCreators[type] = coordinateSystemCreator;
};

CoordinateSystemManager.get = function (type) {
    return coordinateSystemCreators[type];
};

/* harmony default export */ var src_CoordinateSystem = (CoordinateSystemManager);
// CONCATENATED MODULE: ./node_modules/echarts/src/model/OptionManager.js






var OptionManager_each = util["i" /* each */];
var clone = util["d" /* clone */];
var OptionManager_map = util["v" /* map */];
var OptionManager_merge = util["w" /* merge */];

var QUERY_REG = /^(min|max)?(.+)$/;

function OptionManager(api) {
    this._api = api;

    this._timelineOptions = [];

    this._mediaList = [];

    this._mediaDefault;

    this._currentMediaIndices = [];

    this._optionBackup;

    this._newBaseOption;
}

OptionManager.prototype = {

    constructor: OptionManager,

    setOption: function setOption(rawOption, optionPreprocessorFuncs) {
        rawOption = clone(rawOption, true);

        var oldOptionBackup = this._optionBackup;
        var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
        this._newBaseOption = newParsedOption.baseOption;

        if (oldOptionBackup) {
            OptionManager_mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);

            if (newParsedOption.timelineOptions.length) {
                oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
            }
            if (newParsedOption.mediaList.length) {
                oldOptionBackup.mediaList = newParsedOption.mediaList;
            }
            if (newParsedOption.mediaDefault) {
                oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
            }
        } else {
            this._optionBackup = newParsedOption;
        }
    },

    mountOption: function mountOption(isRecreate) {
        var optionBackup = this._optionBackup;

        this._timelineOptions = OptionManager_map(optionBackup.timelineOptions, clone);
        this._mediaList = OptionManager_map(optionBackup.mediaList, clone);
        this._mediaDefault = clone(optionBackup.mediaDefault);
        this._currentMediaIndices = [];

        return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
    },

    getTimelineOption: function getTimelineOption(ecModel) {
        var option;
        var timelineOptions = this._timelineOptions;

        if (timelineOptions.length) {
            var timelineModel = ecModel.getComponent('timeline');
            if (timelineModel) {
                option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);
            }
        }

        return option;
    },

    getMediaOption: function getMediaOption(ecModel) {
        var ecWidth = this._api.getWidth();
        var ecHeight = this._api.getHeight();
        var mediaList = this._mediaList;
        var mediaDefault = this._mediaDefault;
        var indices = [];
        var result = [];

        if (!mediaList.length && !mediaDefault) {
            return result;
        }

        for (var i = 0, len = mediaList.length; i < len; i++) {
            if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
                indices.push(i);
            }
        }

        if (!indices.length && mediaDefault) {
            indices = [-1];
        }

        if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
            result = OptionManager_map(indices, function (index) {
                return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
            });
        }


        this._currentMediaIndices = indices;

        return result;
    }
};

function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
    var timelineOptions = [];
    var mediaList = [];
    var mediaDefault;
    var baseOption;

    var timelineOpt = rawOption.timeline;

    if (rawOption.baseOption) {
        baseOption = rawOption.baseOption;
    }

    if (timelineOpt || rawOption.options) {
        baseOption = baseOption || {};
        timelineOptions = (rawOption.options || []).slice();
    }

    if (rawOption.media) {
        baseOption = baseOption || {};
        var media = rawOption.media;
        OptionManager_each(media, function (singleMedia) {
            if (singleMedia && singleMedia.option) {
                if (singleMedia.query) {
                    mediaList.push(singleMedia);
                } else if (!mediaDefault) {
                    mediaDefault = singleMedia;
                }
            }
        });
    }

    if (!baseOption) {
        baseOption = rawOption;
    }

    if (!baseOption.timeline) {
        baseOption.timeline = timelineOpt;
    }

    OptionManager_each([baseOption].concat(timelineOptions).concat(util["v" /* map */](mediaList, function (media) {
        return media.option;
    })), function (option) {
        OptionManager_each(optionPreprocessorFuncs, function (preProcess) {
            preProcess(option, isNew);
        });
    });

    return {
        baseOption: baseOption,
        timelineOptions: timelineOptions,
        mediaDefault: mediaDefault,
        mediaList: mediaList
    };
}

function applyMediaQuery(query, ecWidth, ecHeight) {
    var realMap = {
        width: ecWidth,
        height: ecHeight,
        aspectratio: ecWidth / ecHeight };

    var applicatable = true;

    util["i" /* each */](query, function (value, attr) {
        var matched = attr.match(QUERY_REG);

        if (!matched || !matched[1] || !matched[2]) {
            return;
        }

        var operator = matched[1];
        var realAttr = matched[2].toLowerCase();

        if (!compare(realMap[realAttr], value, operator)) {
            applicatable = false;
        }
    });

    return applicatable;
}

function compare(real, expect, operator) {
    if (operator === 'min') {
        return real >= expect;
    } else if (operator === 'max') {
        return real <= expect;
    } else {
        return real === expect;
    }
}

function indicesEquals(indices1, indices2) {
    return indices1.join(',') === indices2.join(',');
}

function OptionManager_mergeOption(oldOption, newOption) {
    newOption = newOption || {};

    OptionManager_each(newOption, function (newCptOpt, mainType) {
        if (newCptOpt == null) {
            return;
        }

        var oldCptOpt = oldOption[mainType];

        if (!model_Component.hasClass(mainType)) {
            oldOption[mainType] = OptionManager_merge(oldCptOpt, newCptOpt, true);
        } else {
            newCptOpt = util_model["m" /* normalizeToArray */](newCptOpt);
            oldCptOpt = util_model["m" /* normalizeToArray */](oldCptOpt);

            var mapResult = util_model["l" /* mappingToExists */](oldCptOpt, newCptOpt);

            oldOption[mainType] = OptionManager_map(mapResult, function (item) {
                return item.option && item.exist ? OptionManager_merge(item.exist, item.option, true) : item.exist || item.option;
            });
        }
    });
}

/* harmony default export */ var model_OptionManager = (OptionManager);
// CONCATENATED MODULE: ./node_modules/echarts/src/preprocessor/helper/compatStyle.js



var compatStyle_each = util["i" /* each */];
var compatStyle_isObject = util["t" /* isObject */];

var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];

function compatItemStyle(opt) {
    var itemStyleOpt = opt && opt.itemStyle;
    if (!itemStyleOpt) {
        return;
    }
    for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
        var styleName = POSSIBLE_STYLES[i];
        var normalItemStyleOpt = itemStyleOpt.normal;
        var emphasisItemStyleOpt = itemStyleOpt.emphasis;
        if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
            opt[styleName] = opt[styleName] || {};
            if (!opt[styleName].normal) {
                opt[styleName].normal = normalItemStyleOpt[styleName];
            } else {
                util["w" /* merge */](opt[styleName].normal, normalItemStyleOpt[styleName]);
            }
            normalItemStyleOpt[styleName] = null;
        }
        if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
            opt[styleName] = opt[styleName] || {};
            if (!opt[styleName].emphasis) {
                opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
            } else {
                util["w" /* merge */](opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
            }
            emphasisItemStyleOpt[styleName] = null;
        }
    }
}

function compatTextStyle(opt, propName) {
    var labelOptSingle = compatStyle_isObject(opt) && opt[propName];
    var textStyle = compatStyle_isObject(labelOptSingle) && labelOptSingle.textStyle;
    if (textStyle) {
        for (var i = 0, len = util_model["a" /* TEXT_STYLE_OPTIONS */].length; i < len; i++) {
            var propName = util_model["a" /* TEXT_STYLE_OPTIONS */][i];
            if (textStyle.hasOwnProperty(propName)) {
                labelOptSingle[propName] = textStyle[propName];
            }
        }
    }
}

function compatLabelTextStyle(labelOpt) {
    if (compatStyle_isObject(labelOpt)) {
        compatTextStyle(labelOpt, 'normal');
        compatTextStyle(labelOpt, 'emphasis');
    }
}

function processSeries(seriesOpt) {
    if (!compatStyle_isObject(seriesOpt)) {
        return;
    }

    compatItemStyle(seriesOpt);
    compatLabelTextStyle(seriesOpt.label);

    compatLabelTextStyle(seriesOpt.upperLabel);

    compatLabelTextStyle(seriesOpt.edgeLabel);

    var markPoint = seriesOpt.markPoint;
    compatItemStyle(markPoint);
    compatLabelTextStyle(markPoint && markPoint.label);

    var markLine = seriesOpt.markLine;
    compatItemStyle(seriesOpt.markLine);
    compatLabelTextStyle(markLine && markLine.label);

    var markArea = seriesOpt.markArea;
    compatLabelTextStyle(markArea && markArea.label);

    compatTextStyle(seriesOpt, 'axisLabel');
    compatTextStyle(seriesOpt, 'title');
    compatTextStyle(seriesOpt, 'detail');

    var data = seriesOpt.data;
    if (data) {
        for (var i = 0; i < data.length; i++) {
            compatItemStyle(data[i]);
            compatLabelTextStyle(data[i] && data[i].label);
        }
    }

    var markPoint = seriesOpt.markPoint;
    if (markPoint && markPoint.data) {
        var mpData = markPoint.data;
        for (var i = 0; i < mpData.length; i++) {
            compatItemStyle(mpData[i]);
            compatLabelTextStyle(mpData[i] && mpData[i].label);
        }
    }

    var markLine = seriesOpt.markLine;
    if (markLine && markLine.data) {
        var mlData = markLine.data;
        for (var i = 0; i < mlData.length; i++) {
            if (util["p" /* isArray */](mlData[i])) {
                compatItemStyle(mlData[i][0]);
                compatLabelTextStyle(mlData[i][0] && mlData[i][0].label);
                compatItemStyle(mlData[i][1]);
                compatLabelTextStyle(mlData[i][1] && mlData[i][1].label);
            } else {
                compatItemStyle(mlData[i]);
                compatLabelTextStyle(mlData[i] && mlData[i].label);
            }
        }
    }
}

function toArr(o) {
    return util["p" /* isArray */](o) ? o : o ? [o] : [];
}

function toObj(o) {
    return (util["p" /* isArray */](o) ? o[0] : o) || {};
}

/* harmony default export */ var compatStyle = (function (option, isTheme) {
    compatStyle_each(toArr(option.series), function (seriesOpt) {
        compatStyle_isObject(seriesOpt) && processSeries(seriesOpt);
    });

    var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];
    isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');

    compatStyle_each(axes, function (axisName) {
        compatStyle_each(toArr(option[axisName]), function (axisOpt) {
            if (axisOpt) {
                compatTextStyle(axisOpt, 'axisLabel');
                compatTextStyle(axisOpt.axisPointer, 'label');
            }
        });
    });

    compatStyle_each(toArr(option.parallel), function (parallelOpt) {
        var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
        compatTextStyle(parallelAxisDefault, 'axisLabel');
        compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');
    });

    compatStyle_each(toArr(option.calendar), function (calendarOpt) {
        compatTextStyle(calendarOpt, 'dayLabel');
        compatTextStyle(calendarOpt, 'monthLabel');
        compatTextStyle(calendarOpt, 'yearLabel');
    });

    compatStyle_each(toArr(option.radar), function (radarOpt) {
        compatTextStyle(radarOpt, 'name');
    });

    compatStyle_each(toArr(option.geo), function (geoOpt) {
        if (compatStyle_isObject(geoOpt)) {
            compatLabelTextStyle(geoOpt.label);
            compatStyle_each(toArr(geoOpt.regions), function (regionObj) {
                compatLabelTextStyle(regionObj.label);
            });
        }
    });

    compatLabelTextStyle(toObj(option.timeline).label);
    compatTextStyle(toObj(option.axisPointer), 'label');
    compatTextStyle(toObj(option.tooltip).axisPointer, 'label');
});
// CONCATENATED MODULE: ./node_modules/echarts/src/preprocessor/backwardCompat.js






function get(opt, path) {
    path = path.split(',');
    var obj = opt;
    for (var i = 0; i < path.length; i++) {
        obj = obj && obj[path[i]];
        if (obj == null) {
            break;
        }
    }
    return obj;
}

function set(opt, path, val, overwrite) {
    path = path.split(',');
    var obj = opt;
    var key;
    for (var i = 0; i < path.length - 1; i++) {
        key = path[i];
        if (obj[key] == null) {
            obj[key] = {};
        }
        obj = obj[key];
    }
    if (overwrite || obj[path[i]] == null) {
        obj[path[i]] = val;
    }
}

function compatLayoutProperties(option) {
    Object(util["i" /* each */])(LAYOUT_PROPERTIES, function (prop) {
        if (prop[0] in option && !(prop[1] in option)) {
            option[prop[1]] = option[prop[0]];
        }
    });
}

var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];

var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];

var COMPATITABLE_SERIES = ['bar', 'boxplot', 'candlestick', 'chord', 'effectScatter', 'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel', 'pie', 'radar', 'sankey', 'scatter', 'treemap'];

/* harmony default export */ var backwardCompat = (function (option, isTheme) {
    compatStyle(option, isTheme);

    option.series = Object(util_model["m" /* normalizeToArray */])(option.series);

    Object(util["i" /* each */])(option.series, function (seriesOpt) {
        if (!Object(util["t" /* isObject */])(seriesOpt)) {
            return;
        }

        var seriesType = seriesOpt.type;

        if (seriesType === 'pie' || seriesType === 'gauge') {
            if (seriesOpt.clockWise != null) {
                seriesOpt.clockwise = seriesOpt.clockWise;
            }
        }
        if (seriesType === 'gauge') {
            var pointerColor = get(seriesOpt, 'pointer.color');
            pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);
        }

        for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {
            if (COMPATITABLE_SERIES[i] === seriesOpt.type) {
                compatLayoutProperties(seriesOpt);
                break;
            }
        }
    });

    if (option.dataRange) {
        option.visualMap = option.dataRange;
    }

    Object(util["i" /* each */])(COMPATITABLE_COMPONENTS, function (componentName) {
        var options = option[componentName];
        if (options) {
            if (!Object(util["p" /* isArray */])(options)) {
                options = [options];
            }
            Object(util["i" /* each */])(options, function (option) {
                compatLayoutProperties(option);
            });
        }
    });
});
// CONCATENATED MODULE: ./node_modules/echarts/src/model/Series.js









var SeriesModel = model_Component.extend({

    type: 'series.__base__',

    seriesIndex: 0,

    coordinateSystem: null,

    defaultOption: null,

    legendDataProvider: null,

    visualColorAccessPath: 'itemStyle.normal.color',

    layoutMode: null,

    init: function init(option, parentModel, ecModel, extraOpt) {
        this.seriesIndex = this.componentIndex;

        this.mergeDefaultAndTheme(option, ecModel);

        var data = this.getInitialData(option, ecModel);
        if (false) {
            zrUtil.assert(data, 'getInitialData returned invalid data.');
        }

        Object(clazz["f" /* set */])(this, 'dataBeforeProcessed', data);

        this.restoreData();
    },

    mergeDefaultAndTheme: function mergeDefaultAndTheme(option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};

        var themeSubType = this.subType;
        if (model_Component.hasClass(themeSubType)) {
            themeSubType += 'Series';
        }
        util["w" /* merge */](option, ecModel.getTheme().get(this.subType));
        util["w" /* merge */](option, this.getDefaultOption());

        util_model["f" /* defaultEmphasis */](option.label, ['show']);

        this.fillDataTextStyle(option.data);

        if (layoutMode) {
            mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
    },

    mergeOption: function mergeOption(newSeriesOption, ecModel) {
        newSeriesOption = util["w" /* merge */](this.option, newSeriesOption, true);
        this.fillDataTextStyle(newSeriesOption.data);

        var layoutMode = this.layoutMode;
        if (layoutMode) {
            mergeLayoutParam(this.option, newSeriesOption, layoutMode);
        }

        var data = this.getInitialData(newSeriesOption, ecModel);

        if (data) {
            Object(clazz["f" /* set */])(this, 'data', data);
            Object(clazz["f" /* set */])(this, 'dataBeforeProcessed', data.cloneShallow());
        }
    },

    fillDataTextStyle: function fillDataTextStyle(data) {
        if (data) {
            var props = ['show'];
            for (var i = 0; i < data.length; i++) {
                if (data[i] && data[i].label) {
                    util_model["f" /* defaultEmphasis */](data[i].label, props);
                }
            }
        }
    },

    getInitialData: function getInitialData() {},

    getData: function getData(dataType) {
        var data = Object(clazz["c" /* get */])(this, 'data');
        return dataType == null ? data : data.getLinkedData(dataType);
    },

    setData: function setData(data) {
        Object(clazz["f" /* set */])(this, 'data', data);
    },

    getRawData: function getRawData() {
        return Object(clazz["c" /* get */])(this, 'dataBeforeProcessed');
    },

    coordDimToDataDim: function coordDimToDataDim(coordDim) {
        return util_model["c" /* coordDimToDataDim */](this.getData(), coordDim);
    },

    dataDimToCoordDim: function dataDimToCoordDim(dataDim) {
        return util_model["d" /* dataDimToCoordDim */](this.getData(), dataDim);
    },

    getBaseAxis: function getBaseAxis() {
        var coordSys = this.coordinateSystem;
        return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
    },

    formatTooltip: function formatTooltip(dataIndex, multipleSeries, dataType) {
        function formatArrayValue(value) {
            var vertially = util["B" /* reduce */](value, function (vertially, val, idx) {
                var dimItem = data.getDimensionInfo(idx);
                return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;
            }, 0);

            var result = [];
            var tooltipDims = util_model["n" /* otherDimToDataDim */](data, 'tooltip');

            tooltipDims.length ? util["i" /* each */](tooltipDims, function (dimIdx) {
                setEachItem(data.get(dimIdx, dataIndex), dimIdx);
            }) : util["i" /* each */](value, setEachItem);

            function setEachItem(val, dimIdx) {
                var dimInfo = data.getDimensionInfo(dimIdx);

                if (!dimInfo || dimInfo.otherDims.tooltip === false) {
                    return;
                }
                var dimType = dimInfo.type;
                var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '') + (dimType === 'ordinal' ? val + '' : dimType === 'time' ? multipleSeries ? '' : Object(format["d" /* formatTime */])('yyyy/MM/dd hh:mm:ss', val) : Object(format["a" /* addCommas */])(val));
                valStr && result.push(Object(format["c" /* encodeHTML */])(valStr));
            }

            return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');
        }

        var data = Object(clazz["c" /* get */])(this, 'data');

        var value = this.getRawValue(dataIndex);
        var formattedValue = util["p" /* isArray */](value) ? formatArrayValue(value) : Object(format["c" /* encodeHTML */])(Object(format["a" /* addCommas */])(value));
        var name = data.getName(dataIndex);

        var color = data.getItemVisual(dataIndex, 'color');
        if (util["t" /* isObject */](color) && color.colorStops) {
            color = (color.colorStops[0] || {}).color;
        }
        color = color || 'transparent';

        var colorEl = Object(format["f" /* getTooltipMarker */])(color);

        var seriesName = this.name;

        if (seriesName === '\0-') {
            seriesName = '';
        }
        seriesName = seriesName ? Object(format["c" /* encodeHTML */])(seriesName) + (!multipleSeries ? '<br/>' : ': ') : '';
        return !multipleSeries ? seriesName + colorEl + (name ? Object(format["c" /* encodeHTML */])(name) + ': ' + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;
    },

    isAnimationEnabled: function isAnimationEnabled() {
        if (core_env["a" /* default */].node) {
            return false;
        }

        var animationEnabled = this.getShallow('animation');
        if (animationEnabled) {
            if (this.getData().count() > this.getShallow('animationThreshold')) {
                animationEnabled = false;
            }
        }
        return animationEnabled;
    },

    restoreData: function restoreData() {
        Object(clazz["f" /* set */])(this, 'data', Object(clazz["c" /* get */])(this, 'dataBeforeProcessed').cloneShallow());
    },

    getColorFromPalette: function getColorFromPalette(name, scope) {
        var ecModel = this.ecModel;

        var color = mixin_colorPalette.getColorFromPalette.call(this, name, scope);
        if (!color) {
            color = ecModel.getColorFromPalette(name, scope);
        }
        return color;
    },

    getAxisTooltipData: null,

    getTooltipPosition: null
});

util["y" /* mixin */](SeriesModel, util_model["e" /* dataFormatMixin */]);
util["y" /* mixin */](SeriesModel, mixin_colorPalette);

/* harmony default export */ var Series = (SeriesModel);
// CONCATENATED MODULE: ./node_modules/echarts/src/view/Component.js




var Component_Component = function Component() {
    this.group = new Group["a" /* default */]();

    this.uid = getUID('viewComponent');
};

Component_Component.prototype = {

    constructor: Component_Component,

    init: function init(ecModel, api) {},

    render: function render(componentModel, ecModel, api, payload) {},

    dispose: function dispose() {}

};

var componentProto = Component_Component.prototype;
componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {};

clazz["a" /* enableClassExtend */](Component_Component);

clazz["b" /* enableClassManagement */](Component_Component, { registerWhenExtend: true });

/* harmony default export */ var view_Component = (Component_Component);
// CONCATENATED MODULE: ./node_modules/echarts/src/view/Chart.js






function Chart() {
    this.group = new Group["a" /* default */]();

    this.uid = getUID('viewChart');
}

Chart.prototype = {

    type: 'chart',

    init: function init(ecModel, api) {},

    render: function render(seriesModel, ecModel, api, payload) {},

    highlight: function highlight(seriesModel, ecModel, api, payload) {
        toggleHighlight(seriesModel.getData(), payload, 'emphasis');
    },

    downplay: function downplay(seriesModel, ecModel, api, payload) {
        toggleHighlight(seriesModel.getData(), payload, 'normal');
    },

    remove: function remove(ecModel, api) {
        this.group.removeAll();
    },

    dispose: function dispose() {}

};

var chartProto = Chart.prototype;
chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
};

function elSetState(el, state) {
    if (el) {
        el.trigger(state);
        if (el.type === 'group') {
            for (var i = 0; i < el.childCount(); i++) {
                elSetState(el.childAt(i), state);
            }
        }
    }
}

function toggleHighlight(data, payload, state) {
    var dataIndex = util_model["p" /* queryDataIndex */](data, payload);

    if (dataIndex != null) {
        util["i" /* each */](util_model["m" /* normalizeToArray */](dataIndex), function (dataIdx) {
            elSetState(data.getItemGraphicEl(dataIdx), state);
        });
    } else {
        data.eachItemGraphicEl(function (el) {
            elSetState(el, state);
        });
    }
}

clazz["a" /* enableClassExtend */](Chart, ['dispose']);

clazz["b" /* enableClassManagement */](Chart, { registerWhenExtend: true });

/* harmony default export */ var view_Chart = (Chart);
// EXTERNAL MODULE: ./node_modules/echarts/src/util/graphic.js + 18 modules
var graphic = __webpack_require__(1);

// CONCATENATED MODULE: ./node_modules/echarts/src/util/throttle.js

var ORIGIN_METHOD = '\0__throttleOriginMethod';
var RATE = '\0__throttleRate';
var THROTTLE_TYPE = '\0__throttleType';

function throttle(fn, delay, debounce) {

    var currCall;
    var lastCall = 0;
    var lastExec = 0;
    var timer = null;
    var diff;
    var scope;
    var args;
    var debounceNextCall;

    delay = delay || 0;

    function exec() {
        lastExec = new Date().getTime();
        timer = null;
        fn.apply(scope, args || []);
    }

    var cb = function cb() {
        currCall = new Date().getTime();
        scope = this;
        args = arguments;
        var thisDelay = debounceNextCall || delay;
        var thisDebounce = debounceNextCall || debounce;
        debounceNextCall = null;
        diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;

        clearTimeout(timer);

        if (thisDebounce) {
            timer = setTimeout(exec, thisDelay);
        } else {
            if (diff >= 0) {
                exec();
            } else {
                timer = setTimeout(exec, -diff);
            }
        }

        lastCall = currCall;
    };

    cb.clear = function () {
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
    };

    cb.debounceNextCall = function (debounceDelay) {
        debounceNextCall = debounceDelay;
    };

    return cb;
}

function createOrUpdate(obj, fnAttr, rate, throttleType) {
    var fn = obj[fnAttr];

    if (!fn) {
        return;
    }

    var originFn = fn[ORIGIN_METHOD] || fn;
    var lastThrottleType = fn[THROTTLE_TYPE];
    var lastRate = fn[RATE];

    if (lastRate !== rate || lastThrottleType !== throttleType) {
        if (rate == null || !throttleType) {
            return obj[fnAttr] = originFn;
        }

        fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');
        fn[ORIGIN_METHOD] = originFn;
        fn[THROTTLE_TYPE] = throttleType;
        fn[RATE] = rate;
    }

    return fn;
}

function throttle_clear(obj, fnAttr) {
    var fn = obj[fnAttr];
    if (fn && fn[ORIGIN_METHOD]) {
        obj[fnAttr] = fn[ORIGIN_METHOD];
    }
}
// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Gradient.js
var Gradient = __webpack_require__(58);

// CONCATENATED MODULE: ./node_modules/echarts/src/visual/seriesColor.js


/* harmony default export */ var seriesColor = (function (ecModel) {
    function encodeColor(seriesModel) {
        var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');
        var data = seriesModel.getData();
        var color = seriesModel.get(colorAccessPath) || seriesModel.getColorFromPalette(seriesModel.get('name'));
        data.setVisual('color', color);

        if (!ecModel.isSeriesFiltered(seriesModel)) {
            if (typeof color === 'function' && !(color instanceof Gradient["a" /* default */])) {
                data.each(function (idx) {
                    data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));
                });
            }

            data.each(function (idx) {
                var itemModel = data.getItemModel(idx);
                var color = itemModel.get(colorAccessPath, true);
                if (color != null) {
                    data.setItemVisual(idx, 'color', color);
                }
            });
        }
    }
    ecModel.eachRawSeries(encodeColor);
});
// CONCATENATED MODULE: ./node_modules/echarts/src/loading/default.js



var PI = Math.PI;

/* harmony default export */ var loading_default = (function (api, opts) {
    opts = opts || {};
    util["h" /* defaults */](opts, {
        text: 'loading',
        color: '#c23531',
        textColor: '#000',
        maskColor: 'rgba(255, 255, 255, 0.8)',
        zlevel: 0
    });
    var mask = new graphic["Rect"]({
        style: {
            fill: opts.maskColor
        },
        zlevel: opts.zlevel,
        z: 10000
    });
    var arc = new graphic["Arc"]({
        shape: {
            startAngle: -PI / 2,
            endAngle: -PI / 2 + 0.1,
            r: 10
        },
        style: {
            stroke: opts.color,
            lineCap: 'round',
            lineWidth: 5
        },
        zlevel: opts.zlevel,
        z: 10001
    });
    var labelRect = new graphic["Rect"]({
        style: {
            fill: 'none',
            text: opts.text,
            textPosition: 'right',
            textDistance: 10,
            textFill: opts.textColor
        },
        zlevel: opts.zlevel,
        z: 10001
    });

    arc.animateShape(true).when(1000, {
        endAngle: PI * 3 / 2
    }).start('circularInOut');
    arc.animateShape(true).when(1000, {
        startAngle: PI * 3 / 2
    }).delay(300).start('circularInOut');

    var group = new graphic["Group"]();
    group.add(arc);
    group.add(labelRect);
    group.add(mask);

    group.resize = function () {
        var cx = api.getWidth() / 2;
        var cy = api.getHeight() / 2;
        arc.setShape({
            cx: cx,
            cy: cy
        });
        var r = arc.shape.r;
        labelRect.setShape({
            x: cx - r,
            y: cy - r,
            width: r * 2,
            height: r * 2
        });

        mask.setShape({
            x: 0,
            y: 0,
            width: api.getWidth(),
            height: api.getHeight()
        });
    };
    group.resize();
    return group;
});
// CONCATENATED MODULE: ./node_modules/echarts/src/echarts.js























var echarts_each = util["i" /* each */];
var parseClassType = model_Component.parseClassType;

var echarts_version = '3.8.3';

var echarts_dependencies = {
    zrender: '3.7.2'
};

var PRIORITY_PROCESSOR_FILTER = 1000;
var PRIORITY_PROCESSOR_STATISTIC = 5000;

var PRIORITY_VISUAL_LAYOUT = 1000;
var PRIORITY_VISUAL_GLOBAL = 2000;
var PRIORITY_VISUAL_CHART = 3000;
var PRIORITY_VISUAL_COMPONENT = 4000;

var PRIORITY_VISUAL_BRUSH = 5000;

var PRIORITY = {
    PROCESSOR: {
        FILTER: PRIORITY_PROCESSOR_FILTER,
        STATISTIC: PRIORITY_PROCESSOR_STATISTIC
    },
    VISUAL: {
        LAYOUT: PRIORITY_VISUAL_LAYOUT,
        GLOBAL: PRIORITY_VISUAL_GLOBAL,
        CHART: PRIORITY_VISUAL_CHART,
        COMPONENT: PRIORITY_VISUAL_COMPONENT,
        BRUSH: PRIORITY_VISUAL_BRUSH
    }
};

var IN_MAIN_PROCESS = '__flagInMainProcess';
var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';
var OPTION_UPDATED = '__optionUpdated';
var ACTION_REG = /^[a-zA-Z0-9_]+$/;

function createRegisterEventWithLowercaseName(method) {
    return function (eventName, handler, context) {
        eventName = eventName && eventName.toLowerCase();
        Eventful["a" /* default */].prototype[method].call(this, eventName, handler, context);
    };
}

function MessageCenter() {
    Eventful["a" /* default */].call(this);
}
MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');
MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');
MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');
util["y" /* mixin */](MessageCenter, Eventful["a" /* default */]);

function ECharts(dom, theme, opts) {
    opts = opts || {};

    if (typeof theme === 'string') {
        theme = themeStorage[theme];
    }

    this.id;

    this.group;

    this._dom = dom;

    var defaultRenderer = 'canvas';
    if (false) {
        defaultRenderer = (typeof window === 'undefined' ? global : window).__ECHARTS__DEFAULT__RENDERER__ || defaultRenderer;
    }

    var zr = this._zr = zrender_init(dom, {
        renderer: opts.renderer || defaultRenderer,
        devicePixelRatio: opts.devicePixelRatio,
        width: opts.width,
        height: opts.height
    });

    this._throttledZrFlush = throttle(util["c" /* bind */](zr.flush, zr), 17);

    var theme = util["d" /* clone */](theme);
    theme && backwardCompat(theme, true);

    this._theme = theme;

    this._chartsViews = [];

    this._chartsMap = {};

    this._componentsViews = [];

    this._componentsMap = {};

    this._coordSysMgr = new src_CoordinateSystem();

    this._api = createExtensionAPI(this);

    Eventful["a" /* default */].call(this);

    this._messageCenter = new MessageCenter();

    this._initEvents();

    this.resize = util["c" /* bind */](this.resize, this);

    this._pendingActions = [];

    function prioritySortFunc(a, b) {
        return a.prio - b.prio;
    }
    sort(visualFuncs, prioritySortFunc);
    sort(dataProcessorFuncs, prioritySortFunc);

    zr.animation.on('frame', this._onframe, this);

    util["F" /* setAsPrimitive */](this);
}

var echartsProto = ECharts.prototype;

echartsProto._onframe = function () {
    if (this[OPTION_UPDATED]) {
        var silent = this[OPTION_UPDATED].silent;

        this[IN_MAIN_PROCESS] = true;

        updateMethods.prepareAndUpdate.call(this);

        this[IN_MAIN_PROCESS] = false;

        this[OPTION_UPDATED] = false;

        flushPendingActions.call(this, silent);

        triggerUpdatedEvent.call(this, silent);
    }
};

echartsProto.getDom = function () {
    return this._dom;
};

echartsProto.getZr = function () {
    return this._zr;
};

echartsProto.setOption = function (option, notMerge, lazyUpdate) {
    if (false) {
        zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');
    }

    var silent;
    if (util["t" /* isObject */](notMerge)) {
        lazyUpdate = notMerge.lazyUpdate;
        silent = notMerge.silent;
        notMerge = notMerge.notMerge;
    }

    this[IN_MAIN_PROCESS] = true;

    if (!this._model || notMerge) {
        var optionManager = new model_OptionManager(this._api);
        var theme = this._theme;
        var ecModel = this._model = new Global(null, null, theme, optionManager);
        ecModel.init(null, null, theme, optionManager);
    }

    this._model.setOption(option, echarts_optionPreprocessorFuncs);

    if (lazyUpdate) {
        this[OPTION_UPDATED] = { silent: silent };
        this[IN_MAIN_PROCESS] = false;
    } else {
        updateMethods.prepareAndUpdate.call(this);

        this._zr.flush();

        this[OPTION_UPDATED] = false;
        this[IN_MAIN_PROCESS] = false;

        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
    }
};

echartsProto.setTheme = function () {
    console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
};

echartsProto.getModel = function () {
    return this._model;
};

echartsProto.getOption = function () {
    return this._model && this._model.getOption();
};

echartsProto.getWidth = function () {
    return this._zr.getWidth();
};

echartsProto.getHeight = function () {
    return this._zr.getHeight();
};

echartsProto.getDevicePixelRatio = function () {
    return this._zr.painter.dpr || window.devicePixelRatio || 1;
};

echartsProto.getRenderedCanvas = function (opts) {
    if (!core_env["a" /* default */].canvasSupported) {
        return;
    }
    opts = opts || {};
    opts.pixelRatio = opts.pixelRatio || 1;
    opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');
    var zr = this._zr;
    var list = zr.storage.getDisplayList();

    util["i" /* each */](list, function (el) {
        el.stopAnimation(true);
    });
    return zr.painter.getRenderedCanvas(opts);
};

echartsProto.getSvgDataUrl = function () {
    if (!core_env["a" /* default */].svgSupported) {
        return;
    }

    var zr = this._zr;
    var list = zr.storage.getDisplayList();

    util["i" /* each */](list, function (el) {
        el.stopAnimation(true);
    });

    return zr.painter.pathToSvg();
};

echartsProto.getDataURL = function (opts) {
    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self = this;

    echarts_each(excludeComponents, function (componentType) {
        ecModel.eachComponent({
            mainType: componentType
        }, function (component) {
            var view = self._componentsMap[component.__viewId];
            if (!view.group.ignore) {
                excludesComponentViews.push(view);
                view.group.ignore = true;
            }
        });
    });

    var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataUrl() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));

    echarts_each(excludesComponentViews, function (view) {
        view.group.ignore = false;
    });

    return url;
};

echartsProto.getConnectedDataURL = function (opts) {
    if (!core_env["a" /* default */].canvasSupported) {
        return;
    }
    var groupId = this.group;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
        var left = MAX_NUMBER;
        var top = MAX_NUMBER;
        var right = -MAX_NUMBER;
        var bottom = -MAX_NUMBER;
        var canvasList = [];
        var dpr = opts && opts.pixelRatio || 1;

        util["i" /* each */](echarts_instances, function (chart, id) {
            if (chart.group === groupId) {
                var canvas = chart.getRenderedCanvas(util["d" /* clone */](opts));
                var boundingRect = chart.getDom().getBoundingClientRect();
                left = mathMin(boundingRect.left, left);
                top = mathMin(boundingRect.top, top);
                right = mathMax(boundingRect.right, right);
                bottom = mathMax(boundingRect.bottom, bottom);
                canvasList.push({
                    dom: canvas,
                    left: boundingRect.left,
                    top: boundingRect.top
                });
            }
        });

        left *= dpr;
        top *= dpr;
        right *= dpr;
        bottom *= dpr;
        var width = right - left;
        var height = bottom - top;
        var targetCanvas = util["e" /* createCanvas */]();
        targetCanvas.width = width;
        targetCanvas.height = height;
        var zr = zrender_init(targetCanvas);

        echarts_each(canvasList, function (item) {
            var img = new graphic["Image"]({
                style: {
                    x: item.left * dpr - left,
                    y: item.top * dpr - top,
                    image: item.dom
                }
            });
            zr.add(img);
        });
        zr.refreshImmediately();

        return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
    } else {
        return this.getDataURL(opts);
    }
};

echartsProto.convertToPixel = util["g" /* curry */](doConvertPixel, 'convertToPixel');

echartsProto.convertFromPixel = util["g" /* curry */](doConvertPixel, 'convertFromPixel');

function doConvertPixel(methodName, finder, value) {
    var ecModel = this._model;
    var coordSysList = this._coordSysMgr.getCoordinateSystems();
    var result;

    finder = util_model["o" /* parseFinder */](ecModel, finder);

    for (var i = 0; i < coordSysList.length; i++) {
        var coordSys = coordSysList[i];
        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {
            return result;
        }
    }

    if (false) {
        console.warn('No coordinate system that supports ' + methodName + ' found by the given finder.');
    }
}

echartsProto.containPixel = function (finder, value) {
    var ecModel = this._model;
    var result;

    finder = util_model["o" /* parseFinder */](ecModel, finder);

    util["i" /* each */](finder, function (models, key) {
        key.indexOf('Models') >= 0 && util["i" /* each */](models, function (model) {
            var coordSys = model.coordinateSystem;
            if (coordSys && coordSys.containPoint) {
                result |= !!coordSys.containPoint(value);
            } else if (key === 'seriesModels') {
                var view = this._chartsMap[model.__viewId];
                if (view && view.containPoint) {
                    result |= view.containPoint(value, model);
                } else {
                    if (false) {
                        console.warn(key + ': ' + (view ? 'The found component do not support containPoint.' : 'No view mapping to the found component.'));
                    }
                }
            } else {
                if (false) {
                    console.warn(key + ': containPoint is not supported');
                }
            }
        }, this);
    }, this);

    return !!result;
};

echartsProto.getVisual = function (finder, visualType) {
    var ecModel = this._model;

    finder = util_model["o" /* parseFinder */](ecModel, finder, { defaultMainType: 'series' });

    var seriesModel = finder.seriesModel;

    if (false) {
        if (!seriesModel) {
            console.warn('There is no specified seires model');
        }
    }

    var data = seriesModel.getData();

    var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null;

    return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
};

echartsProto.getViewOfComponentModel = function (componentModel) {
    return this._componentsMap[componentModel.__viewId];
};

echartsProto.getViewOfSeriesModel = function (seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
};

var updateMethods = {
    update: function update(payload) {

        var ecModel = this._model;
        var api = this._api;
        var coordSysMgr = this._coordSysMgr;
        var zr = this._zr;

        if (!ecModel) {
            return;
        }

        ecModel.restoreData();

        coordSysMgr.create(this._model, this._api);

        processData.call(this, ecModel, api);

        stackSeriesData.call(this, ecModel);

        coordSysMgr.update(ecModel, api);

        doVisualEncoding.call(this, ecModel, payload);

        doRender.call(this, ecModel, payload);

        var backgroundColor = ecModel.get('backgroundColor') || 'transparent';

        var painter = zr.painter;

        if (painter.isSingleCanvas && painter.isSingleCanvas()) {
            zr.configLayer(0, {
                clearColor: backgroundColor
            });
        } else {
            if (!core_env["a" /* default */].canvasSupported) {
                var colorArr = tool_color["b" /* parse */](backgroundColor);
                backgroundColor = tool_color["c" /* stringify */](colorArr, 'rgb');
                if (colorArr[3] === 0) {
                    backgroundColor = 'transparent';
                }
            }
            if (backgroundColor.colorStops || backgroundColor.image) {
                zr.configLayer(0, {
                    clearColor: backgroundColor
                });
                this[HAS_GRADIENT_OR_PATTERN_BG] = true;

                this._dom.style.background = 'transparent';
            } else {
                if (this[HAS_GRADIENT_OR_PATTERN_BG]) {
                    zr.configLayer(0, {
                        clearColor: null
                    });
                }
                this[HAS_GRADIENT_OR_PATTERN_BG] = false;

                this._dom.style.background = backgroundColor;
            }
        }

        echarts_each(postUpdateFuncs, function (func) {
            func(ecModel, api);
        });
    },

    updateView: function updateView(payload) {
        var ecModel = this._model;

        if (!ecModel) {
            return;
        }

        ecModel.eachSeries(function (seriesModel) {
            seriesModel.getData().clearAllVisual();
        });

        doVisualEncoding.call(this, ecModel, payload);

        invokeUpdateMethod.call(this, 'updateView', ecModel, payload);
    },

    updateVisual: function updateVisual(payload) {
        var ecModel = this._model;

        if (!ecModel) {
            return;
        }

        ecModel.eachSeries(function (seriesModel) {
            seriesModel.getData().clearAllVisual();
        });

        doVisualEncoding.call(this, ecModel, payload, true);

        invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);
    },

    updateLayout: function updateLayout(payload) {
        var ecModel = this._model;

        if (!ecModel) {
            return;
        }

        doLayout.call(this, ecModel, payload);

        invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);
    },

    prepareAndUpdate: function prepareAndUpdate(payload) {
        var ecModel = this._model;

        prepareView.call(this, 'component', ecModel);

        prepareView.call(this, 'chart', ecModel);

        updateMethods.update.call(this, payload);
    }
};

function updateDirectly(ecIns, method, payload, mainType, subType) {
    var ecModel = ecIns._model;

    if (!mainType) {
        echarts_each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
        return;
    }

    var query = {};
    query[mainType + 'Id'] = payload[mainType + 'Id'];
    query[mainType + 'Index'] = payload[mainType + 'Index'];
    query[mainType + 'Name'] = payload[mainType + 'Name'];

    var condition = { mainType: mainType, query: query };
    subType && (condition.subType = subType);
    ecModel && ecModel.eachComponent(condition, function (model, index) {
        callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);
    }, ecIns);

    function callView(view) {
        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
    }
}

echartsProto.resize = function (opts) {
    if (false) {
        zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');
    }

    this[IN_MAIN_PROCESS] = true;

    this._zr.resize(opts);

    var optionChanged = this._model && this._model.resetOption('media');
    var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';

    updateMethods[updateMethod].call(this);

    this._loadingFX && this._loadingFX.resize();

    this[IN_MAIN_PROCESS] = false;

    var silent = opts && opts.silent;

    flushPendingActions.call(this, silent);

    triggerUpdatedEvent.call(this, silent);
};

echartsProto.showLoading = function (name, cfg) {
    if (util["t" /* isObject */](name)) {
        cfg = name;
        name = '';
    }
    name = name || 'default';

    this.hideLoading();
    if (!loadingEffects[name]) {
        if (false) {
            console.warn('Loading effects ' + name + ' not exists.');
        }
        return;
    }
    var el = loadingEffects[name](this._api, cfg);
    var zr = this._zr;
    this._loadingFX = el;

    zr.add(el);
};

echartsProto.hideLoading = function () {
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
};

echartsProto.makeActionFromEvent = function (eventObj) {
    var payload = util["k" /* extend */]({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
};

echartsProto.dispatchAction = function (payload, opt) {
    if (!util["t" /* isObject */](opt)) {
        opt = { silent: !!opt };
    }

    if (!actions[payload.type]) {
        return;
    }

    if (!this._model) {
        return;
    }

    if (this[IN_MAIN_PROCESS]) {
        this._pendingActions.push(payload);
        return;
    }

    doDispatchAction.call(this, payload, opt.silent);

    if (opt.flush) {
        this._zr.flush(true);
    } else if (opt.flush !== false && core_env["a" /* default */].browser.weChat) {
        this._throttledZrFlush();
    }

    flushPendingActions.call(this, opt.silent);

    triggerUpdatedEvent.call(this, opt.silent);
};

function doDispatchAction(payload, silent) {
    var payloadType = payload.type;
    var escapeConnect = payload.escapeConnect;
    var actionWrap = actions[payloadType];
    var actionInfo = actionWrap.actionInfo;

    var cptType = (actionInfo.update || 'update').split(':');
    var updateMethod = cptType.pop();
    cptType = cptType[0] != null && parseClassType(cptType[0]);

    this[IN_MAIN_PROCESS] = true;

    var payloads = [payload];
    var batched = false;

    if (payload.batch) {
        batched = true;
        payloads = util["v" /* map */](payload.batch, function (item) {
            item = util["h" /* defaults */](util["k" /* extend */]({}, item), payload);
            item.batch = null;
            return item;
        });
    }

    var eventObjBatch = [];
    var eventObj;
    var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';

    echarts_each(payloads, function (batchItem) {
        eventObj = actionWrap.action(batchItem, this._model, this._api);

        eventObj = eventObj || util["k" /* extend */]({}, batchItem);

        eventObj.type = actionInfo.event || eventObj.type;
        eventObjBatch.push(eventObj);

        if (isHighDown) {
            updateDirectly(this, updateMethod, batchItem, 'series');
        } else if (cptType) {
            updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
    }, this);

    if (updateMethod !== 'none' && !isHighDown && !cptType) {
        if (this[OPTION_UPDATED]) {
            updateMethods.prepareAndUpdate.call(this, payload);
            this[OPTION_UPDATED] = false;
        } else {
            updateMethods[updateMethod].call(this, payload);
        }
    }

    if (batched) {
        eventObj = {
            type: actionInfo.event || payloadType,
            escapeConnect: escapeConnect,
            batch: eventObjBatch
        };
    } else {
        eventObj = eventObjBatch[0];
    }

    this[IN_MAIN_PROCESS] = false;

    !silent && this._messageCenter.trigger(eventObj.type, eventObj);
}

function flushPendingActions(silent) {
    var pendingActions = this._pendingActions;
    while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
    }
}

function triggerUpdatedEvent(silent) {
    !silent && this.trigger('updated');
}

echartsProto.on = createRegisterEventWithLowercaseName('on');
echartsProto.off = createRegisterEventWithLowercaseName('off');
echartsProto.one = createRegisterEventWithLowercaseName('one');

function invokeUpdateMethod(methodName, ecModel, payload) {
    var api = this._api;

    echarts_each(this._componentsViews, function (component) {
        var componentModel = component.__model;
        component[methodName](componentModel, ecModel, api, payload);

        updateZ(componentModel, component);
    }, this);

    ecModel.eachSeries(function (seriesModel, idx) {
        var chart = this._chartsMap[seriesModel.__viewId];
        chart[methodName](seriesModel, ecModel, api, payload);

        updateZ(seriesModel, chart);

        updateProgressiveAndBlend(seriesModel, chart);
    }, this);

    updateHoverLayerStatus(this._zr, ecModel);

    echarts_each(postUpdateFuncs, function (func) {
        func(ecModel, api);
    });
}

function prepareView(type, ecModel) {
    var isComponent = type === 'component';
    var viewList = isComponent ? this._componentsViews : this._chartsViews;
    var viewMap = isComponent ? this._componentsMap : this._chartsMap;
    var zr = this._zr;

    for (var i = 0; i < viewList.length; i++) {
        viewList[i].__alive = false;
    }

    ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {
        if (isComponent) {
            if (componentType === 'series') {
                return;
            }
        } else {
            model = componentType;
        }

        var viewId = '_ec_' + model.id + '_' + model.type;
        var view = viewMap[viewId];
        if (!view) {
            var classType = parseClassType(model.type);
            var Clazz = isComponent ? view_Component.getClass(classType.main, classType.sub) : view_Chart.getClass(classType.sub);
            if (Clazz) {
                view = new Clazz();
                view.init(ecModel, this._api);
                viewMap[viewId] = view;
                viewList.push(view);
                zr.add(view.group);
            } else {
                return;
            }
        }

        model.__viewId = view.__id = viewId;
        view.__alive = true;
        view.__model = model;
        view.group.__ecComponentInfo = {
            mainType: model.mainType,
            index: model.componentIndex
        };
    }, this);

    for (var i = 0; i < viewList.length;) {
        var view = viewList[i];
        if (!view.__alive) {
            zr.remove(view.group);
            view.dispose(ecModel, this._api);
            viewList.splice(i, 1);
            delete viewMap[view.__id];
            view.__id = view.group.__ecComponentInfo = null;
        } else {
            i++;
        }
    }
}

function processData(ecModel, api) {
    echarts_each(dataProcessorFuncs, function (process) {
        process.func(ecModel, api);
    });
}

function stackSeriesData(ecModel) {
    var stackedDataMap = {};
    ecModel.eachSeries(function (series) {
        var stack = series.get('stack');
        var data = series.getData();
        if (stack && data.type === 'list') {
            var previousStack = stackedDataMap[stack];

            if (stackedDataMap.hasOwnProperty(stack) && previousStack) {
                data.stackedOn = previousStack;
            }
            stackedDataMap[stack] = data;
        }
    });
}

function doLayout(ecModel, payload) {
    var api = this._api;
    echarts_each(visualFuncs, function (visual) {
        if (visual.isLayout) {
            visual.func(ecModel, api, payload);
        }
    });
}

function doVisualEncoding(ecModel, payload, excludesLayout) {
    var api = this._api;
    ecModel.clearColorPalette();
    ecModel.eachSeries(function (seriesModel) {
        seriesModel.clearColorPalette();
    });
    echarts_each(visualFuncs, function (visual) {
        (!excludesLayout || !visual.isLayout) && visual.func(ecModel, api, payload);
    });
}

function doRender(ecModel, payload) {
    var api = this._api;

    echarts_each(this._componentsViews, function (componentView) {
        var componentModel = componentView.__model;
        componentView.render(componentModel, ecModel, api, payload);

        updateZ(componentModel, componentView);
    }, this);

    echarts_each(this._chartsViews, function (chart) {
        chart.__alive = false;
    }, this);

    ecModel.eachSeries(function (seriesModel, idx) {
        var chartView = this._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        chartView.render(seriesModel, ecModel, api, payload);

        chartView.group.silent = !!seriesModel.get('silent');

        updateZ(seriesModel, chartView);

        updateProgressiveAndBlend(seriesModel, chartView);
    }, this);

    updateHoverLayerStatus(this._zr, ecModel);

    echarts_each(this._chartsViews, function (chart) {
        if (!chart.__alive) {
            chart.remove(ecModel, api);
        }
    }, this);
}

var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];

echartsProto._initEvents = function () {
    echarts_each(MOUSE_EVENT_NAMES, function (eveName) {
        this._zr.on(eveName, function (e) {
            var ecModel = this.getModel();
            var el = e.target;
            var params;

            if (eveName === 'globalout') {
                params = {};
            } else if (el && el.dataIndex != null) {
                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
                params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};
            } else if (el && el.eventData) {
                    params = util["k" /* extend */]({}, el.eventData);
                }

            if (params) {
                params.event = e;
                params.type = eveName;
                this.trigger(eveName, params);
            }
        }, this);
    }, this);

    echarts_each(eventActionMap, function (actionType, eventType) {
        this._messageCenter.on(eventType, function (event) {
            this.trigger(eventType, event);
        }, this);
    }, this);
};

echartsProto.isDisposed = function () {
    return this._disposed;
};

echartsProto.clear = function () {
    this.setOption({ series: [] }, true);
};

echartsProto.dispose = function () {
    if (this._disposed) {
        if (false) {
            console.warn('Instance ' + this.id + ' has been disposed');
        }
        return;
    }
    this._disposed = true;

    var api = this._api;
    var ecModel = this._model;

    echarts_each(this._componentsViews, function (component) {
        component.dispose(ecModel, api);
    });
    echarts_each(this._chartsViews, function (chart) {
        chart.dispose(ecModel, api);
    });

    this._zr.dispose();

    delete echarts_instances[this.id];
};

util["y" /* mixin */](ECharts, Eventful["a" /* default */]);

function updateHoverLayerStatus(zr, ecModel) {
    var storage = zr.storage;
    var elCount = 0;
    storage.traverse(function (el) {
        if (!el.isGroup) {
            elCount++;
        }
    });
    if (elCount > ecModel.get('hoverLayerThreshold') && !core_env["a" /* default */].node) {
        storage.traverse(function (el) {
            if (!el.isGroup) {
                el.useHoverLayer = true;
            }
        });
    }
}

function updateProgressiveAndBlend(seriesModel, chartView) {
    var elCount = 0;
    chartView.group.traverse(function (el) {
        if (el.type !== 'group' && !el.ignore) {
            elCount++;
        }
    });
    var frameDrawNum = +seriesModel.get('progressive');
    var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !core_env["a" /* default */].node;
    if (needProgressive) {
        chartView.group.traverse(function (el) {
            if (!el.isGroup) {
                el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1;
                if (needProgressive) {
                    el.stopAnimation(true);
                }
            }
        });
    }

    var blendMode = seriesModel.get('blendMode') || null;
    if (false) {
        if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {
            console.warn('Only canvas support blendMode');
        }
    }
    chartView.group.traverse(function (el) {
        if (!el.isGroup) {
            el.setStyle('blend', blendMode);
        }
    });
}

function updateZ(model, view) {
    var z = model.get('z');
    var zlevel = model.get('zlevel');

    view.group.traverse(function (el) {
        if (el.type !== 'group') {
            z != null && (el.z = z);
            zlevel != null && (el.zlevel = zlevel);
        }
    });
}

function createExtensionAPI(ecInstance) {
    var coordSysMgr = ecInstance._coordSysMgr;
    return util["k" /* extend */](new src_ExtensionAPI(ecInstance), {
        getCoordinateSystems: util["c" /* bind */](coordSysMgr.getCoordinateSystems, coordSysMgr),
        getComponentByElement: function getComponentByElement(el) {
            while (el) {
                var modelInfo = el.__ecComponentInfo;
                if (modelInfo != null) {
                    return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
                }
                el = el.parent;
            }
        }
    });
}

var actions = {};

var eventActionMap = {};

var dataProcessorFuncs = [];

var echarts_optionPreprocessorFuncs = [];

var postUpdateFuncs = [];

var visualFuncs = [];

var themeStorage = {};

var loadingEffects = {};

var echarts_instances = {};
var connectedGroups = {};

var idBase = new Date() - 0;
var groupIdBase = new Date() - 0;
var DOM_ATTRIBUTE_KEY = '_echarts_instance_';

function enableConnect(chart) {
    var STATUS_PENDING = 0;
    var STATUS_UPDATING = 1;
    var STATUS_UPDATED = 2;
    var STATUS_KEY = '__connectUpdateStatus';

    function updateConnectedChartsStatus(charts, status) {
        for (var i = 0; i < charts.length; i++) {
            var otherChart = charts[i];
            otherChart[STATUS_KEY] = status;
        }
    }

    util["i" /* each */](eventActionMap, function (actionType, eventType) {
        chart._messageCenter.on(eventType, function (event) {
            if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
                if (event && event.escapeConnect) {
                    return;
                }

                var action = chart.makeActionFromEvent(event);
                var otherCharts = [];

                util["i" /* each */](echarts_instances, function (otherChart) {
                    if (otherChart !== chart && otherChart.group === chart.group) {
                        otherCharts.push(otherChart);
                    }
                });

                updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
                echarts_each(otherCharts, function (otherChart) {
                    if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
                        otherChart.dispatchAction(action);
                    }
                });
                updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
            }
        });
    });
}

function echarts_init(dom, theme, opts) {
    if (false) {
        if (zrender.version.replace('.', '') - 0 < echarts_dependencies.zrender.replace('.', '') - 0) {
            throw new Error('zrender/src ' + zrender.version + ' is too old for ECharts ' + echarts_version + '. Current version need ZRender ' + echarts_dependencies.zrender + '+');
        }

        if (!dom) {
            throw new Error('Initialize failed: invalid dom.');
        }
    }

    var existInstance = getInstanceByDom(dom);
    if (existInstance) {
        if (false) {
            console.warn('There is a chart instance already initialized on the dom.');
        }
        return existInstance;
    }

    if (false) {
        if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {
            console.warn('Can\'t get dom width or height');
        }
    }

    var chart = new ECharts(dom, theme, opts);
    chart.id = 'ec_' + idBase++;
    echarts_instances[chart.id] = chart;

    if (dom.setAttribute) {
        dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);
    } else {
        dom[DOM_ATTRIBUTE_KEY] = chart.id;
    }

    enableConnect(chart);

    return chart;
}

function connect(groupId) {
    if (util["p" /* isArray */](groupId)) {
        var charts = groupId;
        groupId = null;

        util["i" /* each */](charts, function (chart) {
            if (chart.group != null) {
                groupId = chart.group;
            }
        });
        groupId = groupId || 'g_' + groupIdBase++;
        util["i" /* each */](charts, function (chart) {
            chart.group = groupId;
        });
    }
    connectedGroups[groupId] = true;
    return groupId;
}

function disConnect(groupId) {
    connectedGroups[groupId] = false;
}

var disconnect = disConnect;

function echarts_dispose(chart) {
    if (typeof chart === 'string') {
        chart = echarts_instances[chart];
    } else if (!(chart instanceof ECharts)) {
        chart = getInstanceByDom(chart);
    }
    if (chart instanceof ECharts && !chart.isDisposed()) {
        chart.dispose();
    }
}

function getInstanceByDom(dom) {
    var key;
    if (dom.getAttribute) {
        key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
    } else {
        key = dom[DOM_ATTRIBUTE_KEY];
    }
    return echarts_instances[key];
}

function getInstanceById(key) {
    return echarts_instances[key];
}

function registerTheme(name, theme) {
    themeStorage[name] = theme;
}

function registerPreprocessor(preprocessorFunc) {
    echarts_optionPreprocessorFuncs.push(preprocessorFunc);
}

function registerProcessor(priority, processorFunc) {
    if (typeof priority === 'function') {
        processorFunc = priority;
        priority = PRIORITY_PROCESSOR_FILTER;
    }
    if (false) {
        if (isNaN(priority)) {
            throw new Error('Unkown processor priority');
        }
    }
    dataProcessorFuncs.push({
        prio: priority,
        func: processorFunc
    });
}

function registerPostUpdate(postUpdateFunc) {
    postUpdateFuncs.push(postUpdateFunc);
}

function registerAction(actionInfo, eventName, action) {
    if (typeof eventName === 'function') {
        action = eventName;
        eventName = '';
    }
    var actionType = util["t" /* isObject */](actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
        event: eventName
    }][0];

    actionInfo.event = (actionInfo.event || actionType).toLowerCase();
    eventName = actionInfo.event;

    util["b" /* assert */](ACTION_REG.test(actionType) && ACTION_REG.test(eventName));

    if (!actions[actionType]) {
        actions[actionType] = { action: action, actionInfo: actionInfo };
    }
    eventActionMap[eventName] = actionType;
}

function registerCoordinateSystem(type, CoordinateSystem) {
    src_CoordinateSystem.register(type, CoordinateSystem);
}

function getCoordinateSystemDimensions(type) {
    var coordSysCreator = src_CoordinateSystem.get(type);
    if (coordSysCreator) {
        return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
    }
}

function registerLayout(priority, layoutFunc) {
    if (typeof priority === 'function') {
        layoutFunc = priority;
        priority = PRIORITY_VISUAL_LAYOUT;
    }
    if (false) {
        if (isNaN(priority)) {
            throw new Error('Unkown layout priority');
        }
    }
    visualFuncs.push({
        prio: priority,
        func: layoutFunc,
        isLayout: true
    });
}

function registerVisual(priority, visualFunc) {
    if (typeof priority === 'function') {
        visualFunc = priority;
        priority = PRIORITY_VISUAL_CHART;
    }
    if (false) {
        if (isNaN(priority)) {
            throw new Error('Unkown visual priority');
        }
    }
    visualFuncs.push({
        prio: priority,
        func: visualFunc
    });
}

function registerLoading(name, loadingFx) {
    loadingEffects[name] = loadingFx;
}

function extendComponentModel(opts) {
    return model_Component.extend(opts);
}

function extendComponentView(opts) {
    return view_Component.extend(opts);
}

function extendSeriesModel(opts) {
    return Series.extend(opts);
}

function extendChartView(opts) {
    return view_Chart.extend(opts);
}

function setCanvasCreator(creator) {
    util["a" /* $inject */].createCanvas(creator);
}

registerVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);
registerPreprocessor(backwardCompat);
registerLoading('default', loading_default);

registerAction({
    type: 'highlight',
    event: 'highlight',
    update: 'highlight'
}, util["z" /* noop */]);

registerAction({
    type: 'downplay',
    event: 'downplay',
    update: 'downplay'
}, util["z" /* noop */]);

var _registerMap;

var _getMap;

var _parseGeoJSON;

var _dataTool;



var $inject = {
    registerMap: function registerMap(f) {
        _registerMap = f;
    },
    getMap: function getMap(f) {
        _getMap = f;
    },
    parseGeoJSON: function parseGeoJSON(f) {
        _parseGeoJSON = f;
    },
    dataTool: function dataTool(f) {
        _dataTool = f;
    }
};
// CONCATENATED MODULE: ./node_modules/echarts/src/layout/barGrid.js



var STACK_PREFIX = '__ec_stack_';

function getSeriesStackId(seriesModel) {
    return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;
}

function getAxisKey(axis) {
    return axis.dim + axis.index;
}

function getLayoutOnAxis(opt, api) {
    var params = [];
    var baseAxis = opt.axis;
    var axisKey = 'axis0';

    if (baseAxis.type !== 'category') {
        return;
    }
    var bandWidth = baseAxis.getBandWidth();

    for (var i = 0; i < opt.count || 0; i++) {
        params.push(util["h" /* defaults */]({
            bandWidth: bandWidth,
            axisKey: axisKey,
            stackId: STACK_PREFIX + i
        }, opt));
    }
    var widthAndOffsets = doCalBarWidthAndOffset(params, api);

    var result = [];
    for (var i = 0; i < opt.count; i++) {
        var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
        item.offsetCenter = item.offset + item.width / 2;
        result.push(item);
    }

    return result;
}

function calBarWidthAndOffset(barSeries, api) {
    var seriesInfoList = util["v" /* map */](barSeries, function (seriesModel) {
        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var axisExtent = baseAxis.getExtent();
        var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();

        var barWidth = Object(number["h" /* parsePercent */])(seriesModel.get('barWidth'), bandWidth);
        var barMaxWidth = Object(number["h" /* parsePercent */])(seriesModel.get('barMaxWidth'), bandWidth);
        var barGap = seriesModel.get('barGap');
        var barCategoryGap = seriesModel.get('barCategoryGap');

        return {
            bandWidth: bandWidth,
            barWidth: barWidth,
            barMaxWidth: barMaxWidth,
            barGap: barGap,
            barCategoryGap: barCategoryGap,
            axisKey: getAxisKey(baseAxis),
            stackId: getSeriesStackId(seriesModel)
        };
    });

    return doCalBarWidthAndOffset(seriesInfoList, api);
}

function doCalBarWidthAndOffset(seriesInfoList, api) {
    var columnsMap = {};

    util["i" /* each */](seriesInfoList, function (seriesInfo, idx) {
        var axisKey = seriesInfo.axisKey;
        var bandWidth = seriesInfo.bandWidth;
        var columnsOnAxis = columnsMap[axisKey] || {
            bandWidth: bandWidth,
            remainedWidth: bandWidth,
            autoWidthCount: 0,
            categoryGap: '20%',
            gap: '30%',
            stacks: {}
        };
        var stacks = columnsOnAxis.stacks;
        columnsMap[axisKey] = columnsOnAxis;

        var stackId = seriesInfo.stackId;

        if (!stacks[stackId]) {
            columnsOnAxis.autoWidthCount++;
        }
        stacks[stackId] = stacks[stackId] || {
            width: 0,
            maxWidth: 0
        };

        var barWidth = seriesInfo.barWidth;
        if (barWidth && !stacks[stackId].width) {
            stacks[stackId].width = barWidth;
            barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
            columnsOnAxis.remainedWidth -= barWidth;
        }

        var barMaxWidth = seriesInfo.barMaxWidth;
        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
        var barGap = seriesInfo.barGap;
        barGap != null && (columnsOnAxis.gap = barGap);
        var barCategoryGap = seriesInfo.barCategoryGap;
        barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
    });

    var result = {};

    util["i" /* each */](columnsMap, function (columnsOnAxis, coordSysName) {

        result[coordSysName] = {};

        var stacks = columnsOnAxis.stacks;
        var bandWidth = columnsOnAxis.bandWidth;
        var categoryGap = Object(number["h" /* parsePercent */])(columnsOnAxis.categoryGap, bandWidth);
        var barGapPercent = Object(number["h" /* parsePercent */])(columnsOnAxis.gap, 1);

        var remainedWidth = columnsOnAxis.remainedWidth;
        var autoWidthCount = columnsOnAxis.autoWidthCount;
        var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);

        util["i" /* each */](stacks, function (column, stack) {
            var maxWidth = column.maxWidth;
            if (maxWidth && maxWidth < autoWidth) {
                maxWidth = Math.min(maxWidth, remainedWidth);
                if (column.width) {
                    maxWidth = Math.min(maxWidth, column.width);
                }
                remainedWidth -= maxWidth;
                column.width = maxWidth;
                autoWidthCount--;
            }
        });

        autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);

        var widthSum = 0;
        var lastColumn;
        util["i" /* each */](stacks, function (column, idx) {
            if (!column.width) {
                column.width = autoWidth;
            }
            lastColumn = column;
            widthSum += column.width * (1 + barGapPercent);
        });
        if (lastColumn) {
            widthSum -= lastColumn.width * barGapPercent;
        }

        var offset = -widthSum / 2;
        util["i" /* each */](stacks, function (column, stackId) {
            result[coordSysName][stackId] = result[coordSysName][stackId] || {
                offset: offset,
                width: column.width
            };

            offset += column.width * (1 + barGapPercent);
        });
    });

    return result;
}

function barLayoutGrid(seriesType, ecModel, api) {

    var barWidthAndOffset = calBarWidthAndOffset(util["l" /* filter */](ecModel.getSeriesByType(seriesType), function (seriesModel) {
        return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
    }));

    var lastStackCoords = {};
    var lastStackCoordsOrigin = {};

    ecModel.eachSeriesByType(seriesType, function (seriesModel) {
        if (seriesModel.coordinateSystem.type !== 'cartesian2d') {
            return;
        }

        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();

        var stackId = getSeriesStackId(seriesModel);
        var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
        var columnOffset = columnLayoutInfo.offset;
        var columnWidth = columnLayoutInfo.width;
        var valueAxis = cartesian.getOtherAxis(baseAxis);

        var barMinHeight = seriesModel.get('barMinHeight') || 0;

        var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];

        var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];
        var coords = data.mapArray(coordDims, function (x, y) {
            return cartesian.dataToPoint([x, y]);
        }, true);

        lastStackCoords[stackId] = lastStackCoords[stackId] || [];
        lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || [];

        data.setLayout({
            offset: columnOffset,
            size: columnWidth
        });

        data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {
            if (isNaN(value)) {
                return;
            }

            if (!lastStackCoords[stackId][idx]) {
                lastStackCoords[stackId][idx] = {
                    p: valueAxisStart,
                    n: valueAxisStart };
                lastStackCoordsOrigin[stackId][idx] = {
                    p: valueAxisStart,
                    n: valueAxisStart };
            }
            var sign = value >= 0 ? 'p' : 'n';
            var coord = coords[idx];
            var lastCoord = lastStackCoords[stackId][idx][sign];
            var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];
            var x;
            var y;
            var width;
            var height;

            if (valueAxis.isHorizontal()) {
                x = lastCoord;
                y = coord[1] + columnOffset;
                width = coord[0] - lastCoordOrigin;
                height = columnWidth;

                lastStackCoordsOrigin[stackId][idx][sign] += width;
                if (Math.abs(width) < barMinHeight) {
                    width = (width < 0 ? -1 : 1) * barMinHeight;
                }
                lastStackCoords[stackId][idx][sign] += width;
            } else {
                x = coord[0] + columnOffset;
                y = lastCoord;
                width = columnWidth;
                height = coord[1] - lastCoordOrigin;

                lastStackCoordsOrigin[stackId][idx][sign] += height;
                if (Math.abs(height) < barMinHeight) {
                    height = (height <= 0 ? -1 : 1) * barMinHeight;
                }
                lastStackCoords[stackId][idx][sign] += height;
            }

            data.setItemLayout(idx, {
                x: x,
                y: y,
                width: width,
                height: height
            });
        }, true);
    }, this);
}

barLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;

/* harmony default export */ var barGrid = (barLayoutGrid);
// EXTERNAL MODULE: ./node_modules/zrender/src/contain/text.js
var contain_text = __webpack_require__(20);

// CONCATENATED MODULE: ./node_modules/echarts/src/scale/Scale.js




function Scale(setting) {
    this._setting = setting || {};

    this._extent = [Infinity, -Infinity];

    this._interval = 0;

    this.init && this.init.apply(this, arguments);
}

Scale.prototype.parse = function (val) {
    return val;
};

Scale.prototype.getSetting = function (name) {
    return this._setting[name];
};

Scale.prototype.contain = function (val) {
    var extent = this._extent;
    return val >= extent[0] && val <= extent[1];
};

Scale.prototype.normalize = function (val) {
    var extent = this._extent;
    if (extent[1] === extent[0]) {
        return 0.5;
    }
    return (val - extent[0]) / (extent[1] - extent[0]);
};

Scale.prototype.scale = function (val) {
    var extent = this._extent;
    return val * (extent[1] - extent[0]) + extent[0];
};

Scale.prototype.unionExtent = function (other) {
    var extent = this._extent;
    other[0] < extent[0] && (extent[0] = other[0]);
    other[1] > extent[1] && (extent[1] = other[1]);
};

Scale.prototype.unionExtentFromData = function (data, dim) {
    this.unionExtent(data.getDataExtent(dim, true));
};

Scale.prototype.getExtent = function () {
    return this._extent.slice();
};

Scale.prototype.setExtent = function (start, end) {
    var thisExtent = this._extent;
    if (!isNaN(start)) {
        thisExtent[0] = start;
    }
    if (!isNaN(end)) {
        thisExtent[1] = end;
    }
};

Scale.prototype.getTicksLabels = function () {
    var labels = [];
    var ticks = this.getTicks();
    for (var i = 0; i < ticks.length; i++) {
        labels.push(this.getLabel(ticks[i]));
    }
    return labels;
};

Scale.prototype.isBlank = function () {
    return this._isBlank;
}, Scale.prototype.setBlank = function (isBlank) {
    this._isBlank = isBlank;
};

clazz["a" /* enableClassExtend */](Scale);
clazz["b" /* enableClassManagement */](Scale, {
    registerWhenExtend: true
});

/* harmony default export */ var scale_Scale = (Scale);
// CONCATENATED MODULE: ./node_modules/echarts/src/scale/Ordinal.js





var scaleProto = scale_Scale.prototype;

var OrdinalScale = scale_Scale.extend({

    type: 'ordinal',

    init: function init(data, extent) {
        this._data = data;
        this._extent = extent || [0, data.length - 1];
    },

    parse: function parse(val) {
        return typeof val === 'string' ? util["n" /* indexOf */](this._data, val) : Math.round(val);
    },

    contain: function contain(rank) {
        rank = this.parse(rank);
        return scaleProto.contain.call(this, rank) && this._data[rank] != null;
    },

    normalize: function normalize(val) {
        return scaleProto.normalize.call(this, this.parse(val));
    },

    scale: function scale(val) {
        return Math.round(scaleProto.scale.call(this, val));
    },

    getTicks: function getTicks() {
        var ticks = [];
        var extent = this._extent;
        var rank = extent[0];

        while (rank <= extent[1]) {
            ticks.push(rank);
            rank++;
        }

        return ticks;
    },

    getLabel: function getLabel(n) {
        return this._data[n];
    },

    count: function count() {
        return this._extent[1] - this._extent[0] + 1;
    },

    unionExtentFromData: function unionExtentFromData(data, dim) {
        this.unionExtent(data.getDataExtent(dim, false));
    },

    niceTicks: util["z" /* noop */],
    niceExtent: util["z" /* noop */]
});

OrdinalScale.create = function () {
    return new OrdinalScale();
};

/* harmony default export */ var Ordinal = (OrdinalScale);
// CONCATENATED MODULE: ./node_modules/echarts/src/scale/helper.js




var roundNumber = number["k" /* round */];

function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
    var result = {};
    var span = extent[1] - extent[0];

    var interval = result.interval = number["f" /* nice */](span / splitNumber, true);
    if (minInterval != null && interval < minInterval) {
        interval = result.interval = minInterval;
    }
    if (maxInterval != null && interval > maxInterval) {
        interval = result.interval = maxInterval;
    }

    var precision = result.intervalPrecision = getIntervalPrecision(interval);

    var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];

    fixExtent(niceTickExtent, extent);

    return result;
}

function getIntervalPrecision(interval) {
    return number["c" /* getPrecisionSafe */](interval) + 2;
}

function clamp(niceTickExtent, idx, extent) {
    niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
}

function fixExtent(niceTickExtent, extent) {
    !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
    !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
    clamp(niceTickExtent, 0, extent);
    clamp(niceTickExtent, 1, extent);
    if (niceTickExtent[0] > niceTickExtent[1]) {
        niceTickExtent[0] = niceTickExtent[1];
    }
}

function intervalScaleGetTicks(interval, extent, niceTickExtent, intervalPrecision) {
    var ticks = [];

    if (!interval) {
        return ticks;
    }

    var safeLimit = 10000;

    if (extent[0] < niceTickExtent[0]) {
        ticks.push(extent[0]);
    }
    var tick = niceTickExtent[0];

    while (tick <= niceTickExtent[1]) {
        ticks.push(tick);

        tick = roundNumber(tick + interval, intervalPrecision);
        if (tick === ticks[ticks.length - 1]) {
            break;
        }
        if (ticks.length > safeLimit) {
            return [];
        }
    }

    if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {
        ticks.push(extent[1]);
    }

    return ticks;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/scale/Interval.js







var Interval_roundNumber = number["k" /* round */];

var IntervalScale = scale_Scale.extend({

    type: 'interval',

    _interval: 0,

    _intervalPrecision: 2,

    setExtent: function setExtent(start, end) {
        var thisExtent = this._extent;

        if (!isNaN(start)) {
            thisExtent[0] = parseFloat(start);
        }
        if (!isNaN(end)) {
            thisExtent[1] = parseFloat(end);
        }
    },

    unionExtent: function unionExtent(other) {
        var extent = this._extent;
        other[0] < extent[0] && (extent[0] = other[0]);
        other[1] > extent[1] && (extent[1] = other[1]);

        IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
    },

    getInterval: function getInterval() {
        return this._interval;
    },

    setInterval: function setInterval(interval) {
        this._interval = interval;

        this._niceExtent = this._extent.slice();

        this._intervalPrecision = getIntervalPrecision(interval);
    },

    getTicks: function getTicks() {
        return intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision);
    },

    getTicksLabels: function getTicksLabels() {
        var labels = [];
        var ticks = this.getTicks();
        for (var i = 0; i < ticks.length; i++) {
            labels.push(this.getLabel(ticks[i]));
        }
        return labels;
    },

    getLabel: function getLabel(data, opt) {
        if (data == null) {
            return '';
        }

        var precision = opt && opt.precision;

        if (precision == null) {
            precision = number["c" /* getPrecisionSafe */](data) || 0;
        } else if (precision === 'auto') {
            precision = this._intervalPrecision;
        }

        data = Interval_roundNumber(data, precision, true);

        return format["a" /* addCommas */](data);
    },

    niceTicks: function niceTicks(splitNumber, minInterval, maxInterval) {
        splitNumber = splitNumber || 5;
        var extent = this._extent;
        var span = extent[1] - extent[0];
        if (!isFinite(span)) {
            return;
        }

        if (span < 0) {
            span = -span;
            extent.reverse();
        }

        var result = intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);

        this._intervalPrecision = result.intervalPrecision;
        this._interval = result.interval;
        this._niceExtent = result.niceTickExtent;
    },

    niceExtent: function niceExtent(opt) {
        var extent = this._extent;

        if (extent[0] === extent[1]) {
            if (extent[0] !== 0) {
                var expandSize = extent[0];

                if (!opt.fixMax) {
                    extent[1] += expandSize / 2;
                    extent[0] -= expandSize / 2;
                } else {
                    extent[0] -= expandSize / 2;
                }
            } else {
                extent[1] = 1;
            }
        }
        var span = extent[1] - extent[0];

        if (!isFinite(span)) {
            extent[0] = 0;
            extent[1] = 1;
        }

        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);

        var interval = this._interval;

        if (!opt.fixMin) {
            extent[0] = Interval_roundNumber(Math.floor(extent[0] / interval) * interval);
        }
        if (!opt.fixMax) {
            extent[1] = Interval_roundNumber(Math.ceil(extent[1] / interval) * interval);
        }
    }
});

IntervalScale.create = function () {
    return new IntervalScale();
};

/* harmony default export */ var Interval = (IntervalScale);
// CONCATENATED MODULE: ./node_modules/echarts/src/scale/Time.js








var intervalScaleProto = Interval.prototype;

var mathCeil = Math.ceil;
var mathFloor = Math.floor;
var ONE_SECOND = 1000;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;

var bisect = function bisect(a, x, lo, hi) {
    while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (a[mid][1] < x) {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }
    return lo;
};

var TimeScale = Interval.extend({
    type: 'time',

    getLabel: function getLabel(val) {
        var stepLvl = this._stepLvl;

        var date = new Date(val);

        return format["d" /* formatTime */](stepLvl[0], date, this.getSetting('useUTC'));
    },

    niceExtent: function niceExtent(opt) {
        var extent = this._extent;

        if (extent[0] === extent[1]) {
            extent[0] -= ONE_DAY;
            extent[1] += ONE_DAY;
        }

        if (extent[1] === -Infinity && extent[0] === Infinity) {
            var d = new Date();
            extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
            extent[0] = extent[1] - ONE_DAY;
        }

        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);

        var interval = this._interval;

        if (!opt.fixMin) {
            extent[0] = number["k" /* round */](mathFloor(extent[0] / interval) * interval);
        }
        if (!opt.fixMax) {
            extent[1] = number["k" /* round */](mathCeil(extent[1] / interval) * interval);
        }
    },

    niceTicks: function niceTicks(approxTickNum, minInterval, maxInterval) {
        approxTickNum = approxTickNum || 10;

        var extent = this._extent;
        var span = extent[1] - extent[0];
        var approxInterval = span / approxTickNum;

        if (minInterval != null && approxInterval < minInterval) {
            approxInterval = minInterval;
        }
        if (maxInterval != null && approxInterval > maxInterval) {
            approxInterval = maxInterval;
        }

        var scaleLevelsLen = scaleLevels.length;
        var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);

        var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
        var interval = level[1];

        if (level[0] === 'year') {
            var yearSpan = span / interval;

            var yearStep = number["f" /* nice */](yearSpan / approxTickNum, true);

            interval *= yearStep;
        }

        var timezoneOffset = this.getSetting('useUTC') ? 0 : new Date(+extent[0] || +extent[1]).getTimezoneOffset() * 60 * 1000;
        var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];

        fixExtent(niceExtent, extent);

        this._stepLvl = level;

        this._interval = interval;
        this._niceExtent = niceExtent;
    },

    parse: function parse(val) {
        return +number["g" /* parseDate */](val);
    }
});

util["i" /* each */](['contain', 'normalize'], function (methodName) {
    TimeScale.prototype[methodName] = function (val) {
        return intervalScaleProto[methodName].call(this, this.parse(val));
    };
});

var scaleLevels = [['hh:mm:ss', ONE_SECOND], ['hh:mm:ss', ONE_SECOND * 5], ['hh:mm:ss', ONE_SECOND * 10], ['hh:mm:ss', ONE_SECOND * 15], ['hh:mm:ss', ONE_SECOND * 30], ['hh:mm\nMM-dd', ONE_MINUTE], ['hh:mm\nMM-dd', ONE_MINUTE * 5], ['hh:mm\nMM-dd', ONE_MINUTE * 10], ['hh:mm\nMM-dd', ONE_MINUTE * 15], ['hh:mm\nMM-dd', ONE_MINUTE * 30], ['hh:mm\nMM-dd', ONE_HOUR], ['hh:mm\nMM-dd', ONE_HOUR * 2], ['hh:mm\nMM-dd', ONE_HOUR * 6], ['hh:mm\nMM-dd', ONE_HOUR * 12], ['MM-dd\nyyyy', ONE_DAY], ['MM-dd\nyyyy', ONE_DAY * 2], ['MM-dd\nyyyy', ONE_DAY * 3], ['MM-dd\nyyyy', ONE_DAY * 4], ['MM-dd\nyyyy', ONE_DAY * 5], ['MM-dd\nyyyy', ONE_DAY * 6], ['week', ONE_DAY * 7], ['MM-dd\nyyyy', ONE_DAY * 10], ['week', ONE_DAY * 14], ['week', ONE_DAY * 21], ['month', ONE_DAY * 31], ['week', ONE_DAY * 42], ['month', ONE_DAY * 62], ['week', ONE_DAY * 42], ['quarter', ONE_DAY * 380 / 4], ['month', ONE_DAY * 31 * 4], ['month', ONE_DAY * 31 * 5], ['half-year', ONE_DAY * 380 / 2], ['month', ONE_DAY * 31 * 8], ['month', ONE_DAY * 31 * 10], ['year', ONE_DAY * 380]];

TimeScale.create = function (model) {
    return new TimeScale({ useUTC: model.ecModel.get('useUTC') });
};

/* harmony default export */ var Time = (TimeScale);
// CONCATENATED MODULE: ./node_modules/echarts/src/scale/Log.js








var Log_scaleProto = scale_Scale.prototype;
var Log_intervalScaleProto = Interval.prototype;

var getPrecisionSafe = number["c" /* getPrecisionSafe */];
var roundingErrorFix = number["k" /* round */];

var Log_mathFloor = Math.floor;
var Log_mathCeil = Math.ceil;
var mathPow = Math.pow;

var mathLog = Math.log;

var LogScale = scale_Scale.extend({

    type: 'log',

    base: 10,

    $constructor: function $constructor() {
        scale_Scale.apply(this, arguments);
        this._originalScale = new Interval();
    },

    getTicks: function getTicks() {
        var originalScale = this._originalScale;
        var extent = this._extent;
        var originalExtent = originalScale.getExtent();

        return util["v" /* map */](Log_intervalScaleProto.getTicks.call(this), function (val) {
            var powVal = number["k" /* round */](mathPow(this.base, val));

            powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
            powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;

            return powVal;
        }, this);
    },

    getLabel: Log_intervalScaleProto.getLabel,

    scale: function scale(val) {
        val = Log_scaleProto.scale.call(this, val);
        return mathPow(this.base, val);
    },

    setExtent: function setExtent(start, end) {
        var base = this.base;
        start = mathLog(start) / mathLog(base);
        end = mathLog(end) / mathLog(base);
        Log_intervalScaleProto.setExtent.call(this, start, end);
    },

    getExtent: function getExtent() {
        var base = this.base;
        var extent = Log_scaleProto.getExtent.call(this);
        extent[0] = mathPow(base, extent[0]);
        extent[1] = mathPow(base, extent[1]);

        var originalScale = this._originalScale;
        var originalExtent = originalScale.getExtent();
        originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
        originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));

        return extent;
    },

    unionExtent: function unionExtent(extent) {
        this._originalScale.unionExtent(extent);

        var base = this.base;
        extent[0] = mathLog(extent[0]) / mathLog(base);
        extent[1] = mathLog(extent[1]) / mathLog(base);
        Log_scaleProto.unionExtent.call(this, extent);
    },

    unionExtentFromData: function unionExtentFromData(data, dim) {
        this.unionExtent(data.getDataExtent(dim, true, function (val) {
            return val > 0;
        }));
    },

    niceTicks: function niceTicks(approxTickNum) {
        approxTickNum = approxTickNum || 10;
        var extent = this._extent;
        var span = extent[1] - extent[0];
        if (span === Infinity || span <= 0) {
            return;
        }

        var interval = number["i" /* quantity */](span);
        var err = approxTickNum / span * interval;

        if (err <= 0.5) {
            interval *= 10;
        }

        while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
            interval *= 10;
        }

        var niceExtent = [number["k" /* round */](Log_mathCeil(extent[0] / interval) * interval), number["k" /* round */](Log_mathFloor(extent[1] / interval) * interval)];

        this._interval = interval;
        this._niceExtent = niceExtent;
    },

    niceExtent: function niceExtent(opt) {
        Log_intervalScaleProto.niceExtent.call(this, opt);

        var originalScale = this._originalScale;
        originalScale.__fixMin = opt.fixMin;
        originalScale.__fixMax = opt.fixMax;
    }

});

util["i" /* each */](['contain', 'normalize'], function (methodName) {
    LogScale.prototype[methodName] = function (val) {
        val = mathLog(val) / mathLog(this.base);
        return Log_scaleProto[methodName].call(this, val);
    };
});

LogScale.create = function () {
    return new LogScale();
};

function fixRoundingError(val, originalVal) {
    return roundingErrorFix(val, getPrecisionSafe(originalVal));
}

/* harmony default export */ var Log = (LogScale);
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/axisHelper.js










function getScaleExtent(scale, model) {
    var scaleType = scale.type;

    var min = model.getMin();
    var max = model.getMax();
    var fixMin = min != null;
    var fixMax = max != null;
    var originalExtent = scale.getExtent();

    var axisDataLen;
    var boundaryGap;
    var span;
    if (scaleType === 'ordinal') {
        axisDataLen = (model.get('data') || []).length;
    } else {
        boundaryGap = model.get('boundaryGap');
        if (!util["p" /* isArray */](boundaryGap)) {
            boundaryGap = [boundaryGap || 0, boundaryGap || 0];
        }
        if (typeof boundaryGap[0] === 'boolean') {
            if (false) {
                console.warn('Boolean type for boundaryGap is only ' + 'allowed for ordinal axis. Please use string in ' + 'percentage instead, e.g., "20%". Currently, ' + 'boundaryGap is set to be 0.');
            }
            boundaryGap = [0, 0];
        }
        boundaryGap[0] = number["h" /* parsePercent */](boundaryGap[0], 1);
        boundaryGap[1] = number["h" /* parsePercent */](boundaryGap[1], 1);
        span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);
    }

    if (min == null) {
        min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;
    }
    if (max == null) {
        max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;
    }

    if (min === 'dataMin') {
        min = originalExtent[0];
    } else if (typeof min === 'function') {
        min = min({
            min: originalExtent[0],
            max: originalExtent[1]
        });
    }

    if (max === 'dataMax') {
        max = originalExtent[1];
    } else if (typeof max === 'function') {
        max = max({
            min: originalExtent[0],
            max: originalExtent[1]
        });
    }

    (min == null || !isFinite(min)) && (min = NaN);
    (max == null || !isFinite(max)) && (max = NaN);

    scale.setBlank(util["j" /* eqNaN */](min) || util["j" /* eqNaN */](max));

    if (model.getNeedCrossZero()) {
        if (min > 0 && max > 0 && !fixMin) {
            min = 0;
        }

        if (min < 0 && max < 0 && !fixMax) {
            max = 0;
        }
    }

    return [min, max];
}

function niceScaleExtent(scale, model) {
    var extent = getScaleExtent(scale, model);
    var fixMin = model.getMin() != null;
    var fixMax = model.getMax() != null;
    var splitNumber = model.get('splitNumber');

    if (scale.type === 'log') {
        scale.base = model.get('logBase');
    }

    var scaleType = scale.type;
    scale.setExtent(extent[0], extent[1]);
    scale.niceExtent({
        splitNumber: splitNumber,
        fixMin: fixMin,
        fixMax: fixMax,
        minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,
        maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null
    });

    var interval = model.get('interval');
    if (interval != null) {
        scale.setInterval && scale.setInterval(interval);
    }
}

function createScaleByModel(model, axisType) {
    axisType = axisType || model.get('type');
    if (axisType) {
        switch (axisType) {
            case 'category':
                return new Ordinal(model.getCategories(), [Infinity, -Infinity]);
            case 'value':
                return new Interval();

            default:
                return (scale_Scale.getClass(axisType) || Interval).create(model);
        }
    }
}

function ifAxisCrossZero(axis) {
    var dataExtent = axis.scale.getExtent();
    var min = dataExtent[0];
    var max = dataExtent[1];
    return !(min > 0 && max > 0 || min < 0 && max < 0);
}

function getAxisLabelInterval(tickCoords, labels, font, axisRotate, labelRotate) {
    var textSpaceTakenRect;
    var autoLabelInterval = 0;
    var accumulatedLabelInterval = 0;
    var rotation = (axisRotate - labelRotate) / 180 * Math.PI;

    var step = 1;
    if (labels.length > 40) {
        step = Math.floor(labels.length / 40);
    }

    for (var i = 0; i < tickCoords.length; i += step) {
        var tickCoord = tickCoords[i];

        var rect = contain_text["e" /* getBoundingRect */](labels[i], font, 'center', 'top');
        rect.x += tickCoord * Math.cos(rotation);
        rect.y += tickCoord * Math.sin(rotation);

        rect.width *= 1.3;
        rect.height *= 1.3;

        if (!textSpaceTakenRect) {
            textSpaceTakenRect = rect.clone();
        } else if (textSpaceTakenRect.intersect(rect)) {
                accumulatedLabelInterval++;
                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);
            } else {
                textSpaceTakenRect.union(rect);

                accumulatedLabelInterval = 0;
            }
    }
    if (autoLabelInterval === 0 && step > 1) {
        return step;
    }
    return (autoLabelInterval + 1) * step - 1;
}

function axisHelper_getFormattedLabels(axis, labelFormatter) {
    var scale = axis.scale;
    var labels = scale.getTicksLabels();
    var ticks = scale.getTicks();
    if (typeof labelFormatter === 'string') {
        labelFormatter = function (tpl) {
            return function (val) {
                return tpl.replace('{value}', val != null ? val : '');
            };
        }(labelFormatter);

        return util["v" /* map */](labels, labelFormatter);
    } else if (typeof labelFormatter === 'function') {
        return util["v" /* map */](ticks, function (tick, idx) {
            return labelFormatter(getAxisRawValue(axis, tick), idx);
        }, this);
    } else {
        return labels;
    }
}

function getAxisRawValue(axis, value) {
    return axis.type === 'category' ? axis.scale.getLabel(value) : value;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/cartesian/Cartesian.js




function dimAxisMapper(dim) {
    return this._axes[dim];
}

var Cartesian = function Cartesian(name) {
    this._axes = {};

    this._dimList = [];

    this.name = name || '';
};

Cartesian.prototype = {

    constructor: Cartesian,

    type: 'cartesian',

    getAxis: function getAxis(dim) {
        return this._axes[dim];
    },

    getAxes: function getAxes() {
        return util["v" /* map */](this._dimList, dimAxisMapper, this);
    },

    getAxesByScale: function getAxesByScale(scaleType) {
        scaleType = scaleType.toLowerCase();
        return util["l" /* filter */](this.getAxes(), function (axis) {
            return axis.scale.type === scaleType;
        });
    },

    addAxis: function addAxis(axis) {
        var dim = axis.dim;

        this._axes[dim] = axis;

        this._dimList.push(dim);
    },

    dataToCoord: function dataToCoord(val) {
        return this._dataCoordConvert(val, 'dataToCoord');
    },

    coordToData: function coordToData(val) {
        return this._dataCoordConvert(val, 'coordToData');
    },

    _dataCoordConvert: function _dataCoordConvert(input, method) {
        var dimList = this._dimList;

        var output = input instanceof Array ? [] : {};

        for (var i = 0; i < dimList.length; i++) {
            var dim = dimList[i];
            var axis = this._axes[dim];

            output[dim] = axis[method](input[dim]);
        }

        return output;
    }
};

/* harmony default export */ var cartesian_Cartesian = (Cartesian);
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/cartesian/Cartesian2D.js




function Cartesian2D(name) {

    cartesian_Cartesian.call(this, name);
}

Cartesian2D.prototype = {

    constructor: Cartesian2D,

    type: 'cartesian2d',

    dimensions: ['x', 'y'],

    getBaseAxis: function getBaseAxis() {
        return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
    },

    containPoint: function containPoint(point) {
        var axisX = this.getAxis('x');
        var axisY = this.getAxis('y');
        return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
    },

    containData: function containData(data) {
        return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
    },

    dataToPoint: function dataToPoint(data, clamp) {
        var xAxis = this.getAxis('x');
        var yAxis = this.getAxis('y');
        return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];
    },

    pointToData: function pointToData(point, clamp) {
        var xAxis = this.getAxis('x');
        var yAxis = this.getAxis('y');
        return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];
    },

    getOtherAxis: function getOtherAxis(axis) {
        return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
    }

};

util["o" /* inherits */](Cartesian2D, cartesian_Cartesian);

/* harmony default export */ var cartesian_Cartesian2D = (Cartesian2D);
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/Axis.js





var linearMap = number["e" /* linearMap */];

function fixExtentWithBands(extent, nTick) {
    var size = extent[1] - extent[0];
    var len = nTick;
    var margin = size / len / 2;
    extent[0] += margin;
    extent[1] -= margin;
}

var normalizedExtent = [0, 1];

var Axis = function Axis(dim, scale, extent) {
    this.dim = dim;

    this.scale = scale;

    this._extent = extent || [0, 0];

    this.inverse = false;

    this.onBand = false;

    this._labelInterval;
};

Axis.prototype = {

    constructor: Axis,

    contain: function contain(coord) {
        var extent = this._extent;
        var min = Math.min(extent[0], extent[1]);
        var max = Math.max(extent[0], extent[1]);
        return coord >= min && coord <= max;
    },

    containData: function containData(data) {
        return this.contain(this.dataToCoord(data));
    },

    getExtent: function getExtent() {
        return this._extent.slice();
    },

    getPixelPrecision: function getPixelPrecision(dataExtent) {
        return number["b" /* getPixelPrecision */](dataExtent || this.scale.getExtent(), this._extent);
    },

    setExtent: function setExtent(start, end) {
        var extent = this._extent;
        extent[0] = start;
        extent[1] = end;
    },

    dataToCoord: function dataToCoord(data, clamp) {
        var extent = this._extent;
        var scale = this.scale;
        data = scale.normalize(data);

        if (this.onBand && scale.type === 'ordinal') {
            extent = extent.slice();
            fixExtentWithBands(extent, scale.count());
        }

        return linearMap(data, normalizedExtent, extent, clamp);
    },

    coordToData: function coordToData(coord, clamp) {
        var extent = this._extent;
        var scale = this.scale;

        if (this.onBand && scale.type === 'ordinal') {
            extent = extent.slice();
            fixExtentWithBands(extent, scale.count());
        }

        var t = linearMap(coord, extent, normalizedExtent, clamp);

        return this.scale.scale(t);
    },

    pointToData: function pointToData(point, clamp) {},

    getTicksCoords: function getTicksCoords(alignWithLabel) {
        if (this.onBand && !alignWithLabel) {
            var bands = this.getBands();
            var coords = [];
            for (var i = 0; i < bands.length; i++) {
                coords.push(bands[i][0]);
            }
            if (bands[i - 1]) {
                coords.push(bands[i - 1][1]);
            }
            return coords;
        } else {
            return util["v" /* map */](this.scale.getTicks(), this.dataToCoord, this);
        }
    },

    getLabelsCoords: function getLabelsCoords() {
        return util["v" /* map */](this.scale.getTicks(), this.dataToCoord, this);
    },

    getBands: function getBands() {
        var extent = this.getExtent();
        var bands = [];
        var len = this.scale.count();
        var start = extent[0];
        var end = extent[1];
        var span = end - start;

        for (var i = 0; i < len; i++) {
            bands.push([span * i / len + start, span * (i + 1) / len + start]);
        }
        return bands;
    },

    getBandWidth: function getBandWidth() {
        var axisExtent = this._extent;
        var dataExtent = this.scale.getExtent();

        var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);

        len === 0 && (len = 1);

        var size = Math.abs(axisExtent[1] - axisExtent[0]);

        return Math.abs(size) / len;
    },

    isHorizontal: null,

    getRotate: null,

    getLabelInterval: function getLabelInterval() {
        var labelInterval = this._labelInterval;
        if (!labelInterval) {
            var axisModel = this.model;
            var labelModel = axisModel.getModel('axisLabel');
            labelInterval = labelModel.get('interval');

            if (this.type === 'category' && (labelInterval == null || labelInterval === 'auto')) {
                labelInterval = getAxisLabelInterval(util["v" /* map */](this.scale.getTicks(), this.dataToCoord, this), axisModel.getFormattedLabels(), labelModel.getFont(), this.getRotate ? this.getRotate() : this.isHorizontal && !this.isHorizontal() ? 90 : 0, labelModel.get('rotate'));
            }

            this._labelInterval = labelInterval;
        }
        return labelInterval;
    }

};

/* harmony default export */ var coord_Axis = (Axis);
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/cartesian/Axis2D.js



var Axis2D_Axis2D = function Axis2D(dim, scale, coordExtent, axisType, position) {
  coord_Axis.call(this, dim, scale, coordExtent);

  this.type = axisType || 'value';

  this.position = position || 'bottom';
};

Axis2D_Axis2D.prototype = {

  constructor: Axis2D_Axis2D,

  index: 0,

  onZero: false,

  model: null,

  isHorizontal: function isHorizontal() {
    var position = this.position;
    return position === 'top' || position === 'bottom';
  },

  getGlobalExtent: function getGlobalExtent(asc) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc && ret[0] > ret[1] && ret.reverse();
    return ret;
  },

  getOtherAxis: function getOtherAxis() {
    this.grid.getOtherAxis();
  },

  isLabelIgnored: function isLabelIgnored(idx) {
    if (this.type === 'category') {
      var labelInterval = this.getLabelInterval();
      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);
    }
  },

  pointToData: function pointToData(point, clamp) {
    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
  },

  toLocalCoord: null,

  toGlobalCoord: null

};

util["o" /* inherits */](Axis2D_Axis2D, coord_Axis);

/* harmony default export */ var cartesian_Axis2D = (Axis2D_Axis2D);
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/axisDefault.js


var axisDefault_defaultOption = {
    show: true,
    zlevel: 0,
    z: 0,
    inverse: false,

    name: '',

    nameLocation: 'end',

    nameRotate: null,
    nameTruncate: {
        maxWidth: null,
        ellipsis: '...',
        placeholder: '.'
    },

    nameTextStyle: {},

    nameGap: 15,

    silent: false,
    triggerEvent: false,

    tooltip: {
        show: false
    },

    axisPointer: {},

    axisLine: {
        show: true,
        onZero: true,
        onZeroAxisIndex: null,

        lineStyle: {
            color: '#333',
            width: 1,
            type: 'solid'
        },

        symbol: ['none', 'none'],
        symbolSize: [10, 15]
    },

    axisTick: {
        show: true,

        inside: false,

        length: 5,

        lineStyle: {
            width: 1
        }
    },

    axisLabel: {
        show: true,

        inside: false,
        rotate: 0,
        showMinLabel: null,
        showMaxLabel: null,
        margin: 8,

        fontSize: 12
    },

    splitLine: {
        show: true,

        lineStyle: {
            color: ['#ccc'],
            width: 1,
            type: 'solid'
        }
    },

    splitArea: {
        show: false,

        areaStyle: {
            color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']
        }
    }
};

var axisDefault = {};

axisDefault.categoryAxis = util["w" /* merge */]({
    boundaryGap: true,

    splitLine: {
        show: false
    },

    axisTick: {
        alignWithLabel: false,
        interval: 'auto'
    },

    axisLabel: {
        interval: 'auto'
    }
}, axisDefault_defaultOption);

axisDefault.valueAxis = util["w" /* merge */]({
    boundaryGap: [0, 0],

    splitNumber: 5
}, axisDefault_defaultOption);

axisDefault.timeAxis = util["h" /* defaults */]({
    scale: true,
    min: 'dataMin',
    max: 'dataMax'
}, axisDefault.valueAxis);

axisDefault.logAxis = util["h" /* defaults */]({
    scale: true,
    logBase: 10
}, axisDefault.valueAxis);

/* harmony default export */ var coord_axisDefault = (axisDefault);
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/axisModelCreator.js





var AXIS_TYPES = ['value', 'category', 'time', 'log'];

/* harmony default export */ var axisModelCreator = (function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {

    util["i" /* each */](AXIS_TYPES, function (axisType) {

        BaseAxisModelClass.extend({

            type: axisName + 'Axis.' + axisType,

            mergeDefaultAndTheme: function mergeDefaultAndTheme(option, ecModel) {
                var layoutMode = this.layoutMode;
                var inputPositionParams = layoutMode ? getLayoutParams(option) : {};

                var themeModel = ecModel.getTheme();
                util["w" /* merge */](option, themeModel.get(axisType + 'Axis'));
                util["w" /* merge */](option, this.getDefaultOption());

                option.type = axisTypeDefaulter(axisName, option);

                if (layoutMode) {
                    mergeLayoutParam(option, inputPositionParams, layoutMode);
                }
            },

            defaultOption: util["x" /* mergeAll */]([{}, coord_axisDefault[axisType + 'Axis'], extraDefaultOption], true)
        });
    });

    model_Component.registerSubTypeDefaulter(axisName + 'Axis', util["g" /* curry */](axisTypeDefaulter, axisName));
});
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/axisModelCommonMixin.js



function getName(obj) {
    if (util["t" /* isObject */](obj) && obj.value != null) {
        return obj.value;
    } else {
        return obj + '';
    }
}

/* harmony default export */ var axisModelCommonMixin = ({
    getFormattedLabels: function getFormattedLabels() {
        return axisHelper_getFormattedLabels(this.axis, this.get('axisLabel.formatter'));
    },

    getCategories: function getCategories() {
        return this.get('type') === 'category' && util["v" /* map */](this.get('data'), getName);
    },

    getMin: function getMin(origin) {
        var option = this.option;
        var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;

        if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !util["j" /* eqNaN */](min)) {
            min = this.axis.scale.parse(min);
        }
        return min;
    },

    getMax: function getMax(origin) {
        var option = this.option;
        var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;

        if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !util["j" /* eqNaN */](max)) {
            max = this.axis.scale.parse(max);
        }
        return max;
    },

    getNeedCrossZero: function getNeedCrossZero() {
        var option = this.option;
        return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
    },

    getCoordSysModel: util["z" /* noop */],

    setRange: function setRange(rangeStart, rangeEnd) {
        this.option.rangeStart = rangeStart;
        this.option.rangeEnd = rangeEnd;
    },

    resetRange: function resetRange() {
        this.option.rangeStart = this.option.rangeEnd = null;
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/cartesian/AxisModel.js





var AxisModel = model_Component.extend({

    type: 'cartesian2dAxis',

    axis: null,

    init: function init() {
        AxisModel.superApply(this, 'init', arguments);
        this.resetRange();
    },

    mergeOption: function mergeOption() {
        AxisModel.superApply(this, 'mergeOption', arguments);
        this.resetRange();
    },

    restoreData: function restoreData() {
        AxisModel.superApply(this, 'restoreData', arguments);
        this.resetRange();
    },

    getCoordSysModel: function getCoordSysModel() {
        return this.ecModel.queryComponents({
            mainType: 'grid',
            index: this.option.gridIndex,
            id: this.option.gridId
        })[0];
    }

});

function getAxisType(axisDim, option) {
    return option.type || (option.data ? 'category' : 'value');
}

util["w" /* merge */](AxisModel.prototype, axisModelCommonMixin);

var extraOption = {
    offset: 0
};

axisModelCreator('x', AxisModel, getAxisType, extraOption);
axisModelCreator('y', AxisModel, getAxisType, extraOption);

/* harmony default export */ var cartesian_AxisModel = (AxisModel);
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/cartesian/GridModel.js





/* harmony default export */ var GridModel = (model_Component.extend({

    type: 'grid',

    dependencies: ['xAxis', 'yAxis'],

    layoutMode: 'box',

    coordinateSystem: null,

    defaultOption: {
        show: false,
        zlevel: 0,
        z: 0,
        left: '10%',
        top: 60,
        right: '10%',
        bottom: 60,

        containLabel: false,

        backgroundColor: 'rgba(0,0,0,0)',
        borderWidth: 1,
        borderColor: '#ccc'
    }
}));
// CONCATENATED MODULE: ./node_modules/echarts/src/coord/cartesian/Grid.js












var Grid_each = util["i" /* each */];
var Grid_ifAxisCrossZero = ifAxisCrossZero;
var Grid_niceScaleExtent = niceScaleExtent;

function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
    return axisModel.getCoordSysModel() === gridModel;
}

function rotateTextRect(textRect, rotate) {
    var rotateRadians = rotate * Math.PI / 180;
    var boundingBox = textRect.plain();
    var beforeWidth = boundingBox.width;
    var beforeHeight = boundingBox.height;
    var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);
    var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);
    var rotatedRect = new BoundingRect["a" /* default */](boundingBox.x, boundingBox.y, afterWidth, afterHeight);

    return rotatedRect;
}

function getLabelUnionRect(axis) {
    var axisModel = axis.model;
    var labels = axisModel.getFormattedLabels();
    var axisLabelModel = axisModel.getModel('axisLabel');
    var rect;
    var step = 1;
    var labelCount = labels.length;
    if (labelCount > 40) {
        step = Math.ceil(labelCount / 40);
    }
    for (var i = 0; i < labelCount; i += step) {
        if (!axis.isLabelIgnored(i)) {
            var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);
            var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);

            rect ? rect.union(singleRect) : rect = singleRect;
        }
    }
    return rect;
}

function Grid(gridModel, ecModel, api) {
    this._coordsMap = {};

    this._coordsList = [];

    this._axesMap = {};

    this._axesList = [];

    this._initCartesian(gridModel, ecModel, api);

    this.model = gridModel;
}

var gridProto = Grid.prototype;

gridProto.type = 'grid';

gridProto.axisPointerEnabled = true;

gridProto.getRect = function () {
    return this._rect;
};

gridProto.update = function (ecModel, api) {

    var axesMap = this._axesMap;

    this._updateScale(ecModel, this.model);

    Grid_each(axesMap.x, function (xAxis) {
        Grid_niceScaleExtent(xAxis.scale, xAxis.model);
    });
    Grid_each(axesMap.y, function (yAxis) {
        Grid_niceScaleExtent(yAxis.scale, yAxis.model);
    });
    Grid_each(axesMap.x, function (xAxis) {
        fixAxisOnZero(axesMap, 'y', xAxis);
    });
    Grid_each(axesMap.y, function (yAxis) {
        fixAxisOnZero(axesMap, 'x', yAxis);
    });

    this.resize(this.model, api);
};

function fixAxisOnZero(axesMap, otherAxisDim, axis) {
    var axes = axesMap[otherAxisDim];

    if (!axis.onZero) {
        return;
    }

    var onZeroAxisIndex = axis.onZeroAxisIndex;

    if (onZeroAxisIndex != null) {
        var otherAxis = axes[onZeroAxisIndex];
        if (otherAxis && canNotOnZeroToAxis(otherAxis)) {
            axis.onZero = false;
        }
        return;
    }

    for (var idx in axes) {
        if (axes.hasOwnProperty(idx)) {
            var otherAxis = axes[idx];
            if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {
                onZeroAxisIndex = +idx;
                break;
            }
        }
    }

    if (onZeroAxisIndex == null) {
        axis.onZero = false;
    }
    axis.onZeroAxisIndex = onZeroAxisIndex;
}

function canNotOnZeroToAxis(axis) {
    return axis.type === 'category' || axis.type === 'time' || !Grid_ifAxisCrossZero(axis);
}

gridProto.resize = function (gridModel, api, ignoreContainLabel) {

    var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
    });

    this._rect = gridRect;

    var axesList = this._axesList;

    adjustAxes();

    if (!ignoreContainLabel && gridModel.get('containLabel')) {
        Grid_each(axesList, function (axis) {
            if (!axis.model.get('axisLabel.inside')) {
                var labelUnionRect = getLabelUnionRect(axis);
                if (labelUnionRect) {
                    var dim = axis.isHorizontal() ? 'height' : 'width';
                    var margin = axis.model.get('axisLabel.margin');
                    gridRect[dim] -= labelUnionRect[dim] + margin;
                    if (axis.position === 'top') {
                        gridRect.y += labelUnionRect.height + margin;
                    } else if (axis.position === 'left') {
                        gridRect.x += labelUnionRect.width + margin;
                    }
                }
            }
        });

        adjustAxes();
    }

    function adjustAxes() {
        Grid_each(axesList, function (axis) {
            var isHorizontal = axis.isHorizontal();
            var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
            var idx = axis.inverse ? 1 : 0;
            axis.setExtent(extent[idx], extent[1 - idx]);
            updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);
        });
    }
};

gridProto.getAxis = function (axisType, axisIndex) {
    var axesMapOnDim = this._axesMap[axisType];
    if (axesMapOnDim != null) {
        if (axisIndex == null) {
            for (var name in axesMapOnDim) {
                if (axesMapOnDim.hasOwnProperty(name)) {
                    return axesMapOnDim[name];
                }
            }
        }
        return axesMapOnDim[axisIndex];
    }
};

gridProto.getAxes = function () {
    return this._axesList.slice();
};

gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
        return this._coordsMap[key];
    }

    if (util["t" /* isObject */](xAxisIndex)) {
        yAxisIndex = xAxisIndex.yAxisIndex;
        xAxisIndex = xAxisIndex.xAxisIndex;
    }

    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
        if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
            return coordList[i];
        }
    }
};

gridProto.getCartesians = function () {
    return this._coordsList.slice();
};

gridProto.convertToPixel = function (ecModel, finder, value) {
    var target = this._findConvertTarget(ecModel, finder);

    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
};

gridProto.convertFromPixel = function (ecModel, finder, value) {
    var target = this._findConvertTarget(ecModel, finder);

    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
};

gridProto._findConvertTarget = function (ecModel, finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis;

    if (seriesModel) {
        cartesian = seriesModel.coordinateSystem;
        util["n" /* indexOf */](coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
        cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
        axis = this.getAxis('x', xAxisModel.componentIndex);
    } else if (yAxisModel) {
        axis = this.getAxis('y', yAxisModel.componentIndex);
    } else if (gridModel) {
            var grid = gridModel.coordinateSystem;
            if (grid === this) {
                cartesian = this._coordsList[0];
            }
        }

    return { cartesian: cartesian, axis: axis };
};

gridProto.containPoint = function (point) {
    var coord = this._coordsList[0];
    if (coord) {
        return coord.containPoint(point);
    }
};

gridProto._initCartesian = function (gridModel, ecModel, api) {
    var axisPositionUsed = {
        left: false,
        right: false,
        top: false,
        bottom: false
    };

    var axesMap = {
        x: {},
        y: {}
    };
    var axesCount = {
        x: 0,
        y: 0
    };

    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

    if (!axesCount.x || !axesCount.y) {
        this._axesMap = {};
        this._axesList = [];
        return;
    }

    this._axesMap = axesMap;

    Grid_each(axesMap.x, function (xAxis, xAxisIndex) {
        Grid_each(axesMap.y, function (yAxis, yAxisIndex) {
            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
            var cartesian = new cartesian_Cartesian2D(key);

            cartesian.grid = this;
            cartesian.model = gridModel;

            this._coordsMap[key] = cartesian;
            this._coordsList.push(cartesian);

            cartesian.addAxis(xAxis);
            cartesian.addAxis(yAxis);
        }, this);
    }, this);

    function createAxisCreator(axisType) {
        return function (axisModel, idx) {
            if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
                return;
            }

            var axisPosition = axisModel.get('position');
            if (axisType === 'x') {
                if (axisPosition !== 'top' && axisPosition !== 'bottom') {
                    axisPosition = 'bottom';
                    if (axisPositionUsed[axisPosition]) {
                        axisPosition = axisPosition === 'top' ? 'bottom' : 'top';
                    }
                }
            } else {
                if (axisPosition !== 'left' && axisPosition !== 'right') {
                    axisPosition = 'left';
                    if (axisPositionUsed[axisPosition]) {
                        axisPosition = axisPosition === 'left' ? 'right' : 'left';
                    }
                }
            }
            axisPositionUsed[axisPosition] = true;

            var axis = new cartesian_Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);

            var isCategory = axis.type === 'category';
            axis.onBand = isCategory && axisModel.get('boundaryGap');
            axis.inverse = axisModel.get('inverse');

            axis.onZero = axisModel.get('axisLine.onZero');
            axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');

            axisModel.axis = axis;

            axis.model = axisModel;

            axis.grid = this;

            axis.index = idx;

            this._axesList.push(axis);

            axesMap[axisType][idx] = axis;
            axesCount[axisType]++;
        };
    }
};

gridProto._updateScale = function (ecModel, gridModel) {
    util["i" /* each */](this._axesList, function (axis) {
        axis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeries(function (seriesModel) {
        if (isCartesian2D(seriesModel)) {
            var axesModels = findAxesModels(seriesModel, ecModel);
            var xAxisModel = axesModels[0];
            var yAxisModel = axesModels[1];

            if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {
                return;
            }

            var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
            var data = seriesModel.getData();
            var xAxis = cartesian.getAxis('x');
            var yAxis = cartesian.getAxis('y');

            if (data.type === 'list') {
                unionExtent(data, xAxis, seriesModel);
                unionExtent(data, yAxis, seriesModel);
            }
        }
    }, this);

    function unionExtent(data, axis, seriesModel) {
        Grid_each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {
            axis.scale.unionExtentFromData(data, dim);
        });
    }
};

gridProto.getTooltipAxes = function (dim) {
    var baseAxes = [];
    var otherAxes = [];

    Grid_each(this.getCartesians(), function (cartesian) {
        var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
        var otherAxis = cartesian.getOtherAxis(baseAxis);
        util["n" /* indexOf */](baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
        util["n" /* indexOf */](otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });

    return { baseAxes: baseAxes, otherAxes: otherAxes };
};

function updateAxisTransfrom(axis, coordBase) {
    var axisExtent = axis.getExtent();
    var axisExtentSum = axisExtent[0] + axisExtent[1];

    axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
        return coord + coordBase;
    } : function (coord) {
        return axisExtentSum - coord + coordBase;
    };
    axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
        return coord - coordBase;
    } : function (coord) {
        return axisExtentSum - coord + coordBase;
    };
}

var axesTypes = ['xAxis', 'yAxis'];

function findAxesModels(seriesModel, ecModel) {
    return util["v" /* map */](axesTypes, function (axisType) {
        var axisModel = seriesModel.getReferringComponents(axisType)[0];

        if (false) {
            if (!axisModel) {
                throw new Error(axisType + ' "' + zrUtil.retrieve(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '" not found');
            }
        }
        return axisModel;
    });
}

function isCartesian2D(seriesModel) {
    return seriesModel.get('coordinateSystem') === 'cartesian2d';
}

Grid.create = function (ecModel, api) {
    var grids = [];
    ecModel.eachComponent('grid', function (gridModel, idx) {
        var grid = new Grid(gridModel, ecModel, api);
        grid.name = 'grid_' + idx;

        grid.resize(gridModel, api, true);

        gridModel.coordinateSystem = grid;

        grids.push(grid);
    });

    ecModel.eachSeries(function (seriesModel) {
        if (!isCartesian2D(seriesModel)) {
            return;
        }

        var axesModels = findAxesModels(seriesModel, ecModel);
        var xAxisModel = axesModels[0];
        var yAxisModel = axesModels[1];

        var gridModel = xAxisModel.getCoordSysModel();

        if (false) {
            if (!gridModel) {
                throw new Error('Grid "' + zrUtil.retrieve(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '" not found');
            }
            if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
                throw new Error('xAxis and yAxis must use the same grid');
            }
        }

        var grid = gridModel.coordinateSystem;

        seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });

    return grids;
};

Grid.dimensions = Grid.prototype.dimensions = cartesian_Cartesian2D.prototype.dimensions;

src_CoordinateSystem.register('cartesian2d', Grid);

/* harmony default export */ var cartesian_Grid = (Grid);
// EXTERNAL MODULE: ./node_modules/echarts/src/data/List.js
var List = __webpack_require__(227);

// CONCATENATED MODULE: ./node_modules/echarts/src/data/helper/completeDimensions.js





var completeDimensions_each = util["i" /* each */];
var isString = util["u" /* isString */];
var defaults = util["h" /* defaults */];

var OTHER_DIMS = { tooltip: 1, label: 1, itemName: 1 };

function completeDimensions(sysDims, data, opt) {
    data = data || [];
    opt = opt || {};
    sysDims = (sysDims || []).slice();
    var dimsDef = (opt.dimsDef || []).slice();
    var encodeDef = util["f" /* createHashMap */](opt.encodeDef);
    var dataDimNameMap = util["f" /* createHashMap */]();
    var coordDimNameMap = util["f" /* createHashMap */]();

    var result = [];

    var dimCount = opt.dimCount;
    if (dimCount == null) {
        var value0 = retrieveValue(data[0]);
        dimCount = Math.max(util["p" /* isArray */](value0) && value0.length || 1, sysDims.length, dimsDef.length);
        completeDimensions_each(sysDims, function (sysDimItem) {
            var sysDimItemDimsDef = sysDimItem.dimsDef;
            sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
        });
    }

    for (var i = 0; i < dimCount; i++) {
        var dimDefItem = isString(dimsDef[i]) ? { name: dimsDef[i] } : dimsDef[i] || {};
        var userDimName = dimDefItem.name;
        var resultItem = result[i] = { otherDims: {} };

        if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
            resultItem.name = resultItem.tooltipName = userDimName;
            dataDimNameMap.set(userDimName, i);
        }
        dimDefItem.type != null && (resultItem.type = dimDefItem.type);
    }

    encodeDef.each(function (dataDims, coordDim) {
        dataDims = encodeDef.set(coordDim, Object(util_model["m" /* normalizeToArray */])(dataDims).slice());
        completeDimensions_each(dataDims, function (resultDimIdx, coordDimIndex) {
            isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));
            if (resultDimIdx != null && resultDimIdx < dimCount) {
                dataDims[coordDimIndex] = resultDimIdx;
                applyDim(result[resultDimIdx], coordDim, coordDimIndex);
            }
        });
    });

    var availDimIdx = 0;
    completeDimensions_each(sysDims, function (sysDimItem, sysDimIndex) {
        var coordDim;
        var sysDimItem;
        var sysDimItemDimsDef;
        var sysDimItemOtherDims;
        if (isString(sysDimItem)) {
            coordDim = sysDimItem;
            sysDimItem = {};
        } else {
            coordDim = sysDimItem.name;
            sysDimItem = util["d" /* clone */](sysDimItem);

            sysDimItemDimsDef = sysDimItem.dimsDef;
            sysDimItemOtherDims = sysDimItem.otherDims;
            sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
        }

        var dataDims = Object(util_model["m" /* normalizeToArray */])(encodeDef.get(coordDim));

        if (!dataDims.length) {
            for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
                while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
                    availDimIdx++;
                }
                availDimIdx < result.length && dataDims.push(availDimIdx++);
            }
        }

        completeDimensions_each(dataDims, function (resultDimIdx, coordDimIndex) {
            var resultItem = result[resultDimIdx];
            applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);
            if (resultItem.name == null && sysDimItemDimsDef) {
                resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];
            }
            sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);
        });
    });

    var extra = opt.extraPrefix || 'value';

    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
        var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};
        var coordDim = resultItem.coordDim;

        coordDim == null && (resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero), resultItem.coordDimIndex = 0, resultItem.isExtraCoord = true);

        resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));

        resultItem.type == null && guessOrdinal(data, resultDimIdx) && (resultItem.type = 'ordinal');
    }

    return result;

    function applyDim(resultItem, coordDim, coordDimIndex) {
        if (OTHER_DIMS[coordDim]) {
            resultItem.otherDims[coordDim] = coordDimIndex;
        } else {
            resultItem.coordDim = coordDim;
            resultItem.coordDimIndex = coordDimIndex;
            coordDimNameMap.set(coordDim, true);
        }
    }

    function genName(name, map, fromZero) {
        if (fromZero || map.get(name) != null) {
            var i = 0;
            while (map.get(name + i) != null) {
                i++;
            }
            name += i;
        }
        map.set(name, true);
        return name;
    }
}

var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {
    for (var i = 0, len = data.length; i < len; i++) {
        var value = retrieveValue(data[i]);

        if (!util["p" /* isArray */](value)) {
            return false;
        }

        var value = value[dimIndex];

        if (value != null && isFinite(value) && value !== '') {
            return false;
        } else if (isString(value) && value !== '-') {
            return true;
        }
    }
    return false;
};

function retrieveValue(o) {
    return util["p" /* isArray */](o) ? o : util["t" /* isObject */](o) ? o.value : o;
}

/* harmony default export */ var helper_completeDimensions = (completeDimensions);
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/helper/createListFromArray.js






function firstDataNotNull(data) {
    var i = 0;
    while (i < data.length && data[i] == null) {
        i++;
    }
    return data[i];
}
function ifNeedCompleteOrdinalData(data) {
    var sampleItem = firstDataNotNull(data);
    return sampleItem != null && !util["p" /* isArray */](Object(util_model["g" /* getDataItemValue */])(sampleItem));
}

function createListFromArray(data, seriesModel, ecModel) {
    data = data || [];

    if (false) {
        if (!zrUtil.isArray(data)) {
            throw new Error('Invalid data.');
        }
    }

    var coordSysName = seriesModel.get('coordinateSystem');
    var creator = creators[coordSysName];
    var registeredCoordSys = src_CoordinateSystem.get(coordSysName);
    var completeDimOpt = {
        encodeDef: seriesModel.get('encode'),
        dimsDef: seriesModel.get('dimensions')
    };

    var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);
    var dimensions = axesInfo && axesInfo.dimensions;
    if (!dimensions) {
        dimensions = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];
        dimensions = helper_completeDimensions(dimensions, data, completeDimOpt);
    }

    var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;

    var list = new List["a" /* default */](dimensions, seriesModel);

    var nameList = createNameList(axesInfo, data);

    var categories = {};
    var dimValueGetter = categoryIndex >= 0 && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {
        if (Object(util_model["h" /* isDataItemOption */])(itemOpt)) {
            list.hasItemOption = true;
        }

        return dimIndex === categoryIndex ? dataIndex : Object(util_model["b" /* converDataValue */])(Object(util_model["g" /* getDataItemValue */])(itemOpt), dimensions[dimIndex]);
    } : function (itemOpt, dimName, dataIndex, dimIndex) {
        var value = Object(util_model["g" /* getDataItemValue */])(itemOpt);
        var val = Object(util_model["b" /* converDataValue */])(value && value[dimIndex], dimensions[dimIndex]);

        if (Object(util_model["h" /* isDataItemOption */])(itemOpt)) {
            list.hasItemOption = true;
        }

        var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;
        if (categoryAxesModels && categoryAxesModels[dimName]) {
            if (typeof val === 'string') {
                categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories();
                val = util["n" /* indexOf */](categories[dimName], val);
                if (val < 0 && !isNaN(val)) {
                    val = +val;
                }
            }
        }
        return val;
    };

    list.hasItemOption = false;
    list.initData(data, nameList, dimValueGetter);

    return list;
}

function isStackable(axisType) {
    return axisType !== 'category' && axisType !== 'time';
}

function getDimTypeByAxis(axisType) {
    return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
}

var creators = {

    cartesian2d: function cartesian2d(data, seriesModel, ecModel, completeDimOpt) {

        var axesModels = util["v" /* map */](['xAxis', 'yAxis'], function (name) {
            return ecModel.queryComponents({
                mainType: name,
                index: seriesModel.get(name + 'Index'),
                id: seriesModel.get(name + 'Id')
            })[0];
        });
        var xAxisModel = axesModels[0];
        var yAxisModel = axesModels[1];

        if (false) {
            if (!xAxisModel) {
                throw new Error('xAxis "' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '" not found');
            }
            if (!yAxisModel) {
                throw new Error('yAxis "' + zrUtil.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '" not found');
            }
        }

        var xAxisType = xAxisModel.get('type');
        var yAxisType = yAxisModel.get('type');

        var dimensions = [{
            name: 'x',
            type: getDimTypeByAxis(xAxisType),
            stackable: isStackable(xAxisType)
        }, {
            name: 'y',

            type: getDimTypeByAxis(yAxisType),
            stackable: isStackable(yAxisType)
        }];

        var isXAxisCateogry = xAxisType === 'category';
        var isYAxisCategory = yAxisType === 'category';

        dimensions = helper_completeDimensions(dimensions, data, completeDimOpt);

        var categoryAxesModels = {};
        if (isXAxisCateogry) {
            categoryAxesModels.x = xAxisModel;
        }
        if (isYAxisCategory) {
            categoryAxesModels.y = yAxisModel;
        }
        return {
            dimensions: dimensions,
            categoryIndex: isXAxisCateogry ? 0 : isYAxisCategory ? 1 : -1,
            categoryAxesModels: categoryAxesModels
        };
    },

    singleAxis: function singleAxis(data, seriesModel, ecModel, completeDimOpt) {

        var singleAxisModel = ecModel.queryComponents({
            mainType: 'singleAxis',
            index: seriesModel.get('singleAxisIndex'),
            id: seriesModel.get('singleAxisId')
        })[0];

        if (false) {
            if (!singleAxisModel) {
                throw new Error('singleAxis should be specified.');
            }
        }

        var singleAxisType = singleAxisModel.get('type');
        var isCategory = singleAxisType === 'category';

        var dimensions = [{
            name: 'single',
            type: getDimTypeByAxis(singleAxisType),
            stackable: isStackable(singleAxisType)
        }];

        dimensions = helper_completeDimensions(dimensions, data, completeDimOpt);

        var categoryAxesModels = {};
        if (isCategory) {
            categoryAxesModels.single = singleAxisModel;
        }

        return {
            dimensions: dimensions,
            categoryIndex: isCategory ? 0 : -1,
            categoryAxesModels: categoryAxesModels
        };
    },

    polar: function polar(data, seriesModel, ecModel, completeDimOpt) {
        var polarModel = ecModel.queryComponents({
            mainType: 'polar',
            index: seriesModel.get('polarIndex'),
            id: seriesModel.get('polarId')
        })[0];

        var angleAxisModel = polarModel.findAxisModel('angleAxis');
        var radiusAxisModel = polarModel.findAxisModel('radiusAxis');

        if (false) {
            if (!angleAxisModel) {
                throw new Error('angleAxis option not found');
            }
            if (!radiusAxisModel) {
                throw new Error('radiusAxis option not found');
            }
        }

        var radiusAxisType = radiusAxisModel.get('type');
        var angleAxisType = angleAxisModel.get('type');

        var dimensions = [{
            name: 'radius',
            type: getDimTypeByAxis(radiusAxisType),
            stackable: isStackable(radiusAxisType)
        }, {
            name: 'angle',
            type: getDimTypeByAxis(angleAxisType),
            stackable: isStackable(angleAxisType)
        }];
        var isAngleAxisCateogry = angleAxisType === 'category';
        var isRadiusAxisCateogry = radiusAxisType === 'category';

        dimensions = helper_completeDimensions(dimensions, data, completeDimOpt);

        var categoryAxesModels = {};
        if (isRadiusAxisCateogry) {
            categoryAxesModels.radius = radiusAxisModel;
        }
        if (isAngleAxisCateogry) {
            categoryAxesModels.angle = angleAxisModel;
        }
        return {
            dimensions: dimensions,
            categoryIndex: isAngleAxisCateogry ? 1 : isRadiusAxisCateogry ? 0 : -1,
            categoryAxesModels: categoryAxesModels
        };
    },

    geo: function geo(data, seriesModel, ecModel, completeDimOpt) {
        return {
            dimensions: helper_completeDimensions([{ name: 'lng' }, { name: 'lat' }], data, completeDimOpt)
        };
    }
};

function createNameList(result, data) {
    var nameList = [];

    var categoryDim = result && result.dimensions[result.categoryIndex];
    var categoryAxisModel;
    if (categoryDim) {
        categoryAxisModel = result.categoryAxesModels[categoryDim.name];
    }

    if (categoryAxisModel) {
        var categories = categoryAxisModel.getCategories();
        if (categories) {
            var dataLen = data.length;

            if (util["p" /* isArray */](data[0]) && data[0].length > 1) {
                nameList = [];
                for (var i = 0; i < dataLen; i++) {
                    nameList[i] = categories[data[i][result.categoryIndex || 0]];
                }
            } else {
                nameList = categories.slice(0);
            }
        }
    }

    return nameList;
}

/* harmony default export */ var helper_createListFromArray = (createListFromArray);
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/bar/BaseBarSeries.js



/* harmony default export */ var BaseBarSeries = (Series.extend({

    type: 'series.__base_bar__',

    getInitialData: function getInitialData(option, ecModel) {
        return helper_createListFromArray(option.data, this, ecModel);
    },

    getMarkerPosition: function getMarkerPosition(value) {
        var coordSys = this.coordinateSystem;
        if (coordSys) {
            var pt = coordSys.dataToPoint(value, true);
            var data = this.getData();
            var offset = data.getLayout('offset');
            var size = data.getLayout('size');
            var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
            pt[offsetIndex] += offset + size / 2;
            return pt;
        }
        return [NaN, NaN];
    },

    defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: true,

        barMinHeight: 0,

        barMinAngle: 0,

        itemStyle: {}
    }
}));
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/bar/BarSeries.js


/* harmony default export */ var BarSeries = (BaseBarSeries.extend({

    type: 'series.bar',

    dependencies: ['grid', 'polar'],

    brushSelector: 'rect'
}));
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/bar/helper.js


function setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {
    var labelModel = itemModel.getModel('label.normal');
    var hoverLabelModel = itemModel.getModel('label.emphasis');

    graphic["setLabelStyle"](normalStyle, hoverStyle, labelModel, hoverLabelModel, {
        labelFetcher: seriesModel,
        labelDataIndex: dataIndex,
        defaultText: seriesModel.getRawValue(dataIndex),
        isRectText: true,
        autoColor: color
    });

    fixPosition(normalStyle);
    fixPosition(hoverStyle);
}

function fixPosition(style, labelPositionOutside) {
    if (style.textPosition === 'outside') {
        style.textPosition = labelPositionOutside;
    }
}
// EXTERNAL MODULE: ./node_modules/echarts/src/model/mixin/makeStyleMapper.js
var makeStyleMapper = __webpack_require__(42);

// CONCATENATED MODULE: ./node_modules/echarts/src/chart/bar/barItemStyle.js


var _getBarItemStyle = Object(makeStyleMapper["a" /* default */])([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);

/* harmony default export */ var barItemStyle = ({
    getBarItemStyle: function getBarItemStyle(excludes) {
        var style = _getBarItemStyle(this, excludes);
        if (this.getBorderLineDash) {
            var lineDash = this.getBorderLineDash();
            lineDash && (style.lineDash = lineDash);
        }
        return style;
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/bar/BarView.js







var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];

util["k" /* extend */](Model["a" /* default */].prototype, barItemStyle);

/* harmony default export */ var BarView = (extendChartView({

    type: 'bar',

    render: function render(seriesModel, ecModel, api) {
        var coordinateSystemType = seriesModel.get('coordinateSystem');

        if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
            this._render(seriesModel, ecModel, api);
        } else if (false) {
            console.warn('Only cartesian2d and polar supported for bar.');
        }

        return this.group;
    },

    dispose: util["z" /* noop */],

    _render: function _render(seriesModel, ecModel, api) {
        var group = this.group;
        var data = seriesModel.getData();
        var oldData = this._data;

        var coord = seriesModel.coordinateSystem;
        var baseAxis = coord.getBaseAxis();
        var isHorizontalOrRadial;

        if (coord.type === 'cartesian2d') {
            isHorizontalOrRadial = baseAxis.isHorizontal();
        } else if (coord.type === 'polar') {
            isHorizontalOrRadial = baseAxis.dim === 'angle';
        }

        var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;

        data.diff(oldData).add(function (dataIndex) {
            if (!data.hasValue(dataIndex)) {
                return;
            }

            var itemModel = data.getItemModel(dataIndex);
            var layout = getLayout[coord.type](data, dataIndex, itemModel);
            var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);
            data.setItemGraphicEl(dataIndex, el);
            group.add(el);

            updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
        }).update(function (newIndex, oldIndex) {
            var el = oldData.getItemGraphicEl(oldIndex);

            if (!data.hasValue(newIndex)) {
                group.remove(el);
                return;
            }

            var itemModel = data.getItemModel(newIndex);
            var layout = getLayout[coord.type](data, newIndex, itemModel);

            if (el) {
                graphic["updateProps"](el, { shape: layout }, animationModel, newIndex);
            } else {
                el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);
            }

            data.setItemGraphicEl(newIndex, el);

            group.add(el);

            updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
        }).remove(function (dataIndex) {
            var el = oldData.getItemGraphicEl(dataIndex);
            if (coord.type === 'cartesian2d') {
                el && removeRect(dataIndex, animationModel, el);
            } else {
                el && removeSector(dataIndex, animationModel, el);
            }
        }).execute();

        this._data = data;
    },

    remove: function remove(ecModel, api) {
        var group = this.group;
        var data = this._data;
        if (ecModel.get('animation')) {
            if (data) {
                data.eachItemGraphicEl(function (el) {
                    if (el.type === 'sector') {
                        removeSector(el.dataIndex, ecModel, el);
                    } else {
                        removeRect(el.dataIndex, ecModel, el);
                    }
                });
            }
        } else {
            group.removeAll();
        }
    }
}));

var elementCreator = {

    cartesian2d: function cartesian2d(data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {
        var rect = new graphic["Rect"]({ shape: util["k" /* extend */]({}, layout) });

        if (animationModel) {
            var rectShape = rect.shape;
            var animateProperty = isHorizontal ? 'height' : 'width';
            var animateTarget = {};
            rectShape[animateProperty] = 0;
            animateTarget[animateProperty] = layout[animateProperty];
            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {
                shape: animateTarget
            }, animationModel, dataIndex);
        }

        return rect;
    },

    polar: function polar(data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {
        var sector = new graphic["Sector"]({ shape: util["k" /* extend */]({}, layout) });

        if (animationModel) {
            var sectorShape = sector.shape;
            var animateProperty = isRadial ? 'r' : 'endAngle';
            var animateTarget = {};
            sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
            animateTarget[animateProperty] = layout[animateProperty];
            graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {
                shape: animateTarget
            }, animationModel, dataIndex);
        }

        return sector;
    }
};

function removeRect(dataIndex, animationModel, el) {
    el.style.text = null;
    graphic["updateProps"](el, {
        shape: {
            width: 0
        }
    }, animationModel, dataIndex, function () {
        el.parent && el.parent.remove(el);
    });
}

function removeSector(dataIndex, animationModel, el) {
    el.style.text = null;
    graphic["updateProps"](el, {
        shape: {
            r: el.shape.r0
        }
    }, animationModel, dataIndex, function () {
        el.parent && el.parent.remove(el);
    });
}

var getLayout = {
    cartesian2d: function cartesian2d(data, dataIndex, itemModel) {
        var layout = data.getItemLayout(dataIndex);
        var fixedLineWidth = getLineWidth(itemModel, layout);

        var signX = layout.width > 0 ? 1 : -1;
        var signY = layout.height > 0 ? 1 : -1;
        return {
            x: layout.x + signX * fixedLineWidth / 2,
            y: layout.y + signY * fixedLineWidth / 2,
            width: layout.width - signX * fixedLineWidth,
            height: layout.height - signY * fixedLineWidth
        };
    },

    polar: function polar(data, dataIndex, itemModel) {
        var layout = data.getItemLayout(dataIndex);
        return {
            cx: layout.cx,
            cy: layout.cy,
            r0: layout.r0,
            r: layout.r,
            startAngle: layout.startAngle,
            endAngle: layout.endAngle
        };
    }
};

function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
    var color = data.getItemVisual(dataIndex, 'color');
    var opacity = data.getItemVisual(dataIndex, 'opacity');
    var itemStyleModel = itemModel.getModel('itemStyle.normal');
    var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();

    if (!isPolar) {
        el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
    }

    el.useStyle(util["h" /* defaults */]({
        fill: color,
        opacity: opacity
    }, itemStyleModel.getBarItemStyle()));

    var cursorStyle = itemModel.getShallow('cursor');
    cursorStyle && el.attr('cursor', cursorStyle);

    var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';

    if (!isPolar) {
        setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);
    }

    graphic["setHoverStyle"](el, hoverStyle);
}

function getLineWidth(itemModel, rawLayout) {
    var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
    return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));
}
// CONCATENATED MODULE: ./node_modules/echarts/src/util/symbol.js






var Triangle = graphic["extendShape"]({
    type: 'triangle',
    shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
    },
    buildPath: function buildPath(path, shape) {
        var cx = shape.cx;
        var cy = shape.cy;
        var width = shape.width / 2;
        var height = shape.height / 2;
        path.moveTo(cx, cy - height);
        path.lineTo(cx + width, cy + height);
        path.lineTo(cx - width, cy + height);
        path.closePath();
    }
});

var Diamond = graphic["extendShape"]({
    type: 'diamond',
    shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
    },
    buildPath: function buildPath(path, shape) {
        var cx = shape.cx;
        var cy = shape.cy;
        var width = shape.width / 2;
        var height = shape.height / 2;
        path.moveTo(cx, cy - height);
        path.lineTo(cx + width, cy);
        path.lineTo(cx, cy + height);
        path.lineTo(cx - width, cy);
        path.closePath();
    }
});

var Pin = graphic["extendShape"]({
    type: 'pin',
    shape: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    buildPath: function buildPath(path, shape) {
        var x = shape.x;
        var y = shape.y;
        var w = shape.width / 5 * 3;

        var h = Math.max(w, shape.height);
        var r = w / 2;

        var dy = r * r / (h - r);
        var cy = y - h + r + dy;
        var angle = Math.asin(dy / r);

        var dx = Math.cos(angle) * r;

        var tanX = Math.sin(angle);
        var tanY = Math.cos(angle);

        var cpLen = r * 0.6;
        var cpLen2 = r * 0.7;

        path.moveTo(x - dx, cy + dy);

        path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
        path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
        path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
        path.closePath();
    }
});

var Arrow = graphic["extendShape"]({

    type: 'arrow',

    shape: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    buildPath: function buildPath(ctx, shape) {
        var height = shape.height;
        var width = shape.width;
        var x = shape.x;
        var y = shape.y;
        var dx = width / 3 * 2;
        ctx.moveTo(x, y);
        ctx.lineTo(x + dx, y + height);
        ctx.lineTo(x, y + height / 4 * 3);
        ctx.lineTo(x - dx, y + height);
        ctx.lineTo(x, y);
        ctx.closePath();
    }
});

var symbolCtors = {

    line: graphic["Line"],

    rect: graphic["Rect"],

    roundRect: graphic["Rect"],

    square: graphic["Rect"],

    circle: graphic["Circle"],

    diamond: Diamond,

    pin: Pin,

    arrow: Arrow,

    triangle: Triangle
};

var symbolShapeMakers = {

    line: function line(x, y, w, h, shape) {
        shape.x1 = x;
        shape.y1 = y + h / 2;
        shape.x2 = x + w;
        shape.y2 = y + h / 2;
    },

    rect: function rect(x, y, w, h, shape) {
        shape.x = x;
        shape.y = y;
        shape.width = w;
        shape.height = h;
    },

    roundRect: function roundRect(x, y, w, h, shape) {
        shape.x = x;
        shape.y = y;
        shape.width = w;
        shape.height = h;
        shape.r = Math.min(w, h) / 4;
    },

    square: function square(x, y, w, h, shape) {
        var size = Math.min(w, h);
        shape.x = x;
        shape.y = y;
        shape.width = size;
        shape.height = size;
    },

    circle: function circle(x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.r = Math.min(w, h) / 2;
    },

    diamond: function diamond(x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.width = w;
        shape.height = h;
    },

    pin: function pin(x, y, w, h, shape) {
        shape.x = x + w / 2;
        shape.y = y + h / 2;
        shape.width = w;
        shape.height = h;
    },

    arrow: function arrow(x, y, w, h, shape) {
        shape.x = x + w / 2;
        shape.y = y + h / 2;
        shape.width = w;
        shape.height = h;
    },

    triangle: function triangle(x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.width = w;
        shape.height = h;
    }
};

var symbolBuildProxies = {};
util["i" /* each */](symbolCtors, function (Ctor, name) {
    symbolBuildProxies[name] = new Ctor();
});

var SymbolClz = graphic["extendShape"]({

    type: 'symbol',

    shape: {
        symbolType: '',
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    beforeBrush: function beforeBrush() {
        var style = this.style;
        var shape = this.shape;

        if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
            style.textPosition = ['50%', '40%'];
            style.textAlign = 'center';
            style.textVerticalAlign = 'middle';
        }
    },

    buildPath: function buildPath(ctx, shape, inBundle) {
        var symbolType = shape.symbolType;
        var proxySymbol = symbolBuildProxies[symbolType];
        if (shape.symbolType !== 'none') {
            if (!proxySymbol) {
                symbolType = 'rect';
                proxySymbol = symbolBuildProxies[symbolType];
            }
            symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
            proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
        }
    }
});

function symbolPathSetColor(color, innerColor) {
    if (this.type !== 'image') {
        var symbolStyle = this.style;
        var symbolShape = this.shape;
        if (symbolShape && symbolShape.symbolType === 'line') {
            symbolStyle.stroke = color;
        } else if (this.__isEmptyBrush) {
            symbolStyle.stroke = color;
            symbolStyle.fill = innerColor || '#fff';
        } else {
            symbolStyle.fill && (symbolStyle.fill = color);
            symbolStyle.stroke && (symbolStyle.stroke = color);
        }
        this.dirty(false);
    }
}

function createSymbol(symbolType, x, y, w, h, color, keepAspect) {

    var isEmpty = symbolType.indexOf('empty') === 0;
    if (isEmpty) {
        symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
    }
    var symbolPath;

    if (symbolType.indexOf('image://') === 0) {
        symbolPath = graphic["makeImage"](symbolType.slice(8), new BoundingRect["a" /* default */](x, y, w, h), keepAspect ? 'center' : 'cover');
    } else if (symbolType.indexOf('path://') === 0) {
        symbolPath = graphic["makePath"](symbolType.slice(7), {}, new BoundingRect["a" /* default */](x, y, w, h), keepAspect ? 'center' : 'cover');
    } else {
        symbolPath = new SymbolClz({
            shape: {
                symbolType: symbolType,
                x: x,
                y: y,
                width: w,
                height: h
            }
        });
    }

    symbolPath.__isEmptyBrush = isEmpty;

    symbolPath.setColor = symbolPathSetColor;

    symbolPath.setColor(color);

    return symbolPath;
}
// EXTERNAL MODULE: ./node_modules/zrender/src/core/matrix.js
var core_matrix = __webpack_require__(31);

// CONCATENATED MODULE: ./node_modules/echarts/src/component/axis/AxisBuilder.js









var AxisBuilder_PI = Math.PI;

function makeAxisEventDataBase(axisModel) {
    var eventData = {
        componentType: axisModel.mainType
    };
    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
    return eventData;
}

var AxisBuilder_AxisBuilder = function AxisBuilder(axisModel, opt) {
    this.opt = opt;

    this.axisModel = axisModel;

    Object(util["h" /* defaults */])(opt, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: true
    });

    this.group = new graphic["Group"]();

    var dumbGroup = new graphic["Group"]({
        position: opt.position.slice(),
        rotation: opt.rotation
    });

    dumbGroup.updateTransform();
    this._transform = dumbGroup.transform;

    this._dumbGroup = dumbGroup;
};

AxisBuilder_AxisBuilder.prototype = {

    constructor: AxisBuilder_AxisBuilder,

    hasBuilder: function hasBuilder(name) {
        return !!builders[name];
    },

    add: function add(name) {
        builders[name].call(this);
    },

    getGroup: function getGroup() {
        return this.group;
    }

};

var builders = {
    axisLine: function axisLine() {
        var opt = this.opt;
        var axisModel = this.axisModel;

        if (!axisModel.get('axisLine.show')) {
            return;
        }

        var extent = this.axisModel.axis.getExtent();

        var matrix = this._transform;
        var pt1 = [extent[0], 0];
        var pt2 = [extent[1], 0];
        if (matrix) {
            Object(vector["b" /* applyTransform */])(pt1, pt1, matrix);
            Object(vector["b" /* applyTransform */])(pt2, pt2, matrix);
        }

        var lineStyle = Object(util["k" /* extend */])({
            lineCap: 'round'
        }, axisModel.getModel('axisLine.lineStyle').getLineStyle());

        this.group.add(new graphic["Line"](graphic["subPixelOptimizeLine"]({
            anid: 'line',

            shape: {
                x1: pt1[0],
                y1: pt1[1],
                x2: pt2[0],
                y2: pt2[1]
            },
            style: lineStyle,
            strokeContainThreshold: opt.strokeContainThreshold || 5,
            silent: true,
            z2: 1
        })));

        var arrows = axisModel.get('axisLine.symbol');
        var arrowSize = axisModel.get('axisLine.symbolSize');

        if (arrows != null) {
            if (typeof arrows === 'string') {
                arrows = [arrows, arrows];
            }
            if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {
                arrowSize = [arrowSize, arrowSize];
            }

            var symbolWidth = arrowSize[0];
            var symbolHeight = arrowSize[1];

            Object(util["i" /* each */])([[opt.rotation + Math.PI / 2, pt1], [opt.rotation - Math.PI / 2, pt2]], function (item, index) {
                if (arrows[index] !== 'none' && arrows[index] != null) {
                    var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);
                    symbol.attr({
                        rotation: item[0],
                        position: item[1],
                        silent: true
                    });
                    this.group.add(symbol);
                }
            }, this);
        }
    },

    axisTickLabel: function axisTickLabel() {
        var axisModel = this.axisModel;
        var opt = this.opt;

        var tickEls = buildAxisTick(this, axisModel, opt);
        var labelEls = buildAxisLabel(this, axisModel, opt);

        fixMinMaxLabelShow(axisModel, labelEls, tickEls);
    },

    axisName: function axisName() {
        var opt = this.opt;
        var axisModel = this.axisModel;
        var name = Object(util["C" /* retrieve */])(opt.axisName, axisModel.get('name'));

        if (!name) {
            return;
        }

        var nameLocation = axisModel.get('nameLocation');
        var nameDirection = opt.nameDirection;
        var textStyleModel = axisModel.getModel('nameTextStyle');
        var gap = axisModel.get('nameGap') || 0;

        var extent = this.axisModel.axis.getExtent();
        var gapSignal = extent[0] > extent[1] ? -1 : 1;
        var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];

        var labelLayout;

        var nameRotation = axisModel.get('nameRotate');
        if (nameRotation != null) {
            nameRotation = nameRotation * AxisBuilder_PI / 180;
        }

        var axisNameAvailableWidth;

        if (isNameLocationCenter(nameLocation)) {
            labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);
        } else {
            labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);

            axisNameAvailableWidth = opt.axisNameAvailableWidth;
            if (axisNameAvailableWidth != null) {
                axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
                !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
            }
        }

        var textFont = textStyleModel.getFont();

        var truncateOpt = axisModel.get('nameTruncate', true) || {};
        var ellipsis = truncateOpt.ellipsis;
        var maxWidth = Object(util["C" /* retrieve */])(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);

        var truncatedText = ellipsis != null && maxWidth != null ? format["i" /* truncateText */](name, maxWidth, textFont, ellipsis, { minChar: 2, placeholder: truncateOpt.placeholder }) : name;

        var tooltipOpt = axisModel.get('tooltip', true);

        var mainType = axisModel.mainType;
        var formatterParams = {
            componentType: mainType,
            name: name,
            $vars: ['name']
        };
        formatterParams[mainType + 'Index'] = axisModel.componentIndex;

        var textEl = new graphic["Text"]({
            anid: 'name',

            __fullText: name,
            __truncatedText: truncatedText,

            position: pos,
            rotation: labelLayout.rotation,
            silent: isSilent(axisModel),
            z2: 1,
            tooltip: tooltipOpt && tooltipOpt.show ? Object(util["k" /* extend */])({
                content: name,
                formatter: function formatter() {
                    return name;
                },
                formatterParams: formatterParams
            }, tooltipOpt) : null
        });

        graphic["setTextStyle"](textEl.style, textStyleModel, {
            text: truncatedText,
            textFont: textFont,
            textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),
            textAlign: labelLayout.textAlign,
            textVerticalAlign: labelLayout.textVerticalAlign
        });

        if (axisModel.get('triggerEvent')) {
            textEl.eventData = makeAxisEventDataBase(axisModel);
            textEl.eventData.targetType = 'axisName';
            textEl.eventData.name = name;
        }

        this._dumbGroup.add(textEl);
        textEl.updateTransform();

        this.group.add(textEl);

        textEl.decomposeTransform();
    }

};

var innerTextLayout = AxisBuilder_AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
    var rotationDiff = Object(number["j" /* remRadian */])(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;

    if (Object(number["d" /* isRadianAroundZero */])(rotationDiff)) {
        textVerticalAlign = direction > 0 ? 'top' : 'bottom';
        textAlign = 'center';
    } else if (Object(number["d" /* isRadianAroundZero */])(rotationDiff - AxisBuilder_PI)) {
        textVerticalAlign = direction > 0 ? 'bottom' : 'top';
        textAlign = 'center';
    } else {
        textVerticalAlign = 'middle';

        if (rotationDiff > 0 && rotationDiff < AxisBuilder_PI) {
            textAlign = direction > 0 ? 'right' : 'left';
        } else {
            textAlign = direction > 0 ? 'left' : 'right';
        }
    }

    return {
        rotation: rotationDiff,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
    };
};

function endTextLayout(opt, textPosition, textRotate, extent) {
    var rotationDiff = Object(number["j" /* remRadian */])(textRotate - opt.rotation);
    var textAlign;
    var textVerticalAlign;
    var inverse = extent[0] > extent[1];
    var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;

    if (Object(number["d" /* isRadianAroundZero */])(rotationDiff - AxisBuilder_PI / 2)) {
        textVerticalAlign = onLeft ? 'bottom' : 'top';
        textAlign = 'center';
    } else if (Object(number["d" /* isRadianAroundZero */])(rotationDiff - AxisBuilder_PI * 1.5)) {
        textVerticalAlign = onLeft ? 'top' : 'bottom';
        textAlign = 'center';
    } else {
        textVerticalAlign = 'middle';
        if (rotationDiff < AxisBuilder_PI * 1.5 && rotationDiff > AxisBuilder_PI / 2) {
            textAlign = onLeft ? 'left' : 'right';
        } else {
            textAlign = onLeft ? 'right' : 'left';
        }
    }

    return {
        rotation: rotationDiff,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
    };
}

function isSilent(axisModel) {
    var tooltipOpt = axisModel.get('tooltip');
    return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
}

function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
    var showMinLabel = axisModel.get('axisLabel.showMinLabel');
    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');

    labelEls = labelEls || [];
    tickEls = tickEls || [];

    var firstLabel = labelEls[0];
    var nextLabel = labelEls[1];
    var lastLabel = labelEls[labelEls.length - 1];
    var prevLabel = labelEls[labelEls.length - 2];

    var firstTick = tickEls[0];
    var nextTick = tickEls[1];
    var lastTick = tickEls[tickEls.length - 1];
    var prevTick = tickEls[tickEls.length - 2];

    if (showMinLabel === false) {
        ignoreEl(firstLabel);
        ignoreEl(firstTick);
    } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
        if (showMinLabel) {
            ignoreEl(nextLabel);
            ignoreEl(nextTick);
        } else {
            ignoreEl(firstLabel);
            ignoreEl(firstTick);
        }
    }

    if (showMaxLabel === false) {
        ignoreEl(lastLabel);
        ignoreEl(lastTick);
    } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
        if (showMaxLabel) {
            ignoreEl(prevLabel);
            ignoreEl(prevTick);
        } else {
            ignoreEl(lastLabel);
            ignoreEl(lastTick);
        }
    }
}

function ignoreEl(el) {
    el && (el.ignore = true);
}

function isTwoLabelOverlapped(current, next, labelLayout) {
    var firstRect = current && current.getBoundingRect().clone();
    var nextRect = next && next.getBoundingRect().clone();

    if (!firstRect || !nextRect) {
        return;
    }

    var mRotationBack = core_matrix["c" /* identity */]([]);
    core_matrix["f" /* rotate */](mRotationBack, mRotationBack, -current.rotation);

    firstRect.applyTransform(core_matrix["e" /* mul */]([], mRotationBack, current.getLocalTransform()));
    nextRect.applyTransform(core_matrix["e" /* mul */]([], mRotationBack, next.getLocalTransform()));

    return firstRect.intersect(nextRect);
}

function isNameLocationCenter(nameLocation) {
    return nameLocation === 'middle' || nameLocation === 'center';
}

var ifIgnoreOnTick = AxisBuilder_AxisBuilder.ifIgnoreOnTick = function (axis, i, interval, ticksCnt, showMinLabel, showMaxLabel) {
    if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {
        return false;
    }

    var rawTick;
    var scale = axis.scale;
    return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));
};

var getInterval = AxisBuilder_AxisBuilder.getInterval = function (model, labelInterval) {
    var interval = model.get('interval');
    if (interval == null || interval == 'auto') {
        interval = labelInterval;
    }
    return interval;
};

function buildAxisTick(axisBuilder, axisModel, opt) {
    var axis = axisModel.axis;

    if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {
        return;
    }

    var tickModel = axisModel.getModel('axisTick');

    var lineStyleModel = tickModel.getModel('lineStyle');
    var tickLen = tickModel.get('length');

    var tickInterval = getInterval(tickModel, opt.labelInterval);
    var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));

    var ticks = axis.scale.getTicks();

    var showMinLabel = axisModel.get('axisLabel.showMinLabel');
    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');

    var pt1 = [];
    var pt2 = [];
    var matrix = axisBuilder._transform;

    var tickEls = [];

    var ticksCnt = ticksCoords.length;
    for (var i = 0; i < ticksCnt; i++) {
        if (ifIgnoreOnTick(axis, i, tickInterval, ticksCnt, showMinLabel, showMaxLabel)) {
            continue;
        }

        var tickCoord = ticksCoords[i];

        pt1[0] = tickCoord;
        pt1[1] = 0;
        pt2[0] = tickCoord;
        pt2[1] = opt.tickDirection * tickLen;

        if (matrix) {
            Object(vector["b" /* applyTransform */])(pt1, pt1, matrix);
            Object(vector["b" /* applyTransform */])(pt2, pt2, matrix);
        }

        var tickEl = new graphic["Line"](graphic["subPixelOptimizeLine"]({
            anid: 'tick_' + ticks[i],

            shape: {
                x1: pt1[0],
                y1: pt1[1],
                x2: pt2[0],
                y2: pt2[1]
            },
            style: Object(util["h" /* defaults */])(lineStyleModel.getLineStyle(), {
                stroke: axisModel.get('axisLine.lineStyle.color')
            }),
            z2: 2,
            silent: true
        }));
        axisBuilder.group.add(tickEl);
        tickEls.push(tickEl);
    }

    return tickEls;
}

function buildAxisLabel(axisBuilder, axisModel, opt) {
    var axis = axisModel.axis;
    var show = Object(util["C" /* retrieve */])(opt.axisLabelShow, axisModel.get('axisLabel.show'));

    if (!show || axis.scale.isBlank()) {
        return;
    }

    var labelModel = axisModel.getModel('axisLabel');
    var labelMargin = labelModel.get('margin');
    var ticks = axis.scale.getTicks();
    var labels = axisModel.getFormattedLabels();

    var labelRotation = (Object(util["C" /* retrieve */])(opt.labelRotate, labelModel.get('rotate')) || 0) * AxisBuilder_PI / 180;

    var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
    var categoryData = axisModel.get('data');

    var labelEls = [];
    var silent = isSilent(axisModel);
    var triggerEvent = axisModel.get('triggerEvent');

    var showMinLabel = axisModel.get('axisLabel.showMinLabel');
    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');

    Object(util["i" /* each */])(ticks, function (tickVal, index) {
        if (ifIgnoreOnTick(axis, index, opt.labelInterval, ticks.length, showMinLabel, showMaxLabel)) {
            return;
        }

        var itemLabelModel = labelModel;
        if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {
            itemLabelModel = new Model["a" /* default */](categoryData[tickVal].textStyle, labelModel, axisModel.ecModel);
        }

        var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');

        var tickCoord = axis.dataToCoord(tickVal);
        var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
        var labelStr = axis.scale.getLabel(tickVal);

        var textEl = new graphic["Text"]({
            anid: 'label_' + tickVal,
            position: pos,
            rotation: labelLayout.rotation,
            silent: silent,
            z2: 10
        });

        graphic["setTextStyle"](textEl.style, itemLabelModel, {
            text: labels[index],
            textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
            textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
            textFill: typeof textColor === 'function' ? textColor(axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal, index) : textColor
        });

        if (triggerEvent) {
            textEl.eventData = makeAxisEventDataBase(axisModel);
            textEl.eventData.targetType = 'axisLabel';
            textEl.eventData.value = labelStr;
        }

        axisBuilder._dumbGroup.add(textEl);
        textEl.updateTransform();

        labelEls.push(textEl);
        axisBuilder.group.add(textEl);

        textEl.decomposeTransform();
    });

    return labelEls;
}

/* harmony default export */ var axis_AxisBuilder = (AxisBuilder_AxisBuilder);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer/modelHelper.js



var modelHelper_each = util["i" /* each */];
var curry = util["g" /* curry */];

function collect(ecModel, api) {
    var result = {
        axesInfo: {},
        seriesInvolved: false,

        coordSysAxesInfo: {},
        coordSysMap: {}
    };

    collectAxesInfo(result, ecModel, api);

    result.seriesInvolved && collectSeriesInfo(result, ecModel);

    return result;
}

function collectAxesInfo(result, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent('tooltip');
    var globalAxisPointerModel = ecModel.getComponent('axisPointer');

    var linksOption = globalAxisPointerModel.get('link', true) || [];
    var linkGroups = [];

    modelHelper_each(api.getCoordinateSystems(), function (coordSys) {
        if (!coordSys.axisPointerEnabled) {
            return;
        }

        var coordSysKey = makeKey(coordSys.model);
        var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
        result.coordSysMap[coordSysKey] = coordSys;

        var coordSysModel = coordSys.model;
        var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);

        modelHelper_each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));

        if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get('show')) {
            var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
            var cross = baseTooltipModel.get('axisPointer.type') === 'cross';
            var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));
            if (triggerAxis || cross) {
                modelHelper_each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
            }
            if (cross) {
                modelHelper_each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));
            }
        }

        function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
            var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);

            var axisPointerShow = axisPointerModel.get('show');
            if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
                return;
            }

            if (triggerTooltip == null) {
                triggerTooltip = axisPointerModel.get('triggerTooltip');
            }

            axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;

            var snap = axisPointerModel.get('snap');
            var key = makeKey(axis.model);
            var involveSeries = triggerTooltip || snap || axis.type === 'category';

            var axisInfo = result.axesInfo[key] = {
                key: key,
                axis: axis,
                coordSys: coordSys,
                axisPointerModel: axisPointerModel,
                triggerTooltip: triggerTooltip,
                involveSeries: involveSeries,
                snap: snap,
                useHandle: isHandleTrigger(axisPointerModel),
                seriesModels: []
            };
            axesInfoInCoordSys[key] = axisInfo;
            result.seriesInvolved |= involveSeries;

            var groupIndex = getLinkGroupIndex(linksOption, axis);
            if (groupIndex != null) {
                var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = { axesInfo: {} });
                linkGroup.axesInfo[key] = axisInfo;
                linkGroup.mapper = linksOption[groupIndex].mapper;
                axisInfo.linkGroup = linkGroup;
            }
        }
    });
}

function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
    var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
    var volatileOption = {};

    modelHelper_each(['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'], function (field) {
        volatileOption[field] = util["d" /* clone */](tooltipAxisPointerModel.get(field));
    });

    volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;

    if (tooltipAxisPointerModel.get('type') === 'cross') {
        volatileOption.type = 'line';
    }
    var labelOption = volatileOption.label || (volatileOption.label = {});

    labelOption.show == null && (labelOption.show = false);

    if (fromTooltip === 'cross') {
        labelOption.show = true;

        if (!triggerTooltip) {
            var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
            crossStyle && util["h" /* defaults */](labelOption, crossStyle.textStyle);
        }
    }

    return axis.model.getModel('axisPointer', new Model["a" /* default */](volatileOption, globalAxisPointerModel, ecModel));
}

function collectSeriesInfo(result, ecModel) {
    ecModel.eachSeries(function (seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);
        var seriesTooltipShow = seriesModel.get('tooltip.show', true);
        if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false) {
            return;
        }

        modelHelper_each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
            var axis = axisInfo.axis;
            if (coordSys.getAxis(axis.dim) === axis) {
                axisInfo.seriesModels.push(seriesModel);
                axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
                axisInfo.seriesDataCount += seriesModel.getData().count();
            }
        });
    }, this);
}

function getLinkGroupIndex(linksOption, axis) {
    var axisModel = axis.model;
    var dim = axis.dim;
    for (var i = 0; i < linksOption.length; i++) {
        var linkOption = linksOption[i] || {};
        if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
            return i;
        }
    }
}

function checkPropInLink(linkPropValue, axisPropValue) {
    return linkPropValue === 'all' || util["p" /* isArray */](linkPropValue) && util["n" /* indexOf */](linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}

function fixValue(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    if (!axisInfo) {
        return;
    }

    var axisPointerModel = axisInfo.axisPointerModel;
    var scale = axisInfo.axis.scale;
    var option = axisPointerModel.option;
    var status = axisPointerModel.get('status');
    var value = axisPointerModel.get('value');

    if (value != null) {
        value = scale.parse(value);
    }

    var useHandle = isHandleTrigger(axisPointerModel);

    if (status == null) {
        option.status = useHandle ? 'show' : 'hide';
    }

    var extent = scale.getExtent().slice();
    extent[0] > extent[1] && extent.reverse();

    if (value == null || value > extent[1]) {
        value = extent[1];
    }
    if (value < extent[0]) {
        value = extent[0];
    }

    option.value = value;

    if (useHandle) {
        option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
    }
}

function getAxisInfo(axisModel) {
    var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
    return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}

function getAxisPointerModel(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    return axisInfo && axisInfo.axisPointerModel;
}

function isHandleTrigger(axisPointerModel) {
    return !!axisPointerModel.get('handle.show');
}

function makeKey(model) {
    return model.type + '||' + model.id;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axis/AxisView.js



var AxisView = extendComponentView({

    type: 'axis',

    _axisPointer: null,

    axisPointerClass: null,

    render: function render(axisModel, ecModel, api, payload) {
        this.axisPointerClass && fixValue(axisModel);

        AxisView.superApply(this, 'render', arguments);

        _updateAxisPointer(this, axisModel, ecModel, api, payload, true);
    },

    updateAxisPointer: function updateAxisPointer(axisModel, ecModel, api, payload, force) {
        _updateAxisPointer(this, axisModel, ecModel, api, payload, false);
    },

    remove: function remove(ecModel, api) {
        var axisPointer = this._axisPointer;
        axisPointer && axisPointer.remove(api);
        AxisView.superApply(this, 'remove', arguments);
    },

    dispose: function dispose(ecModel, api) {
        disposeAxisPointer(this, api);
        AxisView.superApply(this, 'dispose', arguments);
    }

});

function _updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
    var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);
    if (!Clazz) {
        return;
    }
    var axisPointerModel = getAxisPointerModel(axisModel);
    axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
}

function disposeAxisPointer(axisView, ecModel, api) {
    var axisPointer = axisView._axisPointer;
    axisPointer && axisPointer.dispose(ecModel, api);
    axisView._axisPointer = null;
}

var axisPointerClazz = [];

AxisView.registerAxisPointerClass = function (type, clazz) {
    if (false) {
        if (axisPointerClazz[type]) {
            throw new Error('axisPointer ' + type + ' exists');
        }
    }
    axisPointerClazz[type] = clazz;
};

AxisView.getAxisPointerClass = function (type) {
    return type && axisPointerClazz[type];
};

/* harmony default export */ var axis_AxisView = (AxisView);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axis/cartesianAxisHelper.js


function cartesianAxisHelper_layout(gridModel, axisModel, opt) {
    opt = opt || {};
    var grid = gridModel.coordinateSystem;
    var axis = axisModel.axis;
    var layout = {};

    var rawAxisPosition = axis.position;
    var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;
    var axisDim = axis.dim;

    var rect = grid.getRect();
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var idx = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 };
    var axisOffset = axisModel.get('offset') || 0;

    var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];

    if (axis.onZero) {
        var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex);
        var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));
        posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
    }

    layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]];

    layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);

    var dirMap = { top: -1, bottom: 1, left: -1, right: 1 };

    layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
    layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;

    if (axisModel.get('axisTick.inside')) {
        layout.tickDirection = -layout.tickDirection;
    }
    if (util["C" /* retrieve */](opt.labelInside, axisModel.get('axisLabel.inside'))) {
        layout.labelDirection = -layout.labelDirection;
    }

    var labelRotate = axisModel.get('axisLabel.rotate');
    layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;

    layout.labelInterval = axis.getLabelInterval();

    layout.z2 = 1;

    return layout;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axis/CartesianAxisView.js






var CartesianAxisView_ifIgnoreOnTick = axis_AxisBuilder.ifIgnoreOnTick;
var CartesianAxisView_getInterval = axis_AxisBuilder.getInterval;

var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
var selfBuilderAttrs = ['splitArea', 'splitLine'];

var CartesianAxisView = axis_AxisView.extend({

    type: 'cartesianAxis',

    axisPointerClass: 'CartesianAxisPointer',

    render: function render(axisModel, ecModel, api, payload) {

        this.group.removeAll();

        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new graphic["Group"]();

        this.group.add(this._axisGroup);

        if (!axisModel.get('show')) {
            return;
        }

        var gridModel = axisModel.getCoordSysModel();

        var layout = cartesianAxisHelper_layout(gridModel, axisModel);

        var axisBuilder = new axis_AxisBuilder(axisModel, layout);

        util["i" /* each */](axisBuilderAttrs, axisBuilder.add, axisBuilder);

        this._axisGroup.add(axisBuilder.getGroup());

        util["i" /* each */](selfBuilderAttrs, function (name) {
            if (axisModel.get(name + '.show')) {
                this['_' + name](axisModel, gridModel, layout.labelInterval);
            }
        }, this);

        graphic["groupTransition"](oldAxisGroup, this._axisGroup, axisModel);

        CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);
    },

    _splitLine: function _splitLine(axisModel, gridModel, labelInterval) {
        var axis = axisModel.axis;

        if (axis.scale.isBlank()) {
            return;
        }

        var splitLineModel = axisModel.getModel('splitLine');
        var lineStyleModel = splitLineModel.getModel('lineStyle');
        var lineColors = lineStyleModel.get('color');

        var lineInterval = CartesianAxisView_getInterval(splitLineModel, labelInterval);

        lineColors = util["p" /* isArray */](lineColors) ? lineColors : [lineColors];

        var gridRect = gridModel.coordinateSystem.getRect();
        var isHorizontal = axis.isHorizontal();

        var lineCount = 0;

        var ticksCoords = axis.getTicksCoords();
        var ticks = axis.scale.getTicks();

        var showMinLabel = axisModel.get('axisLabel.showMinLabel');
        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');

        var p1 = [];
        var p2 = [];

        var lineStyle = lineStyleModel.getLineStyle();
        for (var i = 0; i < ticksCoords.length; i++) {
            if (CartesianAxisView_ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {
                continue;
            }

            var tickCoord = axis.toGlobalCoord(ticksCoords[i]);

            if (isHorizontal) {
                p1[0] = tickCoord;
                p1[1] = gridRect.y;
                p2[0] = tickCoord;
                p2[1] = gridRect.y + gridRect.height;
            } else {
                p1[0] = gridRect.x;
                p1[1] = tickCoord;
                p2[0] = gridRect.x + gridRect.width;
                p2[1] = tickCoord;
            }

            var colorIndex = lineCount++ % lineColors.length;
            this._axisGroup.add(new graphic["Line"](graphic["subPixelOptimizeLine"]({
                anid: 'line_' + ticks[i],

                shape: {
                    x1: p1[0],
                    y1: p1[1],
                    x2: p2[0],
                    y2: p2[1]
                },
                style: util["h" /* defaults */]({
                    stroke: lineColors[colorIndex]
                }, lineStyle),
                silent: true
            })));
        }
    },

    _splitArea: function _splitArea(axisModel, gridModel, labelInterval) {
        var axis = axisModel.axis;

        if (axis.scale.isBlank()) {
            return;
        }

        var splitAreaModel = axisModel.getModel('splitArea');
        var areaStyleModel = splitAreaModel.getModel('areaStyle');
        var areaColors = areaStyleModel.get('color');

        var gridRect = gridModel.coordinateSystem.getRect();

        var ticksCoords = axis.getTicksCoords();
        var ticks = axis.scale.getTicks();

        var prevX = axis.toGlobalCoord(ticksCoords[0]);
        var prevY = axis.toGlobalCoord(ticksCoords[0]);

        var count = 0;

        var areaInterval = CartesianAxisView_getInterval(splitAreaModel, labelInterval);

        var areaStyle = areaStyleModel.getAreaStyle();
        areaColors = util["p" /* isArray */](areaColors) ? areaColors : [areaColors];

        var showMinLabel = axisModel.get('axisLabel.showMinLabel');
        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');

        for (var i = 1; i < ticksCoords.length; i++) {
            if (CartesianAxisView_ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {
                continue;
            }

            var tickCoord = axis.toGlobalCoord(ticksCoords[i]);

            var x;
            var y;
            var width;
            var height;
            if (axis.isHorizontal()) {
                x = prevX;
                y = gridRect.y;
                width = tickCoord - x;
                height = gridRect.height;
            } else {
                x = gridRect.x;
                y = prevY;
                width = gridRect.width;
                height = tickCoord - y;
            }

            var colorIndex = count++ % areaColors.length;
            this._axisGroup.add(new graphic["Rect"]({
                anid: 'area_' + ticks[i],

                shape: {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                },
                style: util["h" /* defaults */]({
                    fill: areaColors[colorIndex]
                }, areaStyle),
                silent: true
            }));

            prevX = x + width;
            prevY = y + height;
        }
    }
});

CartesianAxisView.extend({
    type: 'xAxis'
});
CartesianAxisView.extend({
    type: 'yAxis'
});
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axis.js


// CONCATENATED MODULE: ./node_modules/echarts/src/component/gridSimple.js







extendComponentView({

    type: 'grid',

    render: function render(gridModel, ecModel) {
        this.group.removeAll();
        if (gridModel.get('show')) {
            this.group.add(new graphic["Rect"]({
                shape: gridModel.coordinateSystem.getRect(),
                style: util["h" /* defaults */]({
                    fill: gridModel.get('backgroundColor')
                }, gridModel.getItemStyle()),
                silent: true,
                z2: -1
            }));
        }
    }

});

registerPreprocessor(function (option) {
    if (option.xAxis && option.yAxis && !option.grid) {
        option.grid = {};
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/bar.js










registerLayout(util["g" /* curry */](barGrid, 'bar'));

registerVisual(function (ecModel) {
    ecModel.eachSeriesByType('bar', function (seriesModel) {
        var data = seriesModel.getData();
        data.setVisual('legendSymbol', 'roundRect');
    });
});
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/line/LineSeries.js



/* harmony default export */ var LineSeries = (Series.extend({

    type: 'series.line',

    dependencies: ['grid', 'polar'],

    getInitialData: function getInitialData(option, ecModel) {
        if (false) {
            var coordSys = option.coordinateSystem;
            if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {
                throw new Error('Line not support coordinateSystem besides cartesian and polar');
            }
        }
        return helper_createListFromArray(option.data, this, ecModel);
    },

    defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: true,

        hoverAnimation: true,

        clipOverflow: true,


        label: {
            normal: {
                position: 'top'
            }
        },

        lineStyle: {
            normal: {
                width: 2,
                type: 'solid'
            }
        },

        step: false,

        smooth: false,
        smoothMonotone: null,

        symbol: 'emptyCircle',

        symbolSize: 4,

        symbolRotate: null,

        showSymbol: true,

        showAllSymbol: false,

        connectNulls: false,

        sampling: 'none',

        animationEasing: 'linear',

        progressive: 0,
        hoverLayerThreshold: Infinity
    }
}));
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/helper/labelHelper.js




function findLabelValueDim(data) {
    var valueDim;
    var labelDims = Object(util_model["n" /* otherDimToDataDim */])(data, 'label');

    if (labelDims.length) {
        valueDim = labelDims[0];
    } else {
        var dimensions = data.dimensions.slice();
        var dataType;
        while (dimensions.length && (valueDim = dimensions.pop(), dataType = data.getDimensionInfo(valueDim).type, dataType === 'ordinal' || dataType === 'time')) {}
    }

    return valueDim;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/helper/Symbol.js








function getSymbolSize(data, idx) {
    var symbolSize = data.getItemVisual(idx, 'symbolSize');
    return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
}

function getScale(symbolSize) {
    return [symbolSize[0] / 2, symbolSize[1] / 2];
}

function Symbol_SymbolClz(data, idx, seriesScope) {
    graphic["Group"].call(this);

    this.updateData(data, idx, seriesScope);
}

var symbolProto = Symbol_SymbolClz.prototype;

function driftSymbol(dx, dy) {
    this.parent.drift(dx, dy);
}

symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {
    this.removeAll();

    var color = data.getItemVisual(idx, 'color');

    var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);

    symbolPath.attr({
        z2: 100,
        culling: true,
        scale: getScale(symbolSize)
    });

    symbolPath.drift = driftSymbol;

    this._symbolType = symbolType;

    this.add(symbolPath);
};

symbolProto.stopSymbolAnimation = function (toLastFrame) {
    this.childAt(0).stopAnimation(toLastFrame);
};

symbolProto.getSymbolPath = function () {
    return this.childAt(0);
};

symbolProto.getScale = function () {
    return this.childAt(0).scale;
};

symbolProto.highlight = function () {
    this.childAt(0).trigger('emphasis');
};

symbolProto.downplay = function () {
    this.childAt(0).trigger('normal');
};

symbolProto.setZ = function (zlevel, z) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
};

symbolProto.setDraggable = function (draggable) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = draggable ? 'move' : 'pointer';
};

symbolProto.updateData = function (data, idx, seriesScope) {
    this.silent = false;

    var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
    var seriesModel = data.hostModel;
    var symbolSize = getSymbolSize(data, idx);
    var isInit = symbolType !== this._symbolType;

    if (isInit) {
        this._createSymbol(symbolType, data, idx, symbolSize);
    } else {
        var symbolPath = this.childAt(0);
        symbolPath.silent = false;
        graphic["updateProps"](symbolPath, {
            scale: getScale(symbolSize)
        }, seriesModel, idx);
    }

    this._updateCommon(data, idx, symbolSize, seriesScope);

    if (isInit) {
        var symbolPath = this.childAt(0);
        var fadeIn = seriesScope && seriesScope.fadeIn;

        var target = { scale: symbolPath.scale.slice() };
        fadeIn && (target.style = { opacity: symbolPath.style.opacity });

        symbolPath.scale = [0, 0];
        fadeIn && (symbolPath.style.opacity = 0);

        graphic["initProps"](symbolPath, target, seriesModel, idx);
    }

    this._seriesModel = seriesModel;
};

var normalStyleAccessPath = ['itemStyle', 'normal'];
var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];
var normalLabelAccessPath = ['label', 'normal'];
var emphasisLabelAccessPath = ['label', 'emphasis'];

symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var color = data.getItemVisual(idx, 'color');

    if (symbolPath.type !== 'image') {
        symbolPath.useStyle({
            strokeNoScale: true
        });
    }

    var itemStyle = seriesScope && seriesScope.itemStyle;
    var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
    var symbolRotate = seriesScope && seriesScope.symbolRotate;
    var symbolOffset = seriesScope && seriesScope.symbolOffset;
    var labelModel = seriesScope && seriesScope.labelModel;
    var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
    var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
    var cursorStyle = seriesScope && seriesScope.cursorStyle;

    if (!seriesScope || data.hasItemOption) {
        var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);

        itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);
        hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();

        symbolRotate = itemModel.getShallow('symbolRotate');
        symbolOffset = itemModel.getShallow('symbolOffset');

        labelModel = itemModel.getModel(normalLabelAccessPath);
        hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
        hoverAnimation = itemModel.getShallow('hoverAnimation');
        cursorStyle = itemModel.getShallow('cursor');
    } else {
        hoverItemStyle = util["k" /* extend */]({}, hoverItemStyle);
    }

    var elStyle = symbolPath.style;

    symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);

    if (symbolOffset) {
        symbolPath.attr('position', [Object(number["h" /* parsePercent */])(symbolOffset[0], symbolSize[0]), Object(number["h" /* parsePercent */])(symbolOffset[1], symbolSize[1])]);
    }

    cursorStyle && symbolPath.attr('cursor', cursorStyle);

    symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);

    symbolPath.setStyle(itemStyle);

    var opacity = data.getItemVisual(idx, 'opacity');
    if (opacity != null) {
        elStyle.opacity = opacity;
    }

    var useNameLabel = seriesScope && seriesScope.useNameLabel;
    var valueDim = !useNameLabel && findLabelValueDim(data);

    if (useNameLabel || valueDim != null) {
        graphic["setLabelStyle"](elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
            labelFetcher: seriesModel,
            labelDataIndex: idx,
            defaultText: useNameLabel ? data.getName(idx) : data.get(valueDim, idx),
            isRectText: true,
            autoColor: color
        });
    }

    symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');

    symbolPath.hoverStyle = hoverItemStyle;

    graphic["setHoverStyle"](symbolPath);

    var scale = getScale(symbolSize);

    if (hoverAnimation && seriesModel.isAnimationEnabled()) {
        var onEmphasis = function onEmphasis() {
            var ratio = scale[1] / scale[0];
            this.animateTo({
                scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
            }, 400, 'elasticOut');
        };
        var onNormal = function onNormal() {
            this.animateTo({
                scale: scale
            }, 400, 'elasticOut');
        };
        symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
    }
};

symbolProto.fadeOut = function (cb, opt) {
    var symbolPath = this.childAt(0);

    this.silent = symbolPath.silent = true;

    !(opt && opt.keepLabel) && (symbolPath.style.text = null);

    graphic["updateProps"](symbolPath, {
        style: { opacity: 0 },
        scale: [0, 0]
    }, this._seriesModel, this.dataIndex, cb);
};

util["o" /* inherits */](Symbol_SymbolClz, graphic["Group"]);

/* harmony default export */ var helper_Symbol = (Symbol_SymbolClz);
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/helper/SymbolDraw.js





function SymbolDraw(symbolCtor) {
    this.group = new graphic["Group"]();

    this._symbolCtor = symbolCtor || helper_Symbol;
}

var symbolDrawProto = SymbolDraw.prototype;

function symbolNeedsDraw(data, idx, isIgnore) {
    var point = data.getItemLayout(idx);

    return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx)) && data.getItemVisual(idx, 'symbol') !== 'none';
}

symbolDrawProto.updateData = function (data, isIgnore) {
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;

    var SymbolCtor = this._symbolCtor;

    var seriesScope = {
        itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),
        hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),
        symbolRotate: seriesModel.get('symbolRotate'),
        symbolOffset: seriesModel.get('symbolOffset'),
        hoverAnimation: seriesModel.get('hoverAnimation'),

        labelModel: seriesModel.getModel('label.normal'),
        hoverLabelModel: seriesModel.getModel('label.emphasis'),
        cursorStyle: seriesModel.get('cursor')
    };

    data.diff(oldData).add(function (newIdx) {
        var point = data.getItemLayout(newIdx);
        if (symbolNeedsDraw(data, newIdx, isIgnore)) {
            var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
            symbolEl.attr('position', point);
            data.setItemGraphicEl(newIdx, symbolEl);
            group.add(symbolEl);
        }
    }).update(function (newIdx, oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        var point = data.getItemLayout(newIdx);
        if (!symbolNeedsDraw(data, newIdx, isIgnore)) {
            group.remove(symbolEl);
            return;
        }
        if (!symbolEl) {
            symbolEl = new SymbolCtor(data, newIdx);
            symbolEl.attr('position', point);
        } else {
            symbolEl.updateData(data, newIdx, seriesScope);
            graphic["updateProps"](symbolEl, {
                position: point
            }, seriesModel);
        }

        group.add(symbolEl);

        data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function (oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && el.fadeOut(function () {
            group.remove(el);
        });
    }).execute();

    this._data = data;
};

symbolDrawProto.updateLayout = function () {
    var data = this._data;
    if (data) {
        data.eachItemGraphicEl(function (el, idx) {
            var point = data.getItemLayout(idx);
            el.attr('position', point);
        });
    }
};

symbolDrawProto.remove = function (enableAnimation) {
    var group = this.group;
    var data = this._data;
    if (data) {
        if (enableAnimation) {
            data.eachItemGraphicEl(function (el) {
                el.fadeOut(function () {
                    group.remove(el);
                });
            });
        } else {
            group.removeAll();
        }
    }
};

/* harmony default export */ var helper_SymbolDraw = (SymbolDraw);
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/line/lineAnimationDiff.js


function sign(val) {
    return val >= 0 ? 1 : -1;
}

function getStackedOnPoint(coordSys, data, idx) {
    var baseAxis = coordSys.getBaseAxis();
    var valueAxis = coordSys.getOtherAxis(baseAxis);
    var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];

    var valueDim = valueAxis.dim;
    var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;

    var stackedOnSameSign;
    var stackedOn = data.stackedOn;
    var val = data.get(valueDim, idx);

    while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {
        stackedOnSameSign = stackedOn;
        break;
    }
    var stackedData = [];
    stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
    stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;

    return coordSys.dataToPoint(stackedData);
}

function diffData(oldData, newData) {
    var diffResult = [];

    newData.diff(oldData).add(function (idx) {
        diffResult.push({ cmd: '+', idx: idx });
    }).update(function (newIdx, oldIdx) {
        diffResult.push({ cmd: '=', idx: oldIdx, idx1: newIdx });
    }).remove(function (idx) {
        diffResult.push({ cmd: '-', idx: idx });
    }).execute();

    return diffResult;
}

/* harmony default export */ var lineAnimationDiff = (function (oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys) {
    var diff = diffData(oldData, newData);

    var currPoints = [];
    var nextPoints = [];

    var currStackedPoints = [];
    var nextStackedPoints = [];

    var status = [];
    var sortedIndices = [];
    var rawIndices = [];
    var dims = newCoordSys.dimensions;
    for (var i = 0; i < diff.length; i++) {
        var diffItem = diff[i];
        var pointAdded = true;

        switch (diffItem.cmd) {
            case '=':
                var currentPt = oldData.getItemLayout(diffItem.idx);
                var nextPt = newData.getItemLayout(diffItem.idx1);

                if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
                    currentPt = nextPt.slice();
                }
                currPoints.push(currentPt);
                nextPoints.push(nextPt);

                currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
                nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);

                rawIndices.push(newData.getRawIndex(diffItem.idx1));
                break;
            case '+':
                var idx = diffItem.idx;
                currPoints.push(oldCoordSys.dataToPoint([newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)]));

                nextPoints.push(newData.getItemLayout(idx).slice());

                currStackedPoints.push(getStackedOnPoint(oldCoordSys, newData, idx));
                nextStackedPoints.push(newStackedOnPoints[idx]);

                rawIndices.push(newData.getRawIndex(idx));
                break;
            case '-':
                var idx = diffItem.idx;
                var rawIndex = oldData.getRawIndex(idx);

                if (rawIndex !== idx) {
                    currPoints.push(oldData.getItemLayout(idx));
                    nextPoints.push(newCoordSys.dataToPoint([oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)]));

                    currStackedPoints.push(oldStackedOnPoints[idx]);
                    nextStackedPoints.push(getStackedOnPoint(newCoordSys, oldData, idx));

                    rawIndices.push(rawIndex);
                } else {
                    pointAdded = false;
                }
        }

        if (pointAdded) {
            status.push(diffItem);
            sortedIndices.push(sortedIndices.length);
        }
    }

    sortedIndices.sort(function (a, b) {
        return rawIndices[a] - rawIndices[b];
    });

    var sortedCurrPoints = [];
    var sortedNextPoints = [];

    var sortedCurrStackedPoints = [];
    var sortedNextStackedPoints = [];

    var sortedStatus = [];
    for (var i = 0; i < sortedIndices.length; i++) {
        var idx = sortedIndices[i];
        sortedCurrPoints[i] = currPoints[idx];
        sortedNextPoints[i] = nextPoints[idx];

        sortedCurrStackedPoints[i] = currStackedPoints[idx];
        sortedNextStackedPoints[i] = nextStackedPoints[idx];

        sortedStatus[i] = status[idx];
    }

    return {
        current: sortedCurrPoints,
        next: sortedNextPoints,

        stackedOnCurrent: sortedCurrStackedPoints,
        stackedOnNext: sortedNextStackedPoints,

        status: sortedStatus
    };
});
// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Path.js + 7 modules
var Path = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/helper/fixClipWithShadow.js
var fixClipWithShadow = __webpack_require__(102);

// CONCATENATED MODULE: ./node_modules/echarts/src/chart/line/poly.js






var vec2Min = vector["j" /* min */];
var vec2Max = vector["i" /* max */];

var scaleAndAdd = vector["m" /* scaleAndAdd */];
var v2Copy = vector["d" /* copy */];

var poly_v = [];
var cp0 = [];
var cp1 = [];

function isPointNull(p) {
    return isNaN(p[0]) || isNaN(p[1]);
}

function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
    var prevIdx = 0;
    var idx = start;
    for (var k = 0; k < segLen; k++) {
        var p = points[idx];
        if (idx >= allLen || idx < 0) {
            break;
        }
        if (isPointNull(p)) {
            if (connectNulls) {
                idx += dir;
                continue;
            }
            break;
        }

        if (idx === start) {
            ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
            v2Copy(cp0, p);
        } else {
            if (smooth > 0) {
                var nextIdx = idx + dir;
                var nextP = points[nextIdx];
                if (connectNulls) {
                    while (nextP && isPointNull(points[nextIdx])) {
                        nextIdx += dir;
                        nextP = points[nextIdx];
                    }
                }

                var ratioNextSeg = 0.5;
                var prevP = points[prevIdx];
                var nextP = points[nextIdx];

                if (!nextP || isPointNull(nextP)) {
                    v2Copy(cp1, p);
                } else {
                    if (isPointNull(nextP) && !connectNulls) {
                        nextP = p;
                    }

                    vector["n" /* sub */](poly_v, nextP, prevP);

                    var lenPrevSeg;
                    var lenNextSeg;
                    if (smoothMonotone === 'x' || smoothMonotone === 'y') {
                        var dim = smoothMonotone === 'x' ? 0 : 1;
                        lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
                        lenNextSeg = Math.abs(p[dim] - nextP[dim]);
                    } else {
                        lenPrevSeg = vector["f" /* dist */](p, prevP);
                        lenNextSeg = vector["f" /* dist */](p, nextP);
                    }

                    ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);

                    scaleAndAdd(cp1, p, poly_v, -smooth * (1 - ratioNextSeg));
                }

                vec2Min(cp0, cp0, smoothMax);
                vec2Max(cp0, cp0, smoothMin);
                vec2Min(cp1, cp1, smoothMax);
                vec2Max(cp1, cp1, smoothMin);

                ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);

                scaleAndAdd(cp0, p, poly_v, smooth * ratioNextSeg);
            } else {
                ctx.lineTo(p[0], p[1]);
            }
        }

        prevIdx = idx;
        idx += dir;
    }

    return k;
}

function getBoundingBox(points, smoothConstraint) {
    var ptMin = [Infinity, Infinity];
    var ptMax = [-Infinity, -Infinity];
    if (smoothConstraint) {
        for (var i = 0; i < points.length; i++) {
            var pt = points[i];
            if (pt[0] < ptMin[0]) {
                ptMin[0] = pt[0];
            }
            if (pt[1] < ptMin[1]) {
                ptMin[1] = pt[1];
            }
            if (pt[0] > ptMax[0]) {
                ptMax[0] = pt[0];
            }
            if (pt[1] > ptMax[1]) {
                ptMax[1] = pt[1];
            }
        }
    }
    return {
        min: smoothConstraint ? ptMin : ptMax,
        max: smoothConstraint ? ptMax : ptMin
    };
}

var Polyline = Path["a" /* default */].extend({

    type: 'ec-polyline',

    shape: {
        points: [],

        smooth: 0,

        smoothConstraint: true,

        smoothMonotone: null,

        connectNulls: false
    },

    style: {
        fill: null,

        stroke: '#000'
    },

    brush: Object(fixClipWithShadow["a" /* default */])(Path["a" /* default */].prototype.brush),

    buildPath: function buildPath(ctx, shape) {
        var points = shape.points;

        var i = 0;
        var len = points.length;

        var result = getBoundingBox(points, shape.smoothConstraint);

        if (shape.connectNulls) {
            for (; len > 0; len--) {
                if (!isPointNull(points[len - 1])) {
                    break;
                }
            }
            for (; i < len; i++) {
                if (!isPointNull(points[i])) {
                    break;
                }
            }
        }
        while (i < len) {
            i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
        }
    }
});

var Polygon = Path["a" /* default */].extend({

    type: 'ec-polygon',

    shape: {
        points: [],

        stackedOnPoints: [],

        smooth: 0,

        stackedOnSmooth: 0,

        smoothConstraint: true,

        smoothMonotone: null,

        connectNulls: false
    },

    brush: Object(fixClipWithShadow["a" /* default */])(Path["a" /* default */].prototype.brush),

    buildPath: function buildPath(ctx, shape) {
        var points = shape.points;
        var stackedOnPoints = shape.stackedOnPoints;

        var i = 0;
        var len = points.length;
        var smoothMonotone = shape.smoothMonotone;
        var bbox = getBoundingBox(points, shape.smoothConstraint);
        var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);

        if (shape.connectNulls) {
            for (; len > 0; len--) {
                if (!isPointNull(points[len - 1])) {
                    break;
                }
            }
            for (; i < len; i++) {
                if (!isPointNull(points[i])) {
                    break;
                }
            }
        }
        while (i < len) {
            var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
            drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
            i += k + 1;

            ctx.closePath();
        }
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/line/LineView.js











function isPointsSame(points1, points2) {
    if (points1.length !== points2.length) {
        return;
    }
    for (var i = 0; i < points1.length; i++) {
        var p1 = points1[i];
        var p2 = points2[i];
        if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
            return;
        }
    }
    return true;
}

function getSmooth(smooth) {
    return typeof smooth === 'number' ? smooth : smooth ? 0.3 : 0;
}

function getAxisExtentWithGap(axis) {
    var extent = axis.getGlobalExtent();
    if (axis.onBand) {
        var halfBandWidth = axis.getBandWidth() / 2 - 1;
        var dir = extent[1] > extent[0] ? 1 : -1;
        extent[0] += dir * halfBandWidth;
        extent[1] -= dir * halfBandWidth;
    }
    return extent;
}

function LineView_sign(val) {
    return val >= 0 ? 1 : -1;
}

function getStackedOnPoints(coordSys, data) {
    var baseAxis = coordSys.getBaseAxis();
    var valueAxis = coordSys.getOtherAxis(baseAxis);

    var valueStart = 0;
    if (!baseAxis.onZero) {
        var extent = valueAxis.scale.getExtent();
        if (extent[0] > 0) {
            valueStart = extent[0];
        } else if (extent[1] < 0) {
            valueStart = extent[1];
        }
    }

    var valueDim = valueAxis.dim;

    var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;

    return data.mapArray([valueDim], function (val, idx) {
        var stackedOnSameSign;
        var stackedOn = data.stackedOn;

        while (stackedOn && LineView_sign(stackedOn.get(valueDim, idx)) === LineView_sign(val)) {
            stackedOnSameSign = stackedOn;
            break;
        }
        var stackedData = [];
        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
        stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;

        return coordSys.dataToPoint(stackedData);
    }, true);
}

function createGridClipShape(cartesian, hasAnimation, seriesModel) {
    var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));
    var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));
    var isHorizontal = cartesian.getBaseAxis().isHorizontal();

    var x = Math.min(xExtent[0], xExtent[1]);
    var y = Math.min(yExtent[0], yExtent[1]);
    var width = Math.max(xExtent[0], xExtent[1]) - x;
    var height = Math.max(yExtent[0], yExtent[1]) - y;
    var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;

    var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);
    if (isHorizontal) {
        y -= expandSize;
        height += expandSize * 2;
    } else {
        x -= expandSize;
        width += expandSize * 2;
    }

    var clipPath = new graphic["Rect"]({
        shape: {
            x: x,
            y: y,
            width: width,
            height: height
        }
    });

    if (hasAnimation) {
        clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
        graphic["initProps"](clipPath, {
            shape: {
                width: width,
                height: height
            }
        }, seriesModel);
    }

    return clipPath;
}

function createPolarClipShape(polar, hasAnimation, seriesModel) {
    var angleAxis = polar.getAngleAxis();
    var radiusAxis = polar.getRadiusAxis();

    var radiusExtent = radiusAxis.getExtent();
    var angleExtent = angleAxis.getExtent();

    var RADIAN = Math.PI / 180;

    var clipPath = new graphic["Sector"]({
        shape: {
            cx: polar.cx,
            cy: polar.cy,
            r0: radiusExtent[0],
            r: radiusExtent[1],
            startAngle: -angleExtent[0] * RADIAN,
            endAngle: -angleExtent[1] * RADIAN,
            clockwise: angleAxis.inverse
        }
    });

    if (hasAnimation) {
        clipPath.shape.endAngle = -angleExtent[0] * RADIAN;
        graphic["initProps"](clipPath, {
            shape: {
                endAngle: -angleExtent[1] * RADIAN
            }
        }, seriesModel);
    }

    return clipPath;
}

function createClipShape(coordSys, hasAnimation, seriesModel) {
    return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);
}

function turnPointsIntoStep(points, coordSys, stepTurnAt) {
    var baseAxis = coordSys.getBaseAxis();
    var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;

    var stepPoints = [];
    for (var i = 0; i < points.length - 1; i++) {
        var nextPt = points[i + 1];
        var pt = points[i];
        stepPoints.push(pt);

        var stepPt = [];
        switch (stepTurnAt) {
            case 'end':
                stepPt[baseIndex] = nextPt[baseIndex];
                stepPt[1 - baseIndex] = pt[1 - baseIndex];

                stepPoints.push(stepPt);
                break;
            case 'middle':
                var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
                var stepPt2 = [];
                stepPt[baseIndex] = stepPt2[baseIndex] = middle;
                stepPt[1 - baseIndex] = pt[1 - baseIndex];
                stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
                stepPoints.push(stepPt);
                stepPoints.push(stepPt2);
                break;
            default:
                stepPt[baseIndex] = pt[baseIndex];
                stepPt[1 - baseIndex] = nextPt[1 - baseIndex];

                stepPoints.push(stepPt);
        }
    }

    points[i] && stepPoints.push(points[i]);
    return stepPoints;
}

function getVisualGradient(data, coordSys) {
    var visualMetaList = data.getVisual('visualMeta');
    if (!visualMetaList || !visualMetaList.length || !data.count()) {
        return;
    }

    var visualMeta;
    for (var i = visualMetaList.length - 1; i >= 0; i--) {
        if (visualMetaList[i].dimension < 2) {
            visualMeta = visualMetaList[i];
            break;
        }
    }
    if (!visualMeta || coordSys.type !== 'cartesian2d') {
        if (false) {
            console.warn('Visual map on line style only support x or y dimension.');
        }
        return;
    }

    var dimension = visualMeta.dimension;
    var dimName = data.dimensions[dimension];
    var axis = coordSys.getAxis(dimName);

    var colorStops = util["v" /* map */](visualMeta.stops, function (stop) {
        return {
            coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
            color: stop.color
        };
    });
    var stopLen = colorStops.length;
    var outerColors = visualMeta.outerColors.slice();

    if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
        colorStops.reverse();
        outerColors.reverse();
    }

    var tinyExtent = 10;
    var minCoord = colorStops[0].coord - tinyExtent;
    var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
    var coordSpan = maxCoord - minCoord;

    if (coordSpan < 1e-3) {
        return 'transparent';
    }

    util["i" /* each */](colorStops, function (stop) {
        stop.offset = (stop.coord - minCoord) / coordSpan;
    });
    colorStops.push({
        offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
        color: outerColors[1] || 'transparent'
    });
    colorStops.unshift({
        offset: stopLen ? colorStops[0].offset : 0.5,
        color: outerColors[0] || 'transparent'
    });

    var gradient = new graphic["LinearGradient"](0, 0, 0, 0, colorStops, true);
    gradient[dimName] = minCoord;
    gradient[dimName + '2'] = maxCoord;

    return gradient;
}

/* harmony default export */ var LineView = (view_Chart.extend({

    type: 'line',

    init: function init() {
        var lineGroup = new graphic["Group"]();

        var symbolDraw = new helper_SymbolDraw();
        this.group.add(symbolDraw.group);

        this._symbolDraw = symbolDraw;
        this._lineGroup = lineGroup;
    },

    render: function render(seriesModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var group = this.group;
        var data = seriesModel.getData();
        var lineStyleModel = seriesModel.getModel('lineStyle.normal');
        var areaStyleModel = seriesModel.getModel('areaStyle.normal');

        var points = data.mapArray(data.getItemLayout, true);

        var isCoordSysPolar = coordSys.type === 'polar';
        var prevCoordSys = this._coordSys;

        var symbolDraw = this._symbolDraw;
        var polyline = this._polyline;
        var polygon = this._polygon;

        var lineGroup = this._lineGroup;

        var hasAnimation = seriesModel.get('animation');

        var isAreaChart = !areaStyleModel.isEmpty();
        var stackedOnPoints = getStackedOnPoints(coordSys, data);

        var showSymbol = seriesModel.get('showSymbol');

        var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys);

        var oldData = this._data;
        oldData && oldData.eachItemGraphicEl(function (el, idx) {
            if (el.__temp) {
                group.remove(el);
                oldData.setItemGraphicEl(idx, null);
            }
        });

        if (!showSymbol) {
            symbolDraw.remove();
        }

        group.add(lineGroup);

        var step = !isCoordSysPolar && seriesModel.get('step');

        if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
            showSymbol && symbolDraw.updateData(data, isSymbolIgnore);

            if (step) {
                points = turnPointsIntoStep(points, coordSys, step);
                stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
            }

            polyline = this._newPolyline(points, coordSys, hasAnimation);
            if (isAreaChart) {
                polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
            }
            lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));
        } else {
            if (isAreaChart && !polygon) {
                polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
            } else if (polygon && !isAreaChart) {
                lineGroup.remove(polygon);
                polygon = this._polygon = null;
            }

            lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));

            showSymbol && symbolDraw.updateData(data, isSymbolIgnore);

            data.eachItemGraphicEl(function (el) {
                el.stopAnimation(true);
            });

            if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
                if (hasAnimation) {
                    this._updateAnimation(data, stackedOnPoints, coordSys, api, step);
                } else {
                    if (step) {
                        points = turnPointsIntoStep(points, coordSys, step);
                        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
                    }

                    polyline.setShape({
                        points: points
                    });
                    polygon && polygon.setShape({
                        points: points,
                        stackedOnPoints: stackedOnPoints
                    });
                }
            }
        }

        var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');

        polyline.useStyle(util["h" /* defaults */](lineStyleModel.getLineStyle(), {
            fill: 'none',
            stroke: visualColor,
            lineJoin: 'bevel'
        }));

        var smooth = seriesModel.get('smooth');
        smooth = getSmooth(seriesModel.get('smooth'));
        polyline.setShape({
            smooth: smooth,
            smoothMonotone: seriesModel.get('smoothMonotone'),
            connectNulls: seriesModel.get('connectNulls')
        });

        if (polygon) {
            var stackedOn = data.stackedOn;
            var stackedOnSmooth = 0;

            polygon.useStyle(util["h" /* defaults */](areaStyleModel.getAreaStyle(), {
                fill: visualColor,
                opacity: 0.7,
                lineJoin: 'bevel'
            }));

            if (stackedOn) {
                var stackedOnSeries = stackedOn.hostModel;
                stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
            }

            polygon.setShape({
                smooth: smooth,
                stackedOnSmooth: stackedOnSmooth,
                smoothMonotone: seriesModel.get('smoothMonotone'),
                connectNulls: seriesModel.get('connectNulls')
            });
        }

        this._data = data;

        this._coordSys = coordSys;
        this._stackedOnPoints = stackedOnPoints;
        this._points = points;
        this._step = step;
    },

    dispose: function dispose() {},

    highlight: function highlight(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = util_model["p" /* queryDataIndex */](data, payload);

        if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
            var symbol = data.getItemGraphicEl(dataIndex);
            if (!symbol) {
                var pt = data.getItemLayout(dataIndex);
                if (!pt) {
                    return;
                }
                symbol = new helper_Symbol(data, dataIndex);
                symbol.position = pt;
                symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
                symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
                symbol.__temp = true;
                data.setItemGraphicEl(dataIndex, symbol);

                symbol.stopSymbolAnimation(true);

                this.group.add(symbol);
            }
            symbol.highlight();
        } else {
            view_Chart.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
        }
    },

    downplay: function downplay(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = util_model["p" /* queryDataIndex */](data, payload);
        if (dataIndex != null && dataIndex >= 0) {
            var symbol = data.getItemGraphicEl(dataIndex);
            if (symbol) {
                if (symbol.__temp) {
                    data.setItemGraphicEl(dataIndex, null);
                    this.group.remove(symbol);
                } else {
                    symbol.downplay();
                }
            }
        } else {
            view_Chart.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
        }
    },

    _newPolyline: function _newPolyline(points) {
        var polyline = this._polyline;

        if (polyline) {
            this._lineGroup.remove(polyline);
        }

        polyline = new Polyline({
            shape: {
                points: points
            },
            silent: true,
            z2: 10
        });

        this._lineGroup.add(polyline);

        this._polyline = polyline;

        return polyline;
    },

    _newPolygon: function _newPolygon(points, stackedOnPoints) {
        var polygon = this._polygon;

        if (polygon) {
            this._lineGroup.remove(polygon);
        }

        polygon = new Polygon({
            shape: {
                points: points,
                stackedOnPoints: stackedOnPoints
            },
            silent: true
        });

        this._lineGroup.add(polygon);

        this._polygon = polygon;
        return polygon;
    },

    _getSymbolIgnoreFunc: function _getSymbolIgnoreFunc(data, coordSys) {
        var categoryAxis = coordSys.getAxesByScale('ordinal')[0];

        if (categoryAxis && categoryAxis.isLabelIgnored) {
            return util["c" /* bind */](categoryAxis.isLabelIgnored, categoryAxis);
        }
    },

    _updateAnimation: function _updateAnimation(data, stackedOnPoints, coordSys, api, step) {
        var polyline = this._polyline;
        var polygon = this._polygon;
        var seriesModel = data.hostModel;

        var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys);

        var current = diff.current;
        var stackedOnCurrent = diff.stackedOnCurrent;
        var next = diff.next;
        var stackedOnNext = diff.stackedOnNext;
        if (step) {
            current = turnPointsIntoStep(diff.current, coordSys, step);
            stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
            next = turnPointsIntoStep(diff.next, coordSys, step);
            stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
        }

        polyline.shape.__points = diff.current;
        polyline.shape.points = current;

        graphic["updateProps"](polyline, {
            shape: {
                points: next
            }
        }, seriesModel);

        if (polygon) {
            polygon.setShape({
                points: current,
                stackedOnPoints: stackedOnCurrent
            });
            graphic["updateProps"](polygon, {
                shape: {
                    points: next,
                    stackedOnPoints: stackedOnNext
                }
            }, seriesModel);
        }

        var updatedDataInfo = [];
        var diffStatus = diff.status;

        for (var i = 0; i < diffStatus.length; i++) {
            var cmd = diffStatus[i].cmd;
            if (cmd === '=') {
                var el = data.getItemGraphicEl(diffStatus[i].idx1);
                if (el) {
                    updatedDataInfo.push({
                        el: el,
                        ptIdx: i });
                }
            }
        }

        if (polyline.animators && polyline.animators.length) {
            polyline.animators[0].during(function () {
                for (var i = 0; i < updatedDataInfo.length; i++) {
                    var el = updatedDataInfo[i].el;
                    el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);
                }
            });
        }
    },

    remove: function remove(ecModel) {
        var group = this.group;
        var oldData = this._data;
        this._lineGroup.removeAll();
        this._symbolDraw.remove(true);

        oldData && oldData.eachItemGraphicEl(function (el, idx) {
            if (el.__temp) {
                group.remove(el);
                oldData.setItemGraphicEl(idx, null);
            }
        });

        this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
    }
}));
// CONCATENATED MODULE: ./node_modules/echarts/src/visual/symbol.js

/* harmony default export */ var visual_symbol = (function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {
    ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {
        var data = seriesModel.getData();

        var symbolType = seriesModel.get('symbol') || defaultSymbolType;
        var symbolSize = seriesModel.get('symbolSize');

        data.setVisual({
            legendSymbol: legendSymbol || symbolType,
            symbol: symbolType,
            symbolSize: symbolSize
        });

        if (!ecModel.isSeriesFiltered(seriesModel)) {
            if (typeof symbolSize === 'function') {
                data.each(function (idx) {
                    var rawValue = seriesModel.getRawValue(idx);

                    var params = seriesModel.getDataParams(idx);
                    data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
                });
            }
            data.each(function (idx) {
                var itemModel = data.getItemModel(idx);
                var itemSymbolType = itemModel.getShallow('symbol', true);
                var itemSymbolSize = itemModel.getShallow('symbolSize', true);

                if (itemSymbolType != null) {
                    data.setItemVisual(idx, 'symbol', itemSymbolType);
                }
                if (itemSymbolSize != null) {
                    data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
                }
            });
        }
    });
});
// CONCATENATED MODULE: ./node_modules/echarts/src/layout/points.js

/* harmony default export */ var layout_points = (function (seriesType, ecModel) {
    ecModel.eachSeriesByType(seriesType, function (seriesModel) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;

        if (!coordSys) {
            return;
        }

        var dims = [];
        var coordDims = coordSys.dimensions;
        for (var i = 0; i < coordDims.length; i++) {
            dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]);
        }

        if (dims.length === 1) {
            data.each(dims[0], function (x, idx) {
                data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));
            });
        } else if (dims.length === 2) {
            data.each(dims, function (x, y, idx) {
                data.setItemLayout(idx, isNaN(x) || isNaN(y) ? [NaN, NaN] : coordSys.dataToPoint([x, y]));
            }, true);
        }
    });
});
// CONCATENATED MODULE: ./node_modules/echarts/src/processor/dataSample.js

var samplers = {
    average: function average(frame) {
        var sum = 0;
        var count = 0;
        for (var i = 0; i < frame.length; i++) {
            if (!isNaN(frame[i])) {
                sum += frame[i];
                count++;
            }
        }

        return count === 0 ? NaN : sum / count;
    },
    sum: function sum(frame) {
        var sum = 0;
        for (var i = 0; i < frame.length; i++) {
            sum += frame[i] || 0;
        }
        return sum;
    },
    max: function max(frame) {
        var max = -Infinity;
        for (var i = 0; i < frame.length; i++) {
            frame[i] > max && (max = frame[i]);
        }
        return max;
    },
    min: function min(frame) {
        var min = Infinity;
        for (var i = 0; i < frame.length; i++) {
            frame[i] < min && (min = frame[i]);
        }
        return min;
    },

    nearest: function nearest(frame) {
        return frame[0];
    }
};

var indexSampler = function indexSampler(frame, value) {
    return Math.round(frame.length / 2);
};

/* harmony default export */ var dataSample = (function (seriesType, ecModel, api) {
    ecModel.eachSeriesByType(seriesType, function (seriesModel) {
        var data = seriesModel.getData();
        var sampling = seriesModel.get('sampling');
        var coordSys = seriesModel.coordinateSystem;

        if (coordSys.type === 'cartesian2d' && sampling) {
            var baseAxis = coordSys.getBaseAxis();
            var valueAxis = coordSys.getOtherAxis(baseAxis);
            var extent = baseAxis.getExtent();

            var size = extent[1] - extent[0];
            var rate = Math.round(data.count() / size);
            if (rate > 1) {
                var sampler;
                if (typeof sampling === 'string') {
                    sampler = samplers[sampling];
                } else if (typeof sampling === 'function') {
                    sampler = sampling;
                }
                if (sampler) {
                    data = data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler);
                    seriesModel.setData(data);
                }
            }
        }
    }, this);
});
// CONCATENATED MODULE: ./node_modules/echarts/src/chart/line.js











registerVisual(util["g" /* curry */](visual_symbol, 'line', 'circle', 'line'));
registerLayout(util["g" /* curry */](layout_points, 'line'));

registerProcessor(PRIORITY.PROCESSOR.STATISTIC, util["g" /* curry */](dataSample, 'line'));
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer/findPointFromSeries.js



/* harmony default export */ var findPointFromSeries = (function (finder, ecModel) {
    var point = [];
    var seriesIndex = finder.seriesIndex;
    var seriesModel;
    if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
        return { point: [] };
    }

    var data = seriesModel.getData();
    var dataIndex = util_model["p" /* queryDataIndex */](data, finder);
    if (dataIndex == null || util["p" /* isArray */](dataIndex)) {
        return { point: [] };
    }

    var el = data.getItemGraphicEl(dataIndex);
    var coordSys = seriesModel.coordinateSystem;

    if (seriesModel.getTooltipPosition) {
        point = seriesModel.getTooltipPosition(dataIndex) || [];
    } else if (coordSys && coordSys.dataToPoint) {
        point = coordSys.dataToPoint(data.getValues(util["v" /* map */](coordSys.dimensions, function (dim) {
            return seriesModel.coordDimToDataDim(dim)[0];
        }), dataIndex, true)) || [];
    } else if (el) {
        var rect = el.getBoundingRect().clone();
        rect.applyTransform(el.transform);
        point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    }

    return { point: point, el: el };
});
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer/axisTrigger.js





var axisTrigger_each = util["i" /* each */];
var axisTrigger_curry = util["g" /* curry */];
var axisTrigger_get = util_model["j" /* makeGetter */]();

/* harmony default export */ var axisTrigger = (function (payload, ecModel, api) {
    var currTrigger = payload.currTrigger;
    var point = [payload.x, payload.y];
    var finder = payload;
    var dispatchAction = payload.dispatchAction || util["c" /* bind */](api.dispatchAction, api);
    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

    if (!coordSysAxesInfo) {
        return;
    }

    if (illegalPoint(point)) {
        point = findPointFromSeries({
            seriesIndex: finder.seriesIndex,

            dataIndex: finder.dataIndex
        }, ecModel).point;
    }
    var isIllegalPoint = illegalPoint(point);

    var inputAxesInfo = finder.axesInfo;

    var axesInfo = coordSysAxesInfo.axesInfo;
    var shouldHide = currTrigger === 'leave' || illegalPoint(point);
    var outputFinder = {};

    var showValueMap = {};
    var dataByCoordSys = { list: [], map: {} };
    var updaters = {
        showPointer: axisTrigger_curry(showPointer, showValueMap),
        showTooltip: axisTrigger_curry(showTooltip, dataByCoordSys)
    };

    axisTrigger_each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
        var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);

        axisTrigger_each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
            var axis = axisInfo.axis;
            var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);

            if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
                var val = inputAxisInfo && inputAxisInfo.value;
                if (val == null && !isIllegalPoint) {
                    val = axis.pointToData(point);
                }
                val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
            }
        });
    });

    var linkTriggers = {};
    axisTrigger_each(axesInfo, function (tarAxisInfo, tarKey) {
        var linkGroup = tarAxisInfo.linkGroup;

        if (linkGroup && !showValueMap[tarKey]) {
            axisTrigger_each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
                var srcValItem = showValueMap[srcKey];

                if (srcAxisInfo !== tarAxisInfo && srcValItem) {
                    var val = srcValItem.value;
                    linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
                    linkTriggers[tarAxisInfo.key] = val;
                }
            });
        }
    });
    axisTrigger_each(linkTriggers, function (val, tarKey) {
        processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
    });

    updateModelActually(showValueMap, axesInfo, outputFinder);
    dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
    dispatchHighDownActually(axesInfo, dispatchAction, api);

    return outputFinder;
});

function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
    var axis = axisInfo.axis;

    if (axis.scale.isBlank() || !axis.containData(newValue)) {
        return;
    }

    if (!axisInfo.involveSeries) {
        updaters.showPointer(axisInfo, newValue);
        return;
    }

    var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
    var payloadBatch = payloadInfo.payloadBatch;
    var snapToValue = payloadInfo.snapToValue;

    if (payloadBatch[0] && outputFinder.seriesIndex == null) {
        util["k" /* extend */](outputFinder, payloadBatch[0]);
    }

    if (!dontSnap && axisInfo.snap) {
        if (axis.containData(snapToValue) && snapToValue != null) {
            newValue = snapToValue;
        }
    }

    updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);

    updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}

function buildPayloadsBySeries(value, axisInfo) {
    var axis = axisInfo.axis;
    var dim = axis.dim;
    var snapToValue = value;
    var payloadBatch = [];
    var minDist = Number.MAX_VALUE;
    var minDiff = -1;

    axisTrigger_each(axisInfo.seriesModels, function (series, idx) {
        var dataDim = series.coordDimToDataDim(dim);
        var seriesNestestValue;
        var dataIndices;

        if (series.getAxisTooltipData) {
            var result = series.getAxisTooltipData(dataDim, value, axis);
            dataIndices = result.dataIndices;
            seriesNestestValue = result.nestestValue;
        } else {
            dataIndices = series.getData().indicesOfNearest(dataDim[0], value, false, axis.type === 'category' ? 0.5 : null);
            if (!dataIndices.length) {
                return;
            }
            seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
        }

        if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
            return;
        }

        var diff = value - seriesNestestValue;
        var dist = Math.abs(diff);

        if (dist <= minDist) {
            if (dist < minDist || diff >= 0 && minDiff < 0) {
                minDist = dist;
                minDiff = diff;
                snapToValue = seriesNestestValue;
                payloadBatch.length = 0;
            }
            axisTrigger_each(dataIndices, function (dataIndex) {
                payloadBatch.push({
                    seriesIndex: series.seriesIndex,
                    dataIndexInside: dataIndex,
                    dataIndex: series.getData().getRawIndex(dataIndex)
                });
            });
        }
    });

    return {
        payloadBatch: payloadBatch,
        snapToValue: snapToValue
    };
}

function showPointer(showValueMap, axisInfo, value, payloadBatch) {
    showValueMap[axisInfo.key] = { value: value, payloadBatch: payloadBatch };
}

function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
    var payloadBatch = payloadInfo.payloadBatch;
    var axis = axisInfo.axis;
    var axisModel = axis.model;
    var axisPointerModel = axisInfo.axisPointerModel;

    if (!axisInfo.triggerTooltip || !payloadBatch.length) {
        return;
    }

    var coordSysModel = axisInfo.coordSys.model;
    var coordSysKey = makeKey(coordSysModel);
    var coordSysItem = dataByCoordSys.map[coordSysKey];
    if (!coordSysItem) {
        coordSysItem = dataByCoordSys.map[coordSysKey] = {
            coordSysId: coordSysModel.id,
            coordSysIndex: coordSysModel.componentIndex,
            coordSysType: coordSysModel.type,
            coordSysMainType: coordSysModel.mainType,
            dataByAxis: []
        };
        dataByCoordSys.list.push(coordSysItem);
    }

    coordSysItem.dataByAxis.push({
        axisDim: axis.dim,
        axisIndex: axisModel.componentIndex,
        axisType: axisModel.type,
        axisId: axisModel.id,
        value: value,

        valueLabelOpt: {
            precision: axisPointerModel.get('label.precision'),
            formatter: axisPointerModel.get('label.formatter')
        },
        seriesDataIndices: payloadBatch.slice()
    });
}

function updateModelActually(showValueMap, axesInfo, outputFinder) {
    var outputAxesInfo = outputFinder.axesInfo = [];

    axisTrigger_each(axesInfo, function (axisInfo, key) {
        var option = axisInfo.axisPointerModel.option;
        var valItem = showValueMap[key];

        if (valItem) {
            !axisInfo.useHandle && (option.status = 'show');
            option.value = valItem.value;

            option.seriesDataIndices = (valItem.payloadBatch || []).slice();
        } else {
                !axisInfo.useHandle && (option.status = 'hide');
            }

        option.status === 'show' && outputAxesInfo.push({
            axisDim: axisInfo.axis.dim,
            axisIndex: axisInfo.axis.model.componentIndex,
            value: option.value
        });
    });
}

function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
    if (illegalPoint(point) || !dataByCoordSys.list.length) {
        dispatchAction({ type: 'hideTip' });
        return;
    }

    var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};

    dispatchAction({
        type: 'showTip',
        escapeConnect: true,
        x: point[0],
        y: point[1],
        tooltipOption: payload.tooltipOption,
        position: payload.position,
        dataIndexInside: sampleItem.dataIndexInside,
        dataIndex: sampleItem.dataIndex,
        seriesIndex: sampleItem.seriesIndex,
        dataByCoordSys: dataByCoordSys.list
    });
}

function dispatchHighDownActually(axesInfo, dispatchAction, api) {

    var zr = api.getZr();
    var highDownKey = 'axisPointerLastHighlights';
    var lastHighlights = axisTrigger_get(zr)[highDownKey] || {};
    var newHighlights = axisTrigger_get(zr)[highDownKey] = {};

    axisTrigger_each(axesInfo, function (axisInfo, key) {
        var option = axisInfo.axisPointerModel.option;
        option.status === 'show' && axisTrigger_each(option.seriesDataIndices, function (batchItem) {
            var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
            newHighlights[key] = batchItem;
        });
    });

    var toHighlight = [];
    var toDownplay = [];
    util["i" /* each */](lastHighlights, function (batchItem, key) {
        !newHighlights[key] && toDownplay.push(batchItem);
    });
    util["i" /* each */](newHighlights, function (batchItem, key) {
        !lastHighlights[key] && toHighlight.push(batchItem);
    });

    toDownplay.length && api.dispatchAction({
        type: 'downplay', escapeConnect: true, batch: toDownplay
    });
    toHighlight.length && api.dispatchAction({
        type: 'highlight', escapeConnect: true, batch: toHighlight
    });
}

function findInputAxisInfo(inputAxesInfo, axisInfo) {
    for (var i = 0; i < (inputAxesInfo || []).length; i++) {
        var inputAxisInfo = inputAxesInfo[i];
        if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
            return inputAxisInfo;
        }
    }
}

function makeMapperParam(axisInfo) {
    var axisModel = axisInfo.axis.model;
    var item = {};
    var dim = item.axisDim = axisInfo.axis.dim;
    item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
    item.axisName = item[dim + 'AxisName'] = axisModel.name;
    item.axisId = item[dim + 'AxisId'] = axisModel.id;
    return item;
}

function illegalPoint(point) {
    return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer/AxisPointerModel.js


var AxisPointerModel = extendComponentModel({

    type: 'axisPointer',

    coordSysAxesInfo: null,

    defaultOption: {
        show: 'auto',

        triggerOn: null,

        zlevel: 0,
        z: 50,

        type: 'line',

        snap: false,
        triggerTooltip: true,

        value: null,
        status: null,
        link: [],

        animation: null,
        animationDurationUpdate: 200,

        lineStyle: {
            color: '#aaa',
            width: 1,
            type: 'solid'
        },

        shadowStyle: {
            color: 'rgba(150,150,150,0.3)'
        },

        label: {
            show: true,
            formatter: null,
            precision: 'auto',
            margin: 3,
            color: '#fff',
            padding: [5, 7, 5, 7],
            backgroundColor: 'auto',
            borderColor: null,
            borderWidth: 0,
            shadowBlur: 3,
            shadowColor: '#aaa'
        },

        handle: {
            show: false,
            icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
            size: 45,

            margin: 50,

            color: '#333',
            shadowBlur: 3,
            shadowColor: '#aaa',
            shadowOffsetX: 0,
            shadowOffsetY: 2,

            throttle: 40
        }
    }

});

/* harmony default export */ var axisPointer_AxisPointerModel = (AxisPointerModel);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer/globalListener.js




var globalListener_get = util_model["j" /* makeGetter */]();
var globalListener_each = util["i" /* each */];

function register(key, api, handler) {
    if (core_env["a" /* default */].node) {
        return;
    }

    var zr = api.getZr();
    globalListener_get(zr).records || (globalListener_get(zr).records = {});

    initGlobalListeners(zr, api);

    var record = globalListener_get(zr).records[key] || (globalListener_get(zr).records[key] = {});
    record.handler = handler;
}

function initGlobalListeners(zr, api) {
    if (globalListener_get(zr).initialized) {
        return;
    }

    globalListener_get(zr).initialized = true;

    useHandler('click', util["g" /* curry */](doEnter, 'click'));
    useHandler('mousemove', util["g" /* curry */](doEnter, 'mousemove'));

    useHandler('globalout', onLeave);

    function useHandler(eventType, cb) {
        zr.on(eventType, function (e) {
            var dis = makeDispatchAction(api);

            globalListener_each(globalListener_get(zr).records, function (record) {
                record && cb(record, e, dis.dispatchAction);
            });

            dispatchTooltipFinally(dis.pendings, api);
        });
    }
}

function dispatchTooltipFinally(pendings, api) {
    var showLen = pendings.showTip.length;
    var hideLen = pendings.hideTip.length;

    var actuallyPayload;
    if (showLen) {
        actuallyPayload = pendings.showTip[showLen - 1];
    } else if (hideLen) {
        actuallyPayload = pendings.hideTip[hideLen - 1];
    }
    if (actuallyPayload) {
        actuallyPayload.dispatchAction = null;
        api.dispatchAction(actuallyPayload);
    }
}

function onLeave(record, e, dispatchAction) {
    record.handler('leave', null, dispatchAction);
}

function doEnter(currTrigger, record, e, dispatchAction) {
    record.handler(currTrigger, e, dispatchAction);
}

function makeDispatchAction(api) {
    var pendings = {
        showTip: [],
        hideTip: []
    };

    var dispatchAction = function dispatchAction(payload) {
        var pendingList = pendings[payload.type];
        if (pendingList) {
            pendingList.push(payload);
        } else {
            payload.dispatchAction = dispatchAction;
            api.dispatchAction(payload);
        }
    };

    return {
        dispatchAction: dispatchAction,
        pendings: pendings
    };
}

function unregister(key, api) {
    if (core_env["a" /* default */].node) {
        return;
    }
    var zr = api.getZr();
    var record = (globalListener_get(zr).records || {})[key];
    if (record) {
        globalListener_get(zr).records[key] = null;
    }
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer/AxisPointerView.js



var AxisPointerView = extendComponentView({

    type: 'axisPointer',

    render: function render(globalAxisPointerModel, ecModel, api) {
        var globalTooltipModel = ecModel.getComponent('tooltip');
        var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click';

        register('axisPointer', api, function (currTrigger, e, dispatchAction) {
            if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
                dispatchAction({
                    type: 'updateAxisPointer',
                    currTrigger: currTrigger,
                    x: e && e.offsetX,
                    y: e && e.offsetY
                });
            }
        });
    },

    remove: function remove(ecModel, api) {
        unregister(api.getZr(), 'axisPointer');
        AxisPointerView.superApply(this._model, 'remove', arguments);
    },

    dispose: function dispose(ecModel, api) {
        unregister('axisPointer', api);
        AxisPointerView.superApply(this._model, 'dispose', arguments);
    }

});

/* harmony default export */ var axisPointer_AxisPointerView = (AxisPointerView);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer/BaseAxisPointer.js








var BaseAxisPointer_get = util_model["j" /* makeGetter */]();
var BaseAxisPointer_clone = util["d" /* clone */];
var bind = util["c" /* bind */];

function BaseAxisPointer() {}

BaseAxisPointer.prototype = {
    _group: null,

    _lastGraphicKey: null,

    _handle: null,

    _dragging: false,

    _lastValue: null,

    _lastStatus: null,

    _payloadInfo: null,

    animationThreshold: 15,

    render: function render(axisModel, axisPointerModel, api, forceRender) {
        var value = axisPointerModel.get('value');
        var status = axisPointerModel.get('status');

        this._axisModel = axisModel;
        this._axisPointerModel = axisPointerModel;
        this._api = api;

        if (!forceRender && this._lastValue === value && this._lastStatus === status) {
            return;
        }
        this._lastValue = value;
        this._lastStatus = status;

        var group = this._group;
        var handle = this._handle;

        if (!status || status === 'hide') {
            group && group.hide();
            handle && handle.hide();
            return;
        }
        group && group.show();
        handle && handle.show();

        var elOption = {};
        this.makeElOption(elOption, value, axisModel, axisPointerModel, api);

        var graphicKey = elOption.graphicKey;
        if (graphicKey !== this._lastGraphicKey) {
            this.clear(api);
        }
        this._lastGraphicKey = graphicKey;

        var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);

        if (!group) {
            group = this._group = new graphic["Group"]();
            this.createPointerEl(group, elOption, axisModel, axisPointerModel);
            this.createLabelEl(group, elOption, axisModel, axisPointerModel);
            api.getZr().add(group);
        } else {
            var doUpdateProps = util["g" /* curry */](updateProps, axisPointerModel, moveAnimation);
            this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
            this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
        }

        updateMandatoryProps(group, axisPointerModel, true);

        this._renderHandle(value);
    },

    remove: function remove(api) {
        this.clear(api);
    },

    dispose: function dispose(api) {
        this.clear(api);
    },

    determineAnimation: function determineAnimation(axisModel, axisPointerModel) {
        var animation = axisPointerModel.get('animation');
        var axis = axisModel.axis;
        var isCategoryAxis = axis.type === 'category';
        var useSnap = axisPointerModel.get('snap');

        if (!useSnap && !isCategoryAxis) {
            return false;
        }

        if (animation === 'auto' || animation == null) {
            var animationThreshold = this.animationThreshold;
            if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
                return true;
            }

            if (useSnap) {
                var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
                var axisExtent = axis.getExtent();

                return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
            }

            return false;
        }

        return animation === true;
    },

    makeElOption: function makeElOption(elOption, value, axisModel, axisPointerModel, api) {},

    createPointerEl: function createPointerEl(group, elOption, axisModel, axisPointerModel) {
        var pointerOption = elOption.pointer;
        if (pointerOption) {
            var pointerEl = BaseAxisPointer_get(group).pointerEl = new graphic[pointerOption.type](BaseAxisPointer_clone(elOption.pointer));
            group.add(pointerEl);
        }
    },

    createLabelEl: function createLabelEl(group, elOption, axisModel, axisPointerModel) {
        if (elOption.label) {
            var labelEl = BaseAxisPointer_get(group).labelEl = new graphic["Rect"](BaseAxisPointer_clone(elOption.label));

            group.add(labelEl);
            updateLabelShowHide(labelEl, axisPointerModel);
        }
    },

    updatePointerEl: function updatePointerEl(group, elOption, updateProps) {
        var pointerEl = BaseAxisPointer_get(group).pointerEl;
        if (pointerEl) {
            pointerEl.setStyle(elOption.pointer.style);
            updateProps(pointerEl, { shape: elOption.pointer.shape });
        }
    },

    updateLabelEl: function updateLabelEl(group, elOption, updateProps, axisPointerModel) {
        var labelEl = BaseAxisPointer_get(group).labelEl;
        if (labelEl) {
            labelEl.setStyle(elOption.label.style);
            updateProps(labelEl, {
                shape: elOption.label.shape,
                position: elOption.label.position
            });

            updateLabelShowHide(labelEl, axisPointerModel);
        }
    },

    _renderHandle: function _renderHandle(value) {
        if (this._dragging || !this.updateHandleTransform) {
            return;
        }

        var axisPointerModel = this._axisPointerModel;
        var zr = this._api.getZr();
        var handle = this._handle;
        var handleModel = axisPointerModel.getModel('handle');

        var status = axisPointerModel.get('status');
        if (!handleModel.get('show') || !status || status === 'hide') {
            handle && zr.remove(handle);
            this._handle = null;
            return;
        }

        var isInit;
        if (!this._handle) {
            isInit = true;
            handle = this._handle = graphic["createIcon"](handleModel.get('icon'), {
                cursor: 'move',
                draggable: true,
                onmousemove: function onmousemove(e) {
                    stop(e.event);
                },
                onmousedown: bind(this._onHandleDragMove, this, 0, 0),
                drift: bind(this._onHandleDragMove, this),
                ondragend: bind(this._onHandleDragEnd, this)
            });
            zr.add(handle);
        }

        updateMandatoryProps(handle, axisPointerModel, false);

        var includeStyles = ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
        handle.setStyle(handleModel.getItemStyle(null, includeStyles));

        var handleSize = handleModel.get('size');
        if (!util["p" /* isArray */](handleSize)) {
            handleSize = [handleSize, handleSize];
        }
        handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);

        createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');

        this._moveHandleToValue(value, isInit);
    },

    _moveHandleToValue: function _moveHandleToValue(value, isInit) {
        updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
    },

    _onHandleDragMove: function _onHandleDragMove(dx, dy) {
        var handle = this._handle;
        if (!handle) {
            return;
        }

        this._dragging = true;

        var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
        this._payloadInfo = trans;

        handle.stopAnimation();
        handle.attr(getHandleTransProps(trans));
        BaseAxisPointer_get(handle).lastProp = null;

        this._doDispatchAxisPointer();
    },

    _doDispatchAxisPointer: function _doDispatchAxisPointer() {
        var handle = this._handle;
        if (!handle) {
            return;
        }

        var payloadInfo = this._payloadInfo;
        var axisModel = this._axisModel;
        this._api.dispatchAction({
            type: 'updateAxisPointer',
            x: payloadInfo.cursorPoint[0],
            y: payloadInfo.cursorPoint[1],
            tooltipOption: payloadInfo.tooltipOption,
            axesInfo: [{
                axisDim: axisModel.axis.dim,
                axisIndex: axisModel.componentIndex
            }]
        });
    },

    _onHandleDragEnd: function _onHandleDragEnd(moveAnimation) {
        this._dragging = false;
        var handle = this._handle;
        if (!handle) {
            return;
        }

        var value = this._axisPointerModel.get('value');

        this._moveHandleToValue(value);

        this._api.dispatchAction({
            type: 'hideTip'
        });
    },

    getHandleTransform: null,

    updateHandleTransform: null,

    clear: function clear(api) {
        this._lastValue = null;
        this._lastStatus = null;

        var zr = api.getZr();
        var group = this._group;
        var handle = this._handle;
        if (zr && group) {
            this._lastGraphicKey = null;
            group && zr.remove(group);
            handle && zr.remove(handle);
            this._group = null;
            this._handle = null;
            this._payloadInfo = null;
        }
    },

    doClear: function doClear() {},

    buildLabel: function buildLabel(xy, wh, xDimIndex) {
        xDimIndex = xDimIndex || 0;
        return {
            x: xy[xDimIndex],
            y: xy[1 - xDimIndex],
            width: wh[xDimIndex],
            height: wh[1 - xDimIndex]
        };
    }
};

BaseAxisPointer.prototype.constructor = BaseAxisPointer;

function updateProps(animationModel, moveAnimation, el, props) {
    if (!propsEqual(BaseAxisPointer_get(el).lastProp, props)) {
        BaseAxisPointer_get(el).lastProp = props;
        moveAnimation ? graphic["updateProps"](el, props, animationModel) : (el.stopAnimation(), el.attr(props));
    }
}

function propsEqual(lastProps, newProps) {
    if (util["t" /* isObject */](lastProps) && util["t" /* isObject */](newProps)) {
        var equals = true;
        util["i" /* each */](newProps, function (item, key) {
            equals = equals && propsEqual(lastProps[key], item);
        });
        return !!equals;
    } else {
        return lastProps === newProps;
    }
}

function updateLabelShowHide(labelEl, axisPointerModel) {
    labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();
}

function getHandleTransProps(trans) {
    return {
        position: trans.position.slice(),
        rotation: trans.rotation || 0
    };
}

function updateMandatoryProps(group, axisPointerModel, silent) {
    var z = axisPointerModel.get('z');
    var zlevel = axisPointerModel.get('zlevel');

    group && group.traverse(function (el) {
        if (el.type !== 'group') {
            z != null && (el.z = z);
            zlevel != null && (el.zlevel = zlevel);
            el.silent = silent;
        }
    });
}

clazz["a" /* enableClassExtend */](BaseAxisPointer);

/* harmony default export */ var axisPointer_BaseAxisPointer = (BaseAxisPointer);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer/viewHelper.js








function buildElStyle(axisPointerModel) {
    var axisPointerType = axisPointerModel.get('type');
    var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
    var style;
    if (axisPointerType === 'line') {
        style = styleModel.getLineStyle();
        style.fill = null;
    } else if (axisPointerType === 'shadow') {
        style = styleModel.getAreaStyle();
        style.stroke = null;
    }
    return style;
}

function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
    var value = axisPointerModel.get('value');
    var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
        precision: axisPointerModel.get('label.precision'),
        formatter: axisPointerModel.get('label.formatter')
    });
    var labelModel = axisPointerModel.getModel('label');
    var paddings = format["g" /* normalizeCssArray */](labelModel.get('padding') || 0);

    var font = labelModel.getFont();
    var textRect = contain_text["e" /* getBoundingRect */](text, font);

    var position = labelPos.position;
    var width = textRect.width + paddings[1] + paddings[3];
    var height = textRect.height + paddings[0] + paddings[2];

    var align = labelPos.align;
    align === 'right' && (position[0] -= width);
    align === 'center' && (position[0] -= width / 2);
    var verticalAlign = labelPos.verticalAlign;
    verticalAlign === 'bottom' && (position[1] -= height);
    verticalAlign === 'middle' && (position[1] -= height / 2);

    confineInContainer(position, width, height, api);

    var bgColor = labelModel.get('backgroundColor');
    if (!bgColor || bgColor === 'auto') {
        bgColor = axisModel.get('axisLine.lineStyle.color');
    }

    elOption.label = {
        shape: { x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius') },
        position: position.slice(),

        style: {
            text: text,
            textFont: font,
            textFill: labelModel.getTextColor(),
            textPosition: 'inside',
            fill: bgColor,
            stroke: labelModel.get('borderColor') || 'transparent',
            lineWidth: labelModel.get('borderWidth') || 0,
            shadowBlur: labelModel.get('shadowBlur'),
            shadowColor: labelModel.get('shadowColor'),
            shadowOffsetX: labelModel.get('shadowOffsetX'),
            shadowOffsetY: labelModel.get('shadowOffsetY')
        },

        z2: 10
    };
}

function confineInContainer(position, width, height, api) {
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    position[0] = Math.min(position[0] + width, viewWidth) - width;
    position[1] = Math.min(position[1] + height, viewHeight) - height;
    position[0] = Math.max(position[0], 0);
    position[1] = Math.max(position[1], 0);
}

function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
    var text = axis.scale.getLabel(value, { precision: opt.precision });
    var formatter = opt.formatter;

    if (formatter) {
        var params = {
            value: getAxisRawValue(axis, value),
            seriesData: []
        };
        util["i" /* each */](seriesDataIndices, function (idxItem) {
            var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
            var dataIndex = idxItem.dataIndexInside;
            var dataParams = series && series.getDataParams(dataIndex);
            dataParams && params.seriesData.push(dataParams);
        });

        if (util["u" /* isString */](formatter)) {
            text = formatter.replace('{value}', text);
        } else if (util["s" /* isFunction */](formatter)) {
            text = formatter(params);
        }
    }

    return text;
}

function getTransformedPosition(axis, value, layoutInfo) {
    var transform = core_matrix["b" /* create */]();
    core_matrix["f" /* rotate */](transform, transform, layoutInfo.rotation);
    core_matrix["h" /* translate */](transform, transform, layoutInfo.position);

    return graphic["applyTransform"]([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
}

function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
    var textLayout = axis_AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
    layoutInfo.labelMargin = axisPointerModel.get('label.margin');
    buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
        position: getTransformedPosition(axisModel.axis, value, layoutInfo),
        align: textLayout.textAlign,
        verticalAlign: textLayout.textVerticalAlign
    });
}

function makeLineShape(p1, p2, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
        x1: p1[xDimIndex],
        y1: p1[1 - xDimIndex],
        x2: p2[xDimIndex],
        y2: p2[1 - xDimIndex]
    };
}

function makeRectShape(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
        x: xy[xDimIndex],
        y: xy[1 - xDimIndex],
        width: wh[xDimIndex],
        height: wh[1 - xDimIndex]
    };
}

function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
    return {
        cx: cx,
        cy: cy,
        r0: r0,
        r: r,
        startAngle: startAngle,
        endAngle: endAngle,
        clockwise: true
    };
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer/CartesianAxisPointer.js






var CartesianAxisPointer = axisPointer_BaseAxisPointer.extend({
    makeElOption: function makeElOption(elOption, value, axisModel, axisPointerModel, api) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisPointerType = axisPointerModel.get('type');
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));

        if (axisPointerType && axisPointerType !== 'none') {
            var elStyle = buildElStyle(axisPointerModel);
            var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent, elStyle);
            pointerOption.style = elStyle;
            elOption.graphicKey = pointerOption.type;
            elOption.pointer = pointerOption;
        }

        var layoutInfo = cartesianAxisHelper_layout(grid.model, axisModel);
        buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
    },

    getHandleTransform: function getHandleTransform(value, axisModel, axisPointerModel) {
        var layoutInfo = cartesianAxisHelper_layout(axisModel.axis.grid.model, axisModel, {
            labelInside: false
        });
        layoutInfo.labelMargin = axisPointerModel.get('handle.margin');
        return {
            position: getTransformedPosition(axisModel.axis, value, layoutInfo),
            rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        };
    },

    updateHandleTransform: function updateHandleTransform(transform, delta, axisModel, axisPointerModel) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisExtent = axis.getGlobalExtent(true);
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var dimIndex = axis.dim === 'x' ? 0 : 1;

        var currPosition = transform.position;
        currPosition[dimIndex] += delta[dimIndex];
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);

        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
        var cursorPoint = [cursorOtherValue, cursorOtherValue];
        cursorPoint[dimIndex] = currPosition[dimIndex];

        var tooltipOptions = [{ verticalAlign: 'middle' }, { align: 'center' }];

        return {
            position: currPosition,
            rotation: transform.rotation,
            cursorPoint: cursorPoint,
            tooltipOption: tooltipOptions[dimIndex]
        };
    }

});

function getCartesian(grid, axis) {
    var opt = {};
    opt[axis.dim + 'AxisIndex'] = axis.index;
    return grid.getCartesian(opt);
}

var pointerShapeBuilder = {

    line: function line(axis, pixelValue, otherExtent, elStyle) {
        var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
        graphic["subPixelOptimizeLine"]({
            shape: targetShape,
            style: elStyle
        });
        return {
            type: 'Line',
            shape: targetShape
        };
    },

    shadow: function shadow(axis, pixelValue, otherExtent, elStyle) {
        var bandWidth = axis.getBandWidth();
        var span = otherExtent[1] - otherExtent[0];
        return {
            type: 'Rect',
            shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
        };
    }
};

function getAxisDimIndex(axis) {
    return axis.dim === 'x' ? 0 : 1;
}

axis_AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);

/* harmony default export */ var axisPointer_CartesianAxisPointer = (CartesianAxisPointer);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/axisPointer.js










registerPreprocessor(function (option) {
    if (option) {
        (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});

        var link = option.axisPointer.link;

        if (link && !util["p" /* isArray */](link)) {
            option.axisPointer.link = [link];
        }
    }
});

registerProcessor(PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
    ecModel.getComponent('axisPointer').coordSysAxesInfo = collect(ecModel, api);
});

registerAction({
    type: 'updateAxisPointer',
    event: 'updateAxisPointer',
    update: ':updateAxisPointer'
}, axisTrigger);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/tooltip/TooltipModel.js


/* harmony default export */ var TooltipModel = (extendComponentModel({

    type: 'tooltip',

    dependencies: ['axisPointer'],

    defaultOption: {
        zlevel: 0,

        z: 8,

        show: true,

        showContent: true,

        trigger: 'item',

        triggerOn: 'mousemove|click',

        alwaysShowContent: false,

        displayMode: 'single',
        confine: false,

        showDelay: 0,

        hideDelay: 100,

        transitionDuration: 0.4,

        enterable: false,

        backgroundColor: 'rgba(50,50,50,0.7)',

        borderColor: '#333',

        borderRadius: 4,

        borderWidth: 0,

        padding: 5,

        extraCssText: '',

        axisPointer: {
            type: 'line',

            axis: 'auto',

            animation: 'auto',
            animationDurationUpdate: 200,
            animationEasingUpdate: 'exponentialOut',

            crossStyle: {
                color: '#999',
                width: 1,
                type: 'dashed',

                textStyle: {}
            }

        },
        textStyle: {
            color: '#fff',
            fontSize: 14
        }
    }
}));
// CONCATENATED MODULE: ./node_modules/echarts/src/component/tooltip/TooltipContent.js






var TooltipContent_each = util["i" /* each */];
var toCamelCase = format["h" /* toCamelCase */];

var vendors = ['', '-webkit-', '-moz-', '-o-'];

var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';

function assembleTransition(duration) {
    var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
    var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;
    return util["v" /* map */](vendors, function (vendorPrefix) {
        return vendorPrefix + 'transition:' + transitionText;
    }).join(';');
}

function assembleFont(textStyleModel) {
    var cssText = [];

    var fontSize = textStyleModel.get('fontSize');
    var color = textStyleModel.getTextColor();

    color && cssText.push('color:' + color);

    cssText.push('font:' + textStyleModel.getFont());

    fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');

    TooltipContent_each(['decoration', 'align'], function (name) {
        var val = textStyleModel.get(name);
        val && cssText.push('text-' + name + ':' + val);
    });

    return cssText.join(';');
}

function assembleCssText(tooltipModel) {

    var cssText = [];

    var transitionDuration = tooltipModel.get('transitionDuration');
    var backgroundColor = tooltipModel.get('backgroundColor');
    var textStyleModel = tooltipModel.getModel('textStyle');
    var padding = tooltipModel.get('padding');

    transitionDuration && cssText.push(assembleTransition(transitionDuration));

    if (backgroundColor) {
        if (core_env["a" /* default */].canvasSupported) {
            cssText.push('background-Color:' + backgroundColor);
        } else {
            cssText.push('background-Color:#' + tool_color["d" /* toHex */](backgroundColor));
            cssText.push('filter:alpha(opacity=70)');
        }
    }

    TooltipContent_each(['width', 'color', 'radius'], function (name) {
        var borderName = 'border-' + name;
        var camelCase = toCamelCase(borderName);
        var val = tooltipModel.get(camelCase);
        val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
    });

    cssText.push(assembleFont(textStyleModel));

    if (padding != null) {
        cssText.push('padding:' + format["g" /* normalizeCssArray */](padding).join('px ') + 'px');
    }

    return cssText.join(';') + ';';
}

function TooltipContent(container, api) {
    var el = document.createElement('div');
    var zr = this._zr = api.getZr();

    this.el = el;

    this._x = api.getWidth() / 2;
    this._y = api.getHeight() / 2;

    container.appendChild(el);

    this._container = container;

    this._show = false;

    this._hideTimeout;

    var self = this;
    el.onmouseenter = function () {
        if (self._enterable) {
            clearTimeout(self._hideTimeout);
            self._show = true;
        }
        self._inContent = true;
    };
    el.onmousemove = function (e) {
        e = e || window.event;
        if (!self._enterable) {
            var handler = zr.handler;
            normalizeEvent(container, e, true);
            handler.dispatch('mousemove', e);
        }
    };
    el.onmouseleave = function () {
        if (self._enterable) {
            if (self._show) {
                self.hideLater(self._hideDelay);
            }
        }
        self._inContent = false;
    };
}

TooltipContent.prototype = {

    constructor: TooltipContent,

    _enterable: true,

    update: function update() {
        var container = this._container;
        var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
        var domStyle = container.style;
        if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
            domStyle.position = 'relative';
        }
    },

    show: function show(tooltipModel) {
        clearTimeout(this._hideTimeout);
        var el = this.el;

        el.style.cssText = gCssText + assembleCssText(tooltipModel) + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');

        el.style.display = el.innerHTML ? 'block' : 'none';

        this._show = true;
    },

    setContent: function setContent(content) {
        this.el.innerHTML = content == null ? '' : content;
    },

    setEnterable: function setEnterable(enterable) {
        this._enterable = enterable;
    },

    getSize: function getSize() {
        var el = this.el;
        return [el.clientWidth, el.clientHeight];
    },

    moveTo: function moveTo(x, y) {
        var zr = this._zr;
        var viewportRootOffset;
        if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {
            x += viewportRootOffset.offsetLeft;
            y += viewportRootOffset.offsetTop;
        }

        var style = this.el.style;
        style.left = x + 'px';
        style.top = y + 'px';

        this._x = x;
        this._y = y;
    },

    hide: function hide() {
        this.el.style.display = 'none';
        this._show = false;
    },

    hideLater: function hideLater(time) {
        if (this._show && !(this._inContent && this._enterable)) {
            if (time) {
                this._hideDelay = time;

                this._show = false;
                this._hideTimeout = setTimeout(util["c" /* bind */](this.hide, this), time);
            } else {
                this.hide();
            }
        }
    },

    isShow: function isShow() {
        return this._show;
    }
};

/* harmony default export */ var tooltip_TooltipContent = (TooltipContent);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/tooltip/TooltipView.js














var TooltipView_bind = util["c" /* bind */];
var TooltipView_each = util["i" /* each */];
var parsePercent = number["h" /* parsePercent */];

var proxyRect = new graphic["Rect"]({
    shape: { x: -1, y: -1, width: 2, height: 2 }
});

/* harmony default export */ var TooltipView = (extendComponentView({

    type: 'tooltip',

    init: function init(ecModel, api) {
        if (core_env["a" /* default */].node) {
            return;
        }
        var tooltipContent = new tooltip_TooltipContent(api.getDom(), api);
        this._tooltipContent = tooltipContent;
    },

    render: function render(tooltipModel, ecModel, api) {
        if (core_env["a" /* default */].node) {
            return;
        }

        this.group.removeAll();

        this._tooltipModel = tooltipModel;

        this._ecModel = ecModel;

        this._api = api;

        this._lastDataByCoordSys = null;

        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');

        var tooltipContent = this._tooltipContent;
        tooltipContent.update();
        tooltipContent.setEnterable(tooltipModel.get('enterable'));

        this._initGlobalListener();

        this._keepShow();
    },

    _initGlobalListener: function _initGlobalListener() {
        var tooltipModel = this._tooltipModel;
        var triggerOn = tooltipModel.get('triggerOn');

        register('itemTooltip', this._api, TooltipView_bind(function (currTrigger, e, dispatchAction) {
            if (triggerOn !== 'none') {
                if (triggerOn.indexOf(currTrigger) >= 0) {
                    this._tryShow(e, dispatchAction);
                } else if (currTrigger === 'leave') {
                    this._hide(dispatchAction);
                }
            }
        }, this));
    },

    _keepShow: function _keepShow() {
        var tooltipModel = this._tooltipModel;
        var ecModel = this._ecModel;
        var api = this._api;

        if (this._lastX != null && this._lastY != null && tooltipModel.get('triggerOn') !== 'none') {
            var self = this;
            clearTimeout(this._refreshUpdateTimeout);
            this._refreshUpdateTimeout = setTimeout(function () {
                self.manuallyShowTip(tooltipModel, ecModel, api, {
                    x: self._lastX,
                    y: self._lastY
                });
            });
        }
    },

    manuallyShowTip: function manuallyShowTip(tooltipModel, ecModel, api, payload) {
        if (payload.from === this.uid || core_env["a" /* default */].node) {
            return;
        }

        var dispatchAction = TooltipView_makeDispatchAction(payload, api);

        this._ticket = '';

        var dataByCoordSys = payload.dataByCoordSys;

        if (payload.tooltip && payload.x != null && payload.y != null) {
            var el = proxyRect;
            el.position = [payload.x, payload.y];
            el.update();
            el.tooltip = payload.tooltip;

            this._tryShow({
                offsetX: payload.x,
                offsetY: payload.y,
                target: el
            }, dispatchAction);
        } else if (dataByCoordSys) {
            this._tryShow({
                offsetX: payload.x,
                offsetY: payload.y,
                position: payload.position,
                event: {},
                dataByCoordSys: payload.dataByCoordSys,
                tooltipOption: payload.tooltipOption
            }, dispatchAction);
        } else if (payload.seriesIndex != null) {

            if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
                return;
            }

            var pointInfo = findPointFromSeries(payload, ecModel);
            var cx = pointInfo.point[0];
            var cy = pointInfo.point[1];
            if (cx != null && cy != null) {
                this._tryShow({
                    offsetX: cx,
                    offsetY: cy,
                    position: payload.position,
                    target: pointInfo.el,
                    event: {}
                }, dispatchAction);
            }
        } else if (payload.x != null && payload.y != null) {
            api.dispatchAction({
                type: 'updateAxisPointer',
                x: payload.x,
                y: payload.y
            });

            this._tryShow({
                offsetX: payload.x,
                offsetY: payload.y,
                position: payload.position,
                target: api.getZr().findHover(payload.x, payload.y).target,
                event: {}
            }, dispatchAction);
        }
    },

    manuallyHideTip: function manuallyHideTip(tooltipModel, ecModel, api, payload) {
        var tooltipContent = this._tooltipContent;

        if (!this._alwaysShowContent) {
            tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
        }

        this._lastX = this._lastY = null;

        if (payload.from !== this.uid) {
            this._hide(TooltipView_makeDispatchAction(payload, api));
        }
    },

    _manuallyAxisShowTip: function _manuallyAxisShowTip(tooltipModel, ecModel, api, payload) {
        var seriesIndex = payload.seriesIndex;
        var dataIndex = payload.dataIndex;
        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;

        if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
            return;
        }

        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        if (!seriesModel) {
            return;
        }

        var data = seriesModel.getData();
        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);

        if (tooltipModel.get('trigger') !== 'axis') {
            return;
        }

        api.dispatchAction({
            type: 'updateAxisPointer',
            seriesIndex: seriesIndex,
            dataIndex: dataIndex,
            position: payload.position
        });

        return true;
    },

    _tryShow: function _tryShow(e, dispatchAction) {
        var el = e.target;
        var tooltipModel = this._tooltipModel;

        if (!tooltipModel) {
            return;
        }

        this._lastX = e.offsetX;
        this._lastY = e.offsetY;

        var dataByCoordSys = e.dataByCoordSys;
        if (dataByCoordSys && dataByCoordSys.length) {
            this._showAxisTooltip(dataByCoordSys, e);
        } else if (el && el.dataIndex != null) {
                this._lastDataByCoordSys = null;
                this._showSeriesItemTooltip(e, el, dispatchAction);
            } else if (el && el.tooltip) {
                    this._lastDataByCoordSys = null;
                    this._showComponentItemTooltip(e, el, dispatchAction);
                } else {
                    this._lastDataByCoordSys = null;
                    this._hide(dispatchAction);
                }
    },

    _showOrMove: function _showOrMove(tooltipModel, cb) {
        var delay = tooltipModel.get('showDelay');
        cb = util["c" /* bind */](cb, this);
        clearTimeout(this._showTimout);
        delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
    },

    _showAxisTooltip: function _showAxisTooltip(dataByCoordSys, e) {
        var ecModel = this._ecModel;
        var globalTooltipModel = this._tooltipModel;
        var point = [e.offsetX, e.offsetY];
        var singleDefaultHTML = [];
        var singleParamsList = [];
        var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);

        TooltipView_each(dataByCoordSys, function (itemCoordSys) {

            TooltipView_each(itemCoordSys.dataByAxis, function (item) {
                var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);
                var axisValue = item.value;
                var seriesDefaultHTML = [];

                if (!axisModel || axisValue == null) {
                    return;
                }

                var valueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);

                util["i" /* each */](item.seriesDataIndices, function (idxItem) {
                    var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
                    var dataIndex = idxItem.dataIndexInside;
                    var dataParams = series && series.getDataParams(dataIndex);
                    dataParams.axisDim = item.axisDim;
                    dataParams.axisIndex = item.axisIndex;
                    dataParams.axisType = item.axisType;
                    dataParams.axisId = item.axisId;
                    dataParams.axisValue = getAxisRawValue(axisModel.axis, axisValue);
                    dataParams.axisValueLabel = valueLabel;

                    if (dataParams) {
                        singleParamsList.push(dataParams);
                        seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));
                    }
                });

                var firstLine = valueLabel;
                singleDefaultHTML.push((firstLine ? format["c" /* encodeHTML */](firstLine) + '<br />' : '') + seriesDefaultHTML.join('<br />'));
            });
        }, this);

        singleDefaultHTML.reverse();
        singleDefaultHTML = singleDefaultHTML.join('<br /><br />');

        var positionExpr = e.position;
        this._showOrMove(singleTooltipModel, function () {
            if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
                this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
            } else {
                this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr);
            }
        });
    },

    _showSeriesItemTooltip: function _showSeriesItemTooltip(e, el, dispatchAction) {
        var ecModel = this._ecModel;

        var seriesIndex = el.seriesIndex;
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);

        var dataModel = el.dataModel || seriesModel;
        var dataIndex = el.dataIndex;
        var dataType = el.dataType;
        var data = dataModel.getData();

        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);

        var tooltipTrigger = tooltipModel.get('trigger');
        if (tooltipTrigger != null && tooltipTrigger !== 'item') {
            return;
        }

        var params = dataModel.getDataParams(dataIndex, dataType);
        var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);
        var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;

        this._showOrMove(tooltipModel, function () {
            this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target);
        });

        dispatchAction({
            type: 'showTip',
            dataIndexInside: dataIndex,
            dataIndex: data.getRawIndex(dataIndex),
            seriesIndex: seriesIndex,
            from: this.uid
        });
    },

    _showComponentItemTooltip: function _showComponentItemTooltip(e, el, dispatchAction) {
        var tooltipOpt = el.tooltip;
        if (typeof tooltipOpt === 'string') {
            var content = tooltipOpt;
            tooltipOpt = {
                content: content,

                formatter: content
            };
        }
        var subTooltipModel = new Model["a" /* default */](tooltipOpt, this._tooltipModel, this._ecModel);
        var defaultHtml = subTooltipModel.get('content');
        var asyncTicket = Math.random();

        this._showOrMove(subTooltipModel, function () {
            this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
        });

        dispatchAction({
            type: 'showTip',
            from: this.uid
        });
    },

    _showTooltipContent: function _showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el) {
        this._ticket = '';

        if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
            return;
        }

        var tooltipContent = this._tooltipContent;

        var formatter = tooltipModel.get('formatter');
        positionExpr = positionExpr || tooltipModel.get('position');
        var html = defaultHtml;

        if (formatter && typeof formatter === 'string') {
            html = format["e" /* formatTpl */](formatter, params, true);
        } else if (typeof formatter === 'function') {
            var callback = TooltipView_bind(function (cbTicket, html) {
                if (cbTicket === this._ticket) {
                    tooltipContent.setContent(html);
                    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
                }
            }, this);
            this._ticket = asyncTicket;
            html = formatter(params, asyncTicket, callback);
        }

        tooltipContent.setContent(html);
        tooltipContent.show(tooltipModel);

        this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
    },

    _updatePosition: function _updatePosition(tooltipModel, positionExpr, x, y, content, params, el) {
        var viewWidth = this._api.getWidth();
        var viewHeight = this._api.getHeight();
        positionExpr = positionExpr || tooltipModel.get('position');

        var contentSize = content.getSize();
        var align = tooltipModel.get('align');
        var vAlign = tooltipModel.get('verticalAlign');
        var rect = el && el.getBoundingRect().clone();
        el && rect.applyTransform(el.transform);

        if (typeof positionExpr === 'function') {
            positionExpr = positionExpr([x, y], params, content.el, rect, {
                viewSize: [viewWidth, viewHeight],
                contentSize: contentSize.slice()
            });
        }

        if (util["p" /* isArray */](positionExpr)) {
            x = parsePercent(positionExpr[0], viewWidth);
            y = parsePercent(positionExpr[1], viewHeight);
        } else if (util["t" /* isObject */](positionExpr)) {
            positionExpr.width = contentSize[0];
            positionExpr.height = contentSize[1];
            var layoutRect = getLayoutRect(positionExpr, { width: viewWidth, height: viewHeight });
            x = layoutRect.x;
            y = layoutRect.y;
            align = null;

            vAlign = null;
        } else if (typeof positionExpr === 'string' && el) {
                var pos = calcTooltipPosition(positionExpr, rect, contentSize);
                x = pos[0];
                y = pos[1];
            } else {
                var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
                x = pos[0];
                y = pos[1];
            }

        align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
        vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);

        if (tooltipModel.get('confine')) {
            var pos = confineTooltipPosition(x, y, content.el, viewWidth, viewHeight);
            x = pos[0];
            y = pos[1];
        }

        content.moveTo(x, y);
    },

    _updateContentNotChangedOnAxis: function _updateContentNotChangedOnAxis(dataByCoordSys) {
        var lastCoordSys = this._lastDataByCoordSys;
        var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;

        contentNotChanged && TooltipView_each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
            var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
            var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
            var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
            contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;

            contentNotChanged && TooltipView_each(lastDataByAxis, function (lastItem, indexAxis) {
                var thisItem = thisDataByAxis[indexAxis] || {};
                var lastIndices = lastItem.seriesDataIndices || [];
                var newIndices = thisItem.seriesDataIndices || [];

                contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;

                contentNotChanged && TooltipView_each(lastIndices, function (lastIdxItem, j) {
                    var newIdxItem = newIndices[j];
                    contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
                });
            });
        });

        this._lastDataByCoordSys = dataByCoordSys;

        return !!contentNotChanged;
    },

    _hide: function _hide(dispatchAction) {
        this._lastDataByCoordSys = null;
        dispatchAction({
            type: 'hideTip',
            from: this.uid
        });
    },

    dispose: function dispose(ecModel, api) {
        if (core_env["a" /* default */].node) {
            return;
        }
        this._tooltipContent.hide();
        unregister('itemTooltip', api);
    }
}));

function buildTooltipModel(modelCascade) {
    var resultModel = modelCascade.pop();
    while (modelCascade.length) {
        var tooltipOpt = modelCascade.pop();
        if (tooltipOpt) {
            if (tooltipOpt instanceof Model["a" /* default */]) {
                tooltipOpt = tooltipOpt.get('tooltip', true);
            }

            if (typeof tooltipOpt === 'string') {
                tooltipOpt = { formatter: tooltipOpt };
            }
            resultModel = new Model["a" /* default */](tooltipOpt, resultModel, resultModel.ecModel);
        }
    }
    return resultModel;
}

function TooltipView_makeDispatchAction(payload, api) {
    return payload.dispatchAction || util["c" /* bind */](api.dispatchAction, api);
}

function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {
    var size = getOuterSize(el);
    var width = size.width;
    var height = size.height;

    if (gapH != null) {
        if (x + width + gapH > viewWidth) {
            x -= width + gapH;
        } else {
            x += gapH;
        }
    }
    if (gapV != null) {
        if (y + height + gapV > viewHeight) {
            y -= height + gapV;
        } else {
            y += gapV;
        }
    }
    return [x, y];
}

function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {
    var size = getOuterSize(el);
    var width = size.width;
    var height = size.height;

    x = Math.min(x + width, viewWidth) - width;
    y = Math.min(y + height, viewHeight) - height;
    x = Math.max(x, 0);
    y = Math.max(y, 0);

    return [x, y];
}

function getOuterSize(el) {
    var width = el.clientWidth;
    var height = el.clientHeight;

    if (document.defaultView && document.defaultView.getComputedStyle) {
        var stl = document.defaultView.getComputedStyle(el);
        if (stl) {
            width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
            height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
        }
    }

    return { width: width, height: height };
}

function calcTooltipPosition(position, rect, contentSize) {
    var domWidth = contentSize[0];
    var domHeight = contentSize[1];
    var gap = 5;
    var x = 0;
    var y = 0;
    var rectWidth = rect.width;
    var rectHeight = rect.height;
    switch (position) {
        case 'inside':
            x = rect.x + rectWidth / 2 - domWidth / 2;
            y = rect.y + rectHeight / 2 - domHeight / 2;
            break;
        case 'top':
            x = rect.x + rectWidth / 2 - domWidth / 2;
            y = rect.y - domHeight - gap;
            break;
        case 'bottom':
            x = rect.x + rectWidth / 2 - domWidth / 2;
            y = rect.y + rectHeight + gap;
            break;
        case 'left':
            x = rect.x - domWidth - gap;
            y = rect.y + rectHeight / 2 - domHeight / 2;
            break;
        case 'right':
            x = rect.x + rectWidth + gap;
            y = rect.y + rectHeight / 2 - domHeight / 2;
    }
    return [x, y];
}

function isCenterAlign(align) {
    return align === 'center' || align === 'middle';
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/tooltip.js








registerAction({
    type: 'showTip',
    event: 'showTip',
    update: 'tooltip:manuallyShowTip'
}, function () {});

registerAction({
    type: 'hideTip',
    event: 'hideTip',
    update: 'tooltip:manuallyHideTip'
}, function () {});
// CONCATENATED MODULE: ./node_modules/echarts/src/component/title.js




extendComponentModel({

    type: 'title',

    layoutMode: { type: 'box', ignoreSize: true },

    defaultOption: {
        zlevel: 0,

        z: 6,
        show: true,

        text: '',

        target: 'blank',
        subtext: '',

        subtarget: 'blank',

        left: 0,

        top: 0,

        backgroundColor: 'rgba(0,0,0,0)',

        borderColor: '#ccc',

        borderWidth: 0,

        padding: 5,

        itemGap: 10,
        textStyle: {
            fontSize: 18,
            fontWeight: 'bolder',
            color: '#333'
        },
        subtextStyle: {
            color: '#aaa'
        }
    }
});

extendComponentView({

    type: 'title',

    render: function render(titleModel, ecModel, api) {
        this.group.removeAll();

        if (!titleModel.get('show')) {
            return;
        }

        var group = this.group;

        var textStyleModel = titleModel.getModel('textStyle');
        var subtextStyleModel = titleModel.getModel('subtextStyle');

        var textAlign = titleModel.get('textAlign');
        var textBaseline = titleModel.get('textBaseline');

        var textEl = new graphic["Text"]({
            style: graphic["setTextStyle"]({}, textStyleModel, {
                text: titleModel.get('text'),
                textFill: textStyleModel.getTextColor()
            }, { disableBox: true }),
            z2: 10
        });

        var textRect = textEl.getBoundingRect();

        var subText = titleModel.get('subtext');
        var subTextEl = new graphic["Text"]({
            style: graphic["setTextStyle"]({}, subtextStyleModel, {
                text: subText,
                textFill: subtextStyleModel.getTextColor(),
                y: textRect.height + titleModel.get('itemGap'),
                textVerticalAlign: 'top'
            }, { disableBox: true }),
            z2: 10
        });

        var link = titleModel.get('link');
        var sublink = titleModel.get('sublink');

        textEl.silent = !link;
        subTextEl.silent = !sublink;

        if (link) {
            textEl.on('click', function () {
                window.open(link, '_' + titleModel.get('target'));
            });
        }
        if (sublink) {
            subTextEl.on('click', function () {
                window.open(sublink, '_' + titleModel.get('subtarget'));
            });
        }

        group.add(textEl);
        subText && group.add(subTextEl);


        var groupRect = group.getBoundingRect();
        var layoutOption = titleModel.getBoxLayoutParams();
        layoutOption.width = groupRect.width;
        layoutOption.height = groupRect.height;
        var layoutRect = getLayoutRect(layoutOption, {
            width: api.getWidth(),
            height: api.getHeight()
        }, titleModel.get('padding'));

        if (!textAlign) {
            textAlign = titleModel.get('left') || titleModel.get('right');
            if (textAlign === 'middle') {
                textAlign = 'center';
            }

            if (textAlign === 'right') {
                layoutRect.x += layoutRect.width;
            } else if (textAlign === 'center') {
                layoutRect.x += layoutRect.width / 2;
            }
        }
        if (!textBaseline) {
            textBaseline = titleModel.get('top') || titleModel.get('bottom');
            if (textBaseline === 'center') {
                textBaseline = 'middle';
            }
            if (textBaseline === 'bottom') {
                layoutRect.y += layoutRect.height;
            } else if (textBaseline === 'middle') {
                layoutRect.y += layoutRect.height / 2;
            }

            textBaseline = textBaseline || 'top';
        }

        group.attr('position', [layoutRect.x, layoutRect.y]);
        var alignStyle = {
            textAlign: textAlign,
            textVerticalAlign: textBaseline
        };
        textEl.setStyle(alignStyle);
        subTextEl.setStyle(alignStyle);

        groupRect = group.getBoundingRect();
        var padding = layoutRect.margin;
        var style = titleModel.getItemStyle(['color', 'opacity']);
        style.fill = titleModel.get('backgroundColor');
        var rect = new graphic["Rect"]({
            shape: {
                x: groupRect.x - padding[3],
                y: groupRect.y - padding[0],
                width: groupRect.width + padding[1] + padding[3],
                height: groupRect.height + padding[0] + padding[2],
                r: titleModel.get('borderRadius')
            },
            style: style,
            silent: true
        });
        graphic["subPixelOptimizeRect"](rect);

        group.add(rect);
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/component/toolbox/featureManager.js

var featureManager_features = {};

function featureManager_register(name, ctor) {
    featureManager_features[name] = ctor;
}

function featureManager_get(name) {
    return featureManager_features[name];
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/toolbox/ToolboxModel.js




var ToolboxModel = extendComponentModel({

    type: 'toolbox',

    layoutMode: {
        type: 'box',
        ignoreSize: true
    },

    mergeDefaultAndTheme: function mergeDefaultAndTheme(option) {
        ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);

        util["i" /* each */](this.option.feature, function (featureOpt, featureName) {
            var Feature = featureManager_get(featureName);
            Feature && util["w" /* merge */](featureOpt, Feature.defaultOption);
        });
    },

    defaultOption: {

        show: true,

        z: 6,

        zlevel: 0,

        orient: 'horizontal',

        left: 'right',

        top: 'top',

        backgroundColor: 'transparent',

        borderColor: '#ccc',

        borderRadius: 0,

        borderWidth: 0,

        padding: 5,

        itemSize: 15,

        itemGap: 8,

        showTitle: true,

        iconStyle: {
            normal: {
                borderColor: '#666',
                color: 'none'
            },
            emphasis: {
                borderColor: '#3E98C5'
            }
        }
    }
});

/* harmony default export */ var toolbox_ToolboxModel = (ToolboxModel);
// EXTERNAL MODULE: ./node_modules/echarts/src/data/DataDiffer.js
var DataDiffer = __webpack_require__(59);

// CONCATENATED MODULE: ./node_modules/echarts/src/component/helper/listComponent.js




function listComponent_layout(group, componentModel, api) {
    var boxLayoutParams = componentModel.getBoxLayoutParams();
    var padding = componentModel.get('padding');
    var viewportSize = { width: api.getWidth(), height: api.getHeight() };

    var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);

    box(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);

    positionElement(group, boxLayoutParams, viewportSize, padding);
}

function makeBackground(rect, componentModel) {
    var padding = format["g" /* normalizeCssArray */](componentModel.get('padding'));
    var style = componentModel.getItemStyle(['color', 'opacity']);
    style.fill = componentModel.get('backgroundColor');
    var rect = new graphic["Rect"]({
        shape: {
            x: rect.x - padding[3],
            y: rect.y - padding[0],
            width: rect.width + padding[1] + padding[3],
            height: rect.height + padding[0] + padding[2],
            r: componentModel.get('borderRadius')
        },
        style: style,
        silent: true,
        z2: -1
    });


    return rect;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/toolbox/ToolboxView.js









/* harmony default export */ var ToolboxView = (extendComponentView({

    type: 'toolbox',

    render: function render(toolboxModel, ecModel, api, payload) {
        var group = this.group;
        group.removeAll();

        if (!toolboxModel.get('show')) {
            return;
        }

        var itemSize = +toolboxModel.get('itemSize');
        var featureOpts = toolboxModel.get('feature') || {};
        var features = this._features || (this._features = {});

        var featureNames = [];
        util["i" /* each */](featureOpts, function (opt, name) {
            featureNames.push(name);
        });

        new DataDiffer["a" /* default */](this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(util["g" /* curry */](processFeature, null)).execute();

        this._featureNames = featureNames;

        function processFeature(newIndex, oldIndex) {
            var featureName = featureNames[newIndex];
            var oldName = featureNames[oldIndex];
            var featureOpt = featureOpts[featureName];
            var featureModel = new Model["a" /* default */](featureOpt, toolboxModel, toolboxModel.ecModel);
            var feature;

            if (featureName && !oldName) {
                if (isUserFeatureName(featureName)) {
                    feature = {
                        model: featureModel,
                        onclick: featureModel.option.onclick,
                        featureName: featureName
                    };
                } else {
                    var Feature = featureManager_get(featureName);
                    if (!Feature) {
                        return;
                    }
                    feature = new Feature(featureModel, ecModel, api);
                }
                features[featureName] = feature;
            } else {
                feature = features[oldName];

                if (!feature) {
                    return;
                }
                feature.model = featureModel;
                feature.ecModel = ecModel;
                feature.api = api;
            }

            if (!featureName && oldName) {
                feature.dispose && feature.dispose(ecModel, api);
                return;
            }

            if (!featureModel.get('show') || feature.unusable) {
                feature.remove && feature.remove(ecModel, api);
                return;
            }

            createIconPaths(featureModel, feature, featureName);

            featureModel.setIconStatus = function (iconName, status) {
                var option = this.option;
                var iconPaths = this.iconPaths;
                option.iconStatus = option.iconStatus || {};
                option.iconStatus[iconName] = status;

                iconPaths[iconName] && iconPaths[iconName].trigger(status);
            };

            if (feature.render) {
                feature.render(featureModel, ecModel, api, payload);
            }
        }

        function createIconPaths(featureModel, feature, featureName) {
            var iconStyleModel = featureModel.getModel('iconStyle');

            var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');
            var titles = featureModel.get('title') || {};
            if (typeof icons === 'string') {
                var icon = icons;
                var title = titles;
                icons = {};
                titles = {};
                icons[featureName] = icon;
                titles[featureName] = title;
            }
            var iconPaths = featureModel.iconPaths = {};
            util["i" /* each */](icons, function (iconStr, iconName) {
                var path = graphic["createIcon"](iconStr, {}, {
                    x: -itemSize / 2,
                    y: -itemSize / 2,
                    width: itemSize,
                    height: itemSize
                });
                path.setStyle(iconStyleModel.getModel('normal').getItemStyle());
                path.hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();

                graphic["setHoverStyle"](path);

                if (toolboxModel.get('showTitle')) {
                    path.__title = titles[iconName];
                    path.on('mouseover', function () {
                        var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();
                        path.setStyle({
                            text: titles[iconName],
                            textPosition: hoverStyle.textPosition || 'bottom',
                            textFill: hoverStyle.fill || hoverStyle.stroke || '#000',
                            textAlign: hoverStyle.textAlign || 'center'
                        });
                    }).on('mouseout', function () {
                        path.setStyle({
                            textFill: null
                        });
                    });
                }
                path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');

                group.add(path);
                path.on('click', util["c" /* bind */](feature.onclick, feature, ecModel, api, iconName));

                iconPaths[iconName] = path;
            });
        }

        listComponent_layout(group, toolboxModel, api);

        group.add(makeBackground(group.getBoundingRect(), toolboxModel));

        group.eachChild(function (icon) {
            var titleText = icon.__title;
            var hoverStyle = icon.hoverStyle;

            if (hoverStyle && titleText) {
                var rect = contain_text["e" /* getBoundingRect */](titleText, contain_text["g" /* makeFont */](hoverStyle));
                var offsetX = icon.position[0] + group.position[0];
                var offsetY = icon.position[1] + group.position[1] + itemSize;

                var needPutOnTop = false;
                if (offsetY + rect.height > api.getHeight()) {
                    hoverStyle.textPosition = 'top';
                    needPutOnTop = true;
                }
                var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;
                if (offsetX + rect.width / 2 > api.getWidth()) {
                    hoverStyle.textPosition = ['100%', topOffset];
                    hoverStyle.textAlign = 'right';
                } else if (offsetX - rect.width / 2 < 0) {
                    hoverStyle.textPosition = [0, topOffset];
                    hoverStyle.textAlign = 'left';
                }
            }
        });
    },

    updateView: function updateView(toolboxModel, ecModel, api, payload) {
        util["i" /* each */](this._features, function (feature) {
            feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
        });
    },

    updateLayout: function updateLayout(toolboxModel, ecModel, api, payload) {
        util["i" /* each */](this._features, function (feature) {
            feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
        });
    },

    remove: function remove(ecModel, api) {
        util["i" /* each */](this._features, function (feature) {
            feature.remove && feature.remove(ecModel, api);
        });
        this.group.removeAll();
    },

    dispose: function dispose(ecModel, api) {
        util["i" /* each */](this._features, function (feature) {
            feature.dispose && feature.dispose(ecModel, api);
        });
    }
}));

function isUserFeatureName(featureName) {
    return featureName.indexOf('my') === 0;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/lang.js

/* harmony default export */ var src_lang = ({
    toolbox: {
        brush: {
            title: {
                rect: '矩形选择',
                polygon: '圈选',
                lineX: '横向选择',
                lineY: '纵向选择',
                keep: '保持选择',
                clear: '清除选择'
            }
        },
        dataView: {
            title: '数据视图',
            lang: ['数据视图', '关闭', '刷新']
        },
        dataZoom: {
            title: {
                zoom: '区域缩放',
                back: '区域缩放还原'
            }
        },
        magicType: {
            title: {
                line: '切换为折线图',
                bar: '切换为柱状图',
                stack: '切换为堆叠',
                tiled: '切换为平铺'
            }
        },
        restore: {
            title: '还原'
        },
        saveAsImage: {
            title: '保存为图片',
            lang: ['右键另存为图片']
        }
    }
});
// CONCATENATED MODULE: ./node_modules/echarts/src/component/toolbox/feature/SaveAsImage.js




var saveAsImageLang = src_lang.toolbox.saveAsImage;

function SaveAsImage(model) {
    this.model = model;
}

SaveAsImage.defaultOption = {
    show: true,
    icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
    title: saveAsImageLang.title,
    type: 'png',

    name: '',
    excludeComponents: ['toolbox'],
    pixelRatio: 1,
    lang: saveAsImageLang.lang.slice()
};

SaveAsImage.prototype.unusable = !core_env["a" /* default */].canvasSupported;

var proto = SaveAsImage.prototype;

proto.onclick = function (ecModel, api) {
    var model = this.model;
    var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';
    var $a = document.createElement('a');
    var type = model.get('type', true) || 'png';
    $a.download = title + '.' + type;
    $a.target = '_blank';
    var url = api.getConnectedDataURL({
        type: type,
        backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',
        excludeComponents: model.get('excludeComponents'),
        pixelRatio: model.get('pixelRatio')
    });
    $a.href = url;

    if (typeof MouseEvent === 'function' && !core_env["a" /* default */].browser.ie && !core_env["a" /* default */].browser.edge) {
        var evt = new MouseEvent('click', {
            view: window,
            bubbles: true,
            cancelable: false
        });
        $a.dispatchEvent(evt);
    } else {
            if (window.navigator.msSaveOrOpenBlob) {
                var bstr = atob(url.split(',')[1]);
                var n = bstr.length;
                var u8arr = new Uint8Array(n);
                while (n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                var blob = new Blob([u8arr]);
                window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);
            } else {
                var lang = model.get('lang');
                var html = '' + '<body style="margin:0;">' + '<img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || '') + '" />' + '</body>';
                var tab = window.open();
                tab.document.write(html);
            }
        }
};

featureManager_register('saveAsImage', SaveAsImage);

/* harmony default export */ var feature_SaveAsImage = (SaveAsImage);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/toolbox/feature/MagicType.js





var magicTypeLang = src_lang.toolbox.magicType;

function MagicType(model) {
    this.model = model;
}

MagicType.defaultOption = {
    show: true,
    type: [],

    icon: {
        line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
        bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
        stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',
        tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'
    },

    title: util["d" /* clone */](magicTypeLang.title),
    option: {},
    seriesIndex: {}
};

var MagicType_proto = MagicType.prototype;

MagicType_proto.getIcons = function () {
    var model = this.model;
    var availableIcons = model.get('icon');
    var icons = {};
    util["i" /* each */](model.get('type'), function (type) {
        if (availableIcons[type]) {
            icons[type] = availableIcons[type];
        }
    });
    return icons;
};

var seriesOptGenreator = {
    'line': function line(seriesType, seriesId, seriesModel, model) {
        if (seriesType === 'bar') {
            return util["w" /* merge */]({
                id: seriesId,
                type: 'line',

                data: seriesModel.get('data'),
                stack: seriesModel.get('stack'),
                markPoint: seriesModel.get('markPoint'),
                markLine: seriesModel.get('markLine')
            }, model.get('option.line') || {}, true);
        }
    },
    'bar': function bar(seriesType, seriesId, seriesModel, model) {
        if (seriesType === 'line') {
            return util["w" /* merge */]({
                id: seriesId,
                type: 'bar',

                data: seriesModel.get('data'),
                stack: seriesModel.get('stack'),
                markPoint: seriesModel.get('markPoint'),
                markLine: seriesModel.get('markLine')
            }, model.get('option.bar') || {}, true);
        }
    },
    'stack': function stack(seriesType, seriesId, seriesModel, model) {
        if (seriesType === 'line' || seriesType === 'bar') {
            return util["w" /* merge */]({
                id: seriesId,
                stack: '__ec_magicType_stack__'
            }, model.get('option.stack') || {}, true);
        }
    },
    'tiled': function tiled(seriesType, seriesId, seriesModel, model) {
        if (seriesType === 'line' || seriesType === 'bar') {
            return util["w" /* merge */]({
                id: seriesId,
                stack: ''
            }, model.get('option.tiled') || {}, true);
        }
    }
};

var radioTypes = [['line', 'bar'], ['stack', 'tiled']];

MagicType_proto.onclick = function (ecModel, api, type) {
    var model = this.model;
    var seriesIndex = model.get('seriesIndex.' + type);

    if (!seriesOptGenreator[type]) {
        return;
    }
    var newOption = {
        series: []
    };
    var generateNewSeriesTypes = function generateNewSeriesTypes(seriesModel) {
        var seriesType = seriesModel.subType;
        var seriesId = seriesModel.id;
        var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);
        if (newSeriesOpt) {
            util["h" /* defaults */](newSeriesOpt, seriesModel.option);
            newOption.series.push(newSeriesOpt);
        }

        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {
            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];
            if (categoryAxis) {
                var axisDim = categoryAxis.dim;
                var axisType = axisDim + 'Axis';
                var axisModel = ecModel.queryComponents({
                    mainType: axisType,
                    index: seriesModel.get(name + 'Index'),
                    id: seriesModel.get(name + 'Id')
                })[0];
                var axisIndex = axisModel.componentIndex;

                newOption[axisType] = newOption[axisType] || [];
                for (var i = 0; i <= axisIndex; i++) {
                    newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
                }
                newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;
            }
        }
    };

    util["i" /* each */](radioTypes, function (radio) {
        if (util["n" /* indexOf */](radio, type) >= 0) {
            util["i" /* each */](radio, function (item) {
                model.setIconStatus(item, 'normal');
            });
        }
    });

    model.setIconStatus(type, 'emphasis');

    ecModel.eachComponent({
        mainType: 'series',
        query: seriesIndex == null ? null : {
            seriesIndex: seriesIndex
        }
    }, generateNewSeriesTypes);
    api.dispatchAction({
        type: 'changeMagicType',
        currentType: type,
        newOption: newOption
    });
};

registerAction({
    type: 'changeMagicType',
    event: 'magicTypeChanged',
    update: 'prepareAndUpdate'
}, function (payload, ecModel) {
    ecModel.mergeOption(payload.newOption);
});

featureManager_register('magicType', MagicType);

/* harmony default export */ var feature_MagicType = (MagicType);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/toolbox/feature/DataView.js






var dataViewLang = src_lang.toolbox.dataView;

var BLOCK_SPLITER = new Array(60).join('-');
var ITEM_SPLITER = '\t';

function groupSeries(ecModel) {
    var seriesGroupByCategoryAxis = {};
    var otherSeries = [];
    var meta = [];
    ecModel.eachRawSeries(function (seriesModel) {
        var coordSys = seriesModel.coordinateSystem;

        if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {
            var baseAxis = coordSys.getBaseAxis();
            if (baseAxis.type === 'category') {
                var key = baseAxis.dim + '_' + baseAxis.index;
                if (!seriesGroupByCategoryAxis[key]) {
                    seriesGroupByCategoryAxis[key] = {
                        categoryAxis: baseAxis,
                        valueAxis: coordSys.getOtherAxis(baseAxis),
                        series: []
                    };
                    meta.push({
                        axisDim: baseAxis.dim,
                        axisIndex: baseAxis.index
                    });
                }
                seriesGroupByCategoryAxis[key].series.push(seriesModel);
            } else {
                otherSeries.push(seriesModel);
            }
        } else {
            otherSeries.push(seriesModel);
        }
    });

    return {
        seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,
        other: otherSeries,
        meta: meta
    };
}

function assembleSeriesWithCategoryAxis(series) {
    var tables = [];
    util["i" /* each */](series, function (group, key) {
        var categoryAxis = group.categoryAxis;
        var valueAxis = group.valueAxis;
        var valueAxisDim = valueAxis.dim;

        var headers = [' '].concat(util["v" /* map */](group.series, function (series) {
            return series.name;
        }));
        var columns = [categoryAxis.model.getCategories()];
        util["i" /* each */](group.series, function (series) {
            columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {
                return val;
            }));
        });

        var lines = [headers.join(ITEM_SPLITER)];
        for (var i = 0; i < columns[0].length; i++) {
            var items = [];
            for (var j = 0; j < columns.length; j++) {
                items.push(columns[j][i]);
            }
            lines.push(items.join(ITEM_SPLITER));
        }
        tables.push(lines.join('\n'));
    });
    return tables.join('\n\n' + BLOCK_SPLITER + '\n\n');
}

function assembleOtherSeries(series) {
    return util["v" /* map */](series, function (series) {
        var data = series.getRawData();
        var lines = [series.name];
        var vals = [];
        data.each(data.dimensions, function () {
            var argLen = arguments.length;
            var dataIndex = arguments[argLen - 1];
            var name = data.getName(dataIndex);
            for (var i = 0; i < argLen - 1; i++) {
                vals[i] = arguments[i];
            }
            lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));
        });
        return lines.join('\n');
    }).join('\n\n' + BLOCK_SPLITER + '\n\n');
}

function getContentFromModel(ecModel) {

    var result = groupSeries(ecModel);

    return {
        value: util["l" /* filter */]([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {
            return str.replace(/[\n\t\s]/g, '');
        }).join('\n\n' + BLOCK_SPLITER + '\n\n'),

        meta: result.meta
    };
}

function trim(str) {
    return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}

function isTSVFormat(block) {
    var firstLine = block.slice(0, block.indexOf('\n'));
    if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
        return true;
    }
}

var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');

function parseTSVContents(tsv) {
    var tsvLines = tsv.split(/\n+/g);
    var headers = trim(tsvLines.shift()).split(itemSplitRegex);

    var categories = [];
    var series = util["v" /* map */](headers, function (header) {
        return {
            name: header,
            data: []
        };
    });
    for (var i = 0; i < tsvLines.length; i++) {
        var items = trim(tsvLines[i]).split(itemSplitRegex);
        categories.push(items.shift());
        for (var j = 0; j < items.length; j++) {
            series[j] && (series[j].data[i] = items[j]);
        }
    }
    return {
        series: series,
        categories: categories
    };
}

function parseListContents(str) {
    var lines = str.split(/\n+/g);
    var seriesName = trim(lines.shift());

    var data = [];
    for (var i = 0; i < lines.length; i++) {
        var items = trim(lines[i]).split(itemSplitRegex);
        var name = '';
        var value;
        var hasName = false;
        if (isNaN(items[0])) {
            hasName = true;
            name = items[0];
            items = items.slice(1);
            data[i] = {
                name: name,
                value: []
            };
            value = data[i].value;
        } else {
            value = data[i] = [];
        }
        for (var j = 0; j < items.length; j++) {
            value.push(+items[j]);
        }
        if (value.length === 1) {
            hasName ? data[i].value = value[0] : data[i] = value[0];
        }
    }

    return {
        name: seriesName,
        data: data
    };
}

function parseContents(str, blockMetaList) {
    var blocks = str.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g'));
    var newOption = {
        series: []
    };
    util["i" /* each */](blocks, function (block, idx) {
        if (isTSVFormat(block)) {
            var result = parseTSVContents(block);
            var blockMeta = blockMetaList[idx];
            var axisKey = blockMeta.axisDim + 'Axis';

            if (blockMeta) {
                newOption[axisKey] = newOption[axisKey] || [];
                newOption[axisKey][blockMeta.axisIndex] = {
                    data: result.categories
                };
                newOption.series = newOption.series.concat(result.series);
            }
        } else {
            var result = parseListContents(block);
            newOption.series.push(result);
        }
    });
    return newOption;
}

function DataView(model) {

    this._dom = null;

    this.model = model;
}

DataView.defaultOption = {
    show: true,
    readOnly: false,
    optionToContent: null,
    contentToOption: null,

    icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
    title: util["d" /* clone */](dataViewLang.title),
    lang: util["d" /* clone */](dataViewLang.lang),
    backgroundColor: '#fff',
    textColor: '#000',
    textareaColor: '#fff',
    textareaBorderColor: '#333',
    buttonColor: '#c23531',
    buttonTextColor: '#fff'
};

DataView.prototype.onclick = function (ecModel, api) {
    var container = api.getDom();
    var model = this.model;
    if (this._dom) {
        container.removeChild(this._dom);
    }
    var root = document.createElement('div');
    root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';
    root.style.backgroundColor = model.get('backgroundColor') || '#fff';

    var header = document.createElement('h4');
    var lang = model.get('lang') || [];
    header.innerHTML = lang[0] || model.get('title');
    header.style.cssText = 'margin: 10px 20px;';
    header.style.color = model.get('textColor');

    var viewMain = document.createElement('div');
    var textarea = document.createElement('textarea');
    viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';

    var optionToContent = model.get('optionToContent');
    var contentToOption = model.get('contentToOption');
    var result = getContentFromModel(ecModel);
    if (typeof optionToContent === 'function') {
        var htmlOrDom = optionToContent(api.getOption());
        if (typeof htmlOrDom === 'string') {
            viewMain.innerHTML = htmlOrDom;
        } else if (util["r" /* isDom */](htmlOrDom)) {
            viewMain.appendChild(htmlOrDom);
        }
    } else {
        viewMain.appendChild(textarea);
        textarea.readOnly = model.get('readOnly');
        textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';
        textarea.style.color = model.get('textColor');
        textarea.style.borderColor = model.get('textareaBorderColor');
        textarea.style.backgroundColor = model.get('textareaColor');
        textarea.value = result.value;
    }

    var blockMetaList = result.meta;

    var buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';

    var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';
    var closeButton = document.createElement('div');
    var refreshButton = document.createElement('div');

    buttonStyle += ';background-color:' + model.get('buttonColor');
    buttonStyle += ';color:' + model.get('buttonTextColor');

    var self = this;

    function close() {
        container.removeChild(root);
        self._dom = null;
    }
    addEventListener(closeButton, 'click', close);

    addEventListener(refreshButton, 'click', function () {
        var newOption;
        try {
            if (typeof contentToOption === 'function') {
                newOption = contentToOption(viewMain, api.getOption());
            } else {
                newOption = parseContents(textarea.value, blockMetaList);
            }
        } catch (e) {
            close();
            throw new Error('Data view format error ' + e);
        }
        if (newOption) {
            api.dispatchAction({
                type: 'changeDataView',
                newOption: newOption
            });
        }

        close();
    });

    closeButton.innerHTML = lang[1];
    refreshButton.innerHTML = lang[2];
    refreshButton.style.cssText = buttonStyle;
    closeButton.style.cssText = buttonStyle;

    !model.get('readOnly') && buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(closeButton);

    addEventListener(textarea, 'keydown', function (e) {
        if ((e.keyCode || e.which) === 9) {
            var val = this.value;
            var start = this.selectionStart;
            var end = this.selectionEnd;

            this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);

            this.selectionStart = this.selectionEnd = start + 1;

            stop(e);
        }
    });

    root.appendChild(header);
    root.appendChild(viewMain);
    root.appendChild(buttonContainer);

    viewMain.style.height = container.clientHeight - 80 + 'px';

    container.appendChild(root);
    this._dom = root;
};

DataView.prototype.remove = function (ecModel, api) {
    this._dom && api.getDom().removeChild(this._dom);
};

DataView.prototype.dispose = function (ecModel, api) {
    this.remove(ecModel, api);
};

function tryMergeDataOption(newData, originalData) {
    return util["v" /* map */](newData, function (newVal, idx) {
        var original = originalData && originalData[idx];
        if (util["t" /* isObject */](original) && !util["p" /* isArray */](original)) {
            if (util["t" /* isObject */](newVal) && !util["p" /* isArray */](newVal)) {
                newVal = newVal.value;
            }

            return util["h" /* defaults */]({
                value: newVal
            }, original);
        } else {
            return newVal;
        }
    });
}

featureManager_register('dataView', DataView);

registerAction({
    type: 'changeDataView',
    event: 'dataViewChanged',
    update: 'prepareAndUpdate'
}, function (payload, ecModel) {
    var newSeriesOptList = [];
    util["i" /* each */](payload.newOption.series, function (seriesOpt) {
        var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
        if (!seriesModel) {
            newSeriesOptList.push(util["k" /* extend */]({
                type: 'scatter'
            }, seriesOpt));
        } else {
            var originalData = seriesModel.get('data');
            newSeriesOptList.push({
                name: seriesOpt.name,
                data: tryMergeDataOption(seriesOpt.data, originalData)
            });
        }
    });

    ecModel.mergeOption(util["h" /* defaults */]({
        series: newSeriesOptList
    }, payload.newOption));
});

/* harmony default export */ var feature_DataView = (DataView);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/helper/interactionMutex.js


var ATTR = '\0_ec_interaction_mutex';

function take(zr, resourceKey, userKey) {
    var store = getStore(zr);
    store[resourceKey] = userKey;
}

function release(zr, resourceKey, userKey) {
    var store = getStore(zr);
    var uKey = store[resourceKey];

    if (uKey === userKey) {
        store[resourceKey] = null;
    }
}

function isTaken(zr, resourceKey) {
    return !!getStore(zr)[resourceKey];
}

function getStore(zr) {
    return zr[ATTR] || (zr[ATTR] = {});
}

registerAction({ type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update' }, function () {});
// CONCATENATED MODULE: ./node_modules/echarts/src/component/helper/BrushController.js






var BrushController_curry = util["g" /* curry */];
var BrushController_each = util["i" /* each */];
var BrushController_map = util["v" /* map */];
var BrushController_mathMin = Math.min;
var BrushController_mathMax = Math.max;
var BrushController_mathPow = Math.pow;

var COVER_Z = 10000;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = 'globalPan';

var DIRECTION_MAP = {
    w: [0, 0],
    e: [0, 1],
    n: [1, 0],
    s: [1, 1]
};
var CURSOR_MAP = {
    w: 'ew',
    e: 'ew',
    n: 'ns',
    s: 'ns',
    ne: 'nesw',
    sw: 'nesw',
    nw: 'nwse',
    se: 'nwse'
};
var DEFAULT_BRUSH_OPT = {
    brushStyle: {
        lineWidth: 2,
        stroke: 'rgba(0,0,0,0.3)',
        fill: 'rgba(0,0,0,0.1)'
    },
    transformable: true,
    brushMode: 'single',
    removeOnClick: false
};

var baseUID = 0;

function BrushController(zr) {

    if (false) {
        zrUtil.assert(zr);
    }

    Eventful["a" /* default */].call(this);

    this._zr = zr;

    this.group = new graphic["Group"]();

    this._brushType;

    this._brushOption;

    this._panels;

    this._track = [];

    this._dragging;

    this._covers = [];

    this._creatingCover;

    this._creatingPanel;

    this._enableGlobalPan;

    if (false) {
        this._mounted;
    }

    this._uid = 'brushController_' + baseUID++;

    this._handlers = {};
    BrushController_each(mouseHandlers, function (handler, eventName) {
        this._handlers[eventName] = util["c" /* bind */](handler, this);
    }, this);
}

BrushController.prototype = {

    constructor: BrushController,

    enableBrush: function enableBrush(brushOption) {
        if (false) {
            zrUtil.assert(this._mounted);
        }

        this._brushType && doDisableBrush(this);
        brushOption.brushType && doEnableBrush(this, brushOption);

        return this;
    },

    setPanels: function setPanels(panelOpts) {
        if (panelOpts && panelOpts.length) {
            var panels = this._panels = {};
            util["i" /* each */](panelOpts, function (panelOpts) {
                panels[panelOpts.panelId] = util["d" /* clone */](panelOpts);
            });
        } else {
            this._panels = null;
        }
        return this;
    },

    mount: function mount(opt) {
        opt = opt || {};

        if (false) {
            this._mounted = true;
        }

        this._enableGlobalPan = opt.enableGlobalPan;

        var thisGroup = this.group;
        this._zr.add(thisGroup);

        thisGroup.attr({
            position: opt.position || [0, 0],
            rotation: opt.rotation || 0,
            scale: opt.scale || [1, 1]
        });
        this._transform = thisGroup.getLocalTransform();

        return this;
    },

    eachCover: function eachCover(cb, context) {
        BrushController_each(this._covers, cb, context);
    },

    updateCovers: function updateCovers(brushOptionList) {
        if (false) {
            zrUtil.assert(this._mounted);
        }

        brushOptionList = util["v" /* map */](brushOptionList, function (brushOption) {
            return util["w" /* merge */](util["d" /* clone */](DEFAULT_BRUSH_OPT), brushOption, true);
        });

        var tmpIdPrefix = '\0-brush-index-';
        var oldCovers = this._covers;
        var newCovers = this._covers = [];
        var controller = this;
        var creatingCover = this._creatingCover;

        new DataDiffer["a" /* default */](oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();

        return this;

        function getKey(brushOption, index) {
            return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;
        }

        function oldGetKey(cover, index) {
            return getKey(cover.__brushOption, index);
        }

        function addOrUpdate(newIndex, oldIndex) {
            var newBrushOption = brushOptionList[newIndex];

            if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
                newCovers[newIndex] = oldCovers[oldIndex];
            } else {
                var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : BrushController_endCreating(controller, BrushController_createCover(controller, newBrushOption));
                updateCoverAfterCreation(controller, cover);
            }
        }

        function remove(oldIndex) {
            if (oldCovers[oldIndex] !== creatingCover) {
                controller.group.remove(oldCovers[oldIndex]);
            }
        }
    },

    unmount: function unmount() {
        if (false) {
            if (!this._mounted) {
                return;
            }
        }

        this.enableBrush(false);

        clearCovers(this);
        this._zr.remove(this.group);

        if (false) {
            this._mounted = false;
        }

        return this;
    },

    dispose: function dispose() {
        this.unmount();
        this.off();
    }
};

util["y" /* mixin */](BrushController, Eventful["a" /* default */]);

function doEnableBrush(controller, brushOption) {
    var zr = controller._zr;

    if (!controller._enableGlobalPan) {
        take(zr, MUTEX_RESOURCE_KEY, controller._uid);
    }

    BrushController_each(controller._handlers, function (handler, eventName) {
        zr.on(eventName, handler);
    });

    controller._brushType = brushOption.brushType;
    controller._brushOption = util["w" /* merge */](util["d" /* clone */](DEFAULT_BRUSH_OPT), brushOption, true);
}

function doDisableBrush(controller) {
    var zr = controller._zr;

    release(zr, MUTEX_RESOURCE_KEY, controller._uid);

    BrushController_each(controller._handlers, function (handler, eventName) {
        zr.off(eventName, handler);
    });

    controller._brushType = controller._brushOption = null;
}

function BrushController_createCover(controller, brushOption) {
    var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
    cover.__brushOption = brushOption;
    BrushController_updateZ(cover, brushOption);
    controller.group.add(cover);
    return cover;
}

function BrushController_endCreating(controller, creatingCover) {
    var coverRenderer = getCoverRenderer(creatingCover);
    if (coverRenderer.endCreating) {
        coverRenderer.endCreating(controller, creatingCover);
        BrushController_updateZ(creatingCover, creatingCover.__brushOption);
    }
    return creatingCover;
}

function updateCoverShape(controller, cover) {
    var brushOption = cover.__brushOption;
    getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}

function BrushController_updateZ(cover, brushOption) {
    var z = brushOption.z;
    z == null && (z = COVER_Z);
    cover.traverse(function (el) {
        el.z = z;
        el.z2 = z;
    });
}

function updateCoverAfterCreation(controller, cover) {
    getCoverRenderer(cover).updateCommon(controller, cover);
    updateCoverShape(controller, cover);
}

function getCoverRenderer(cover) {
    return coverRenderers[cover.__brushOption.brushType];
}

function getPanelByPoint(controller, e, localCursorPoint) {
    var panels = controller._panels;
    if (!panels) {
        return true;
    }
    var panel;
    var transform = controller._transform;
    BrushController_each(panels, function (pn) {
        pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);
    });
    return panel;
}

function getPanelByCover(controller, cover) {
    var panels = controller._panels;
    if (!panels) {
        return true;
    }
    var panelId = cover.__brushOption.panelId;

    return panelId != null ? panels[panelId] : true;
}

function clearCovers(controller) {
    var covers = controller._covers;
    var originalLength = covers.length;
    BrushController_each(covers, function (cover) {
        controller.group.remove(cover);
    }, controller);
    covers.length = 0;

    return !!originalLength;
}

function trigger(controller, opt) {
    var areas = BrushController_map(controller._covers, function (cover) {
        var brushOption = cover.__brushOption;
        var range = util["d" /* clone */](brushOption.range);
        return {
            brushType: brushOption.brushType,
            panelId: brushOption.panelId,
            range: range
        };
    });

    controller.trigger('brush', areas, {
        isEnd: !!opt.isEnd,
        removeOnClick: !!opt.removeOnClick
    });
}

function shouldShowCover(controller) {
    var track = controller._track;

    if (!track.length) {
        return false;
    }

    var p2 = track[track.length - 1];
    var p1 = track[0];
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var dist = BrushController_mathPow(dx * dx + dy * dy, 0.5);

    return dist > UNSELECT_THRESHOLD;
}

function getTrackEnds(track) {
    var tail = track.length - 1;
    tail < 0 && (tail = 0);
    return [track[0], track[tail]];
}

function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
    var cover = new graphic["Group"]();

    cover.add(new graphic["Rect"]({
        name: 'main',
        style: makeStyle(brushOption),
        silent: true,
        draggable: true,
        cursor: 'move',
        drift: BrushController_curry(doDrift, controller, cover, 'nswe'),
        ondragend: BrushController_curry(trigger, controller, { isEnd: true })
    }));

    BrushController_each(edgeNames, function (name) {
        cover.add(new graphic["Rect"]({
            name: name,
            style: { opacity: 0 },
            draggable: true,
            silent: true,
            invisible: true,
            drift: BrushController_curry(doDrift, controller, cover, name),
            ondragend: BrushController_curry(trigger, controller, { isEnd: true })
        }));
    });

    return cover;
}

function updateBaseRect(controller, cover, localRange, brushOption) {
    var lineWidth = brushOption.brushStyle.lineWidth || 0;
    var handleSize = BrushController_mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
    var x = localRange[0][0];
    var y = localRange[1][0];
    var xa = x - lineWidth / 2;
    var ya = y - lineWidth / 2;
    var x2 = localRange[0][1];
    var y2 = localRange[1][1];
    var x2a = x2 - handleSize + lineWidth / 2;
    var y2a = y2 - handleSize + lineWidth / 2;
    var width = x2 - x;
    var height = y2 - y;
    var widtha = width + lineWidth;
    var heighta = height + lineWidth;

    updateRectShape(controller, cover, 'main', x, y, width, height);

    if (brushOption.transformable) {
        updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);
        updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);
        updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);
        updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);

        updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);
        updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);
        updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);
        updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);
    }
}

function updateCommon(controller, cover) {
    var brushOption = cover.__brushOption;
    var transformable = brushOption.transformable;

    var mainEl = cover.childAt(0);
    mainEl.useStyle(makeStyle(brushOption));
    mainEl.attr({
        silent: !transformable,
        cursor: transformable ? 'move' : 'default'
    });

    BrushController_each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {
        var el = cover.childOfName(name);
        var globalDir = getGlobalDirection(controller, name);

        el && el.attr({
            silent: !transformable,
            invisible: !transformable,
            cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null
        });
    });
}

function updateRectShape(controller, cover, name, x, y, w, h) {
    var el = cover.childOfName(name);
    el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
}

function makeStyle(brushOption) {
    return util["h" /* defaults */]({ strokeNoScale: true }, brushOption.brushStyle);
}

function formatRectRange(x, y, x2, y2) {
    var min = [BrushController_mathMin(x, x2), BrushController_mathMin(y, y2)];
    var max = [BrushController_mathMax(x, x2), BrushController_mathMax(y, y2)];

    return [[min[0], max[0]], [min[1], max[1]]];
}

function getTransform(controller) {
    return graphic["getTransform"](controller.group);
}

function getGlobalDirection(controller, localDirection) {
    if (localDirection.length > 1) {
        localDirection = localDirection.split('');
        var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];
        (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();
        return globalDir.join('');
    } else {
        var map = { w: 'left', e: 'right', n: 'top', s: 'bottom' };
        var inverseMap = { left: 'w', right: 'e', top: 'n', bottom: 's' };
        var globalDir = graphic["transformDirection"](map[localDirection], getTransform(controller));
        return inverseMap[globalDir];
    }
}

function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {
    var brushOption = cover.__brushOption;
    var rectRange = toRectRange(brushOption.range);
    var localDelta = toLocalDelta(controller, dx, dy);

    BrushController_each(name.split(''), function (namePart) {
        var ind = DIRECTION_MAP[namePart];
        rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
    });

    brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));

    updateCoverAfterCreation(controller, cover);
    trigger(controller, { isEnd: false });
}

function driftPolygon(controller, cover, dx, dy, e) {
    var range = cover.__brushOption.range;
    var localDelta = toLocalDelta(controller, dx, dy);

    BrushController_each(range, function (point) {
        point[0] += localDelta[0];
        point[1] += localDelta[1];
    });

    updateCoverAfterCreation(controller, cover);
    trigger(controller, { isEnd: false });
}

function toLocalDelta(controller, dx, dy) {
    var thisGroup = controller.group;
    var localD = thisGroup.transformCoordToLocal(dx, dy);
    var localZero = thisGroup.transformCoordToLocal(0, 0);

    return [localD[0] - localZero[0], localD[1] - localZero[1]];
}

function clipByPanel(controller, cover, data) {
    var panel = getPanelByCover(controller, cover);

    return panel && panel !== true ? panel.clipPath(data, controller._transform) : util["d" /* clone */](data);
}

function pointsToRect(points) {
    var xmin = BrushController_mathMin(points[0][0], points[1][0]);
    var ymin = BrushController_mathMin(points[0][1], points[1][1]);
    var xmax = BrushController_mathMax(points[0][0], points[1][0]);
    var ymax = BrushController_mathMax(points[0][1], points[1][1]);

    return {
        x: xmin,
        y: ymin,
        width: xmax - xmin,
        height: ymax - ymin
    };
}

function resetCursor(controller, e, localCursorPoint) {
    if (!controller._brushType) {
        return;
    }

    var zr = controller._zr;
    var covers = controller._covers;
    var currPanel = getPanelByPoint(controller, e, localCursorPoint);

    if (!controller._dragging) {
        for (var i = 0; i < covers.length; i++) {
            var brushOption = covers[i].__brushOption;
            if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
                return;
            }
        }
    }

    currPanel && zr.setCursorStyle('crosshair');
}

function preventDefault(e) {
    var rawE = e.event;
    rawE.preventDefault && rawE.preventDefault();
}

function mainShapeContain(cover, x, y) {
    return cover.childOfName('main').contain(x, y);
}

function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {
    var creatingCover = controller._creatingCover;
    var panel = controller._creatingPanel;
    var thisBrushOption = controller._brushOption;
    var eventParams;

    controller._track.push(localCursorPoint.slice());

    if (shouldShowCover(controller) || creatingCover) {

        if (panel && !creatingCover) {
            thisBrushOption.brushMode === 'single' && clearCovers(controller);
            var brushOption = util["d" /* clone */](thisBrushOption);
            brushOption.brushType = determineBrushType(brushOption.brushType, panel);
            brushOption.panelId = panel === true ? null : panel.panelId;
            creatingCover = controller._creatingCover = BrushController_createCover(controller, brushOption);
            controller._covers.push(creatingCover);
        }

        if (creatingCover) {
            var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
            var coverBrushOption = creatingCover.__brushOption;

            coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));

            if (isEnd) {
                BrushController_endCreating(controller, creatingCover);
                coverRenderer.updateCommon(controller, creatingCover);
            }

            updateCoverShape(controller, creatingCover);

            eventParams = { isEnd: isEnd };
        }
    } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {
        if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {
            eventParams = { isEnd: isEnd, removeOnClick: true };
        }
    }

    return eventParams;
}

function determineBrushType(brushType, panel) {
    if (brushType === 'auto') {
        if (false) {
            zrUtil.assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"');
        }
        return panel.defaultBrushType;
    }
    return brushType;
}

var mouseHandlers = {

    mousedown: function mousedown(e) {
        if (this._dragging) {
            handleDragEnd.call(this, e);
        } else if (!e.target || !e.target.draggable) {

            preventDefault(e);

            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);

            this._creatingCover = null;
            var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);

            if (panel) {
                this._dragging = true;
                this._track = [localCursorPoint.slice()];
            }
        }
    },

    mousemove: function mousemove(e) {
        var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);

        resetCursor(this, e, localCursorPoint);

        if (this._dragging) {

            preventDefault(e);

            var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);

            eventParams && trigger(this, eventParams);
        }
    },

    mouseup: handleDragEnd };

function handleDragEnd(e) {
    if (this._dragging) {

        preventDefault(e);

        var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
        var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);

        this._dragging = false;
        this._track = [];
        this._creatingCover = null;

        eventParams && trigger(this, eventParams);
    }
}

var coverRenderers = {

    lineX: getLineRenderer(0),

    lineY: getLineRenderer(1),

    rect: {
        createCover: function createCover(controller, brushOption) {
            return createBaseRectCover(BrushController_curry(driftRect, function (range) {
                return range;
            }, function (range) {
                return range;
            }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);
        },
        getCreatingRange: function getCreatingRange(localTrack) {
            var ends = getTrackEnds(localTrack);
            return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
        },
        updateCoverShape: function updateCoverShape(controller, cover, localRange, brushOption) {
            updateBaseRect(controller, cover, localRange, brushOption);
        },
        updateCommon: updateCommon,
        contain: mainShapeContain
    },

    polygon: {
        createCover: function createCover(controller, brushOption) {
            var cover = new graphic["Group"]();

            cover.add(new graphic["Polyline"]({
                name: 'main',
                style: makeStyle(brushOption),
                silent: true
            }));

            return cover;
        },
        getCreatingRange: function getCreatingRange(localTrack) {
            return localTrack;
        },
        endCreating: function endCreating(controller, cover) {
            cover.remove(cover.childAt(0));

            cover.add(new graphic["Polygon"]({
                name: 'main',
                draggable: true,
                drift: BrushController_curry(driftPolygon, controller, cover),
                ondragend: BrushController_curry(trigger, controller, { isEnd: true })
            }));
        },
        updateCoverShape: function updateCoverShape(controller, cover, localRange, brushOption) {
            cover.childAt(0).setShape({
                points: clipByPanel(controller, cover, localRange)
            });
        },
        updateCommon: updateCommon,
        contain: mainShapeContain
    }
};

function getLineRenderer(xyIndex) {
    return {
        createCover: function createCover(controller, brushOption) {
            return createBaseRectCover(BrushController_curry(driftRect, function (range) {
                var rectRange = [range, [0, 100]];
                xyIndex && rectRange.reverse();
                return rectRange;
            }, function (rectRange) {
                return rectRange[xyIndex];
            }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);
        },
        getCreatingRange: function getCreatingRange(localTrack) {
            var ends = getTrackEnds(localTrack);
            var min = BrushController_mathMin(ends[0][xyIndex], ends[1][xyIndex]);
            var max = BrushController_mathMax(ends[0][xyIndex], ends[1][xyIndex]);

            return [min, max];
        },
        updateCoverShape: function updateCoverShape(controller, cover, localRange, brushOption) {
            var otherExtent;

            var panel = getPanelByCover(controller, cover);
            if (panel !== true && panel.getLinearBrushOtherExtent) {
                otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);
            } else {
                var zr = controller._zr;
                otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
            }
            var rectRange = [localRange, otherExtent];
            xyIndex && rectRange.reverse();

            updateBaseRect(controller, cover, rectRange, brushOption);
        },
        updateCommon: updateCommon,
        contain: mainShapeContain
    };
}

/* harmony default export */ var helper_BrushController = (BrushController);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/helper/cursorHelper.js

var IRRELEVANT_EXCLUDES = { 'axisPointer': 1, 'tooltip': 1, 'brush': 1 };

function onIrrelevantElement(e, api, targetCoordSysModel) {
    var model = api.getComponentByElement(e.topTarget);

    var coordSys = model && model.coordinateSystem;
    return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/helper/brushHelper.js




function makeRectPanelClipPath(rect) {
    rect = normalizeRect(rect);
    return function (localPoints, transform) {
        return graphic["clipPointsByRect"](localPoints, rect);
    };
}

function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
    rect = normalizeRect(rect);
    return function (xyIndex) {
        var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
        var brushWidth = idx ? rect.width : rect.height;
        var base = idx ? rect.x : rect.y;
        return [base, base + (brushWidth || 0)];
    };
}

function makeRectIsTargetByCursor(rect, api, targetModel) {
    rect = normalizeRect(rect);
    return function (e, localCursorPoint, transform) {
        return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);
    };
}

function normalizeRect(rect) {
    return BoundingRect["a" /* default */].create(rect);
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/helper/BrushTargetManager.js





var BrushTargetManager_each = util["i" /* each */];
var BrushTargetManager_indexOf = util["n" /* indexOf */];
var BrushTargetManager_curry = util["g" /* curry */];

var COORD_CONVERTS = ['dataToPoint', 'pointToData'];

var INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];

function BrushTargetManager(option, ecModel, opt) {
    var targetInfoList = this._targetInfoList = [];
    var info = {};
    var foundCpts = parseFinder(ecModel, option);

    BrushTargetManager_each(targetInfoBuilders, function (builder, type) {
        if (!opt || !opt.include || BrushTargetManager_indexOf(opt.include, type) >= 0) {
            builder(foundCpts, targetInfoList, info);
        }
    });
}

var BrushTargetManager_proto = BrushTargetManager.prototype;

BrushTargetManager_proto.setOutputRanges = function (areas, ecModel) {
    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
        (area.coordRanges || (area.coordRanges = [])).push(coordRange);

        if (!area.coordRange) {
            area.coordRange = coordRange;

            var result = coordConvert[area.brushType](0, coordSys, coordRange);
            area.__rangeOffset = {
                offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
                xyMinMax: result.xyMinMax
            };
        }
    });
};

BrushTargetManager_proto.matchOutputRanges = function (areas, ecModel, cb) {
    BrushTargetManager_each(areas, function (area) {
        var targetInfo = this.findTargetInfo(area, ecModel);

        if (targetInfo && targetInfo !== true) {
            util["i" /* each */](targetInfo.coordSyses, function (coordSys) {
                var result = coordConvert[area.brushType](1, coordSys, area.range);
                cb(area, result.values, coordSys, ecModel);
            });
        }
    }, this);
};

BrushTargetManager_proto.setInputRanges = function (areas, ecModel) {
    BrushTargetManager_each(areas, function (area) {
        var targetInfo = this.findTargetInfo(area, ecModel);

        if (false) {
            zrUtil.assert(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');
            zrUtil.assert(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');
        }

        area.range = area.range || [];

        if (targetInfo && targetInfo !== true) {
            area.panelId = targetInfo.panelId;

            var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
            var rangeOffset = area.__rangeOffset;
            area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
        }
    }, this);
};

BrushTargetManager_proto.makePanelOpts = function (api, getDefaultBrushType) {
    return util["v" /* map */](this._targetInfoList, function (targetInfo) {
        var rect = targetInfo.getPanelRect();
        return {
            panelId: targetInfo.panelId,
            defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),
            clipPath: makeRectPanelClipPath(rect),
            isTargetByCursor: makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
            getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)
        };
    });
};

BrushTargetManager_proto.controlSeries = function (area, seriesModel, ecModel) {
    var targetInfo = this.findTargetInfo(area, ecModel);
    return targetInfo === true || targetInfo && BrushTargetManager_indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
};

BrushTargetManager_proto.findTargetInfo = function (area, ecModel) {
    var targetInfoList = this._targetInfoList;
    var foundCpts = parseFinder(ecModel, area);

    for (var i = 0; i < targetInfoList.length; i++) {
        var targetInfo = targetInfoList[i];
        var areaPanelId = area.panelId;
        if (areaPanelId) {
            if (targetInfo.panelId === areaPanelId) {
                return targetInfo;
            }
        } else {
            for (var i = 0; i < targetInfoMatchers.length; i++) {
                if (targetInfoMatchers[i](foundCpts, targetInfo)) {
                    return targetInfo;
                }
            }
        }
    }

    return true;
};

function formatMinMax(minMax) {
    minMax[0] > minMax[1] && minMax.reverse();
    return minMax;
}

function parseFinder(ecModel, option) {
    return util_model["o" /* parseFinder */](ecModel, option, { includeMainTypes: INCLUDE_FINDER_MAIN_TYPES });
}

var targetInfoBuilders = {

    grid: function grid(foundCpts, targetInfoList) {
        var xAxisModels = foundCpts.xAxisModels;
        var yAxisModels = foundCpts.yAxisModels;
        var gridModels = foundCpts.gridModels;

        var gridModelMap = util["f" /* createHashMap */]();
        var xAxesHas = {};
        var yAxesHas = {};

        if (!xAxisModels && !yAxisModels && !gridModels) {
            return;
        }

        BrushTargetManager_each(xAxisModels, function (axisModel) {
            var gridModel = axisModel.axis.grid.model;
            gridModelMap.set(gridModel.id, gridModel);
            xAxesHas[gridModel.id] = true;
        });
        BrushTargetManager_each(yAxisModels, function (axisModel) {
            var gridModel = axisModel.axis.grid.model;
            gridModelMap.set(gridModel.id, gridModel);
            yAxesHas[gridModel.id] = true;
        });
        BrushTargetManager_each(gridModels, function (gridModel) {
            gridModelMap.set(gridModel.id, gridModel);
            xAxesHas[gridModel.id] = true;
            yAxesHas[gridModel.id] = true;
        });

        gridModelMap.each(function (gridModel) {
            var grid = gridModel.coordinateSystem;
            var cartesians = [];

            BrushTargetManager_each(grid.getCartesians(), function (cartesian, index) {
                if (BrushTargetManager_indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || BrushTargetManager_indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {
                    cartesians.push(cartesian);
                }
            });
            targetInfoList.push({
                panelId: 'grid--' + gridModel.id,
                gridModel: gridModel,
                coordSysModel: gridModel,

                coordSys: cartesians[0],
                coordSyses: cartesians,
                getPanelRect: panelRectBuilder.grid,
                xAxisDeclared: xAxesHas[gridModel.id],
                yAxisDeclared: yAxesHas[gridModel.id]
            });
        });
    },

    geo: function geo(foundCpts, targetInfoList) {
        BrushTargetManager_each(foundCpts.geoModels, function (geoModel) {
            var coordSys = geoModel.coordinateSystem;
            targetInfoList.push({
                panelId: 'geo--' + geoModel.id,
                geoModel: geoModel,
                coordSysModel: geoModel,
                coordSys: coordSys,
                coordSyses: [coordSys],
                getPanelRect: panelRectBuilder.geo
            });
        });
    }
};

var targetInfoMatchers = [function (foundCpts, targetInfo) {
    var xAxisModel = foundCpts.xAxisModel;
    var yAxisModel = foundCpts.yAxisModel;
    var gridModel = foundCpts.gridModel;

    !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
    !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);

    return gridModel && gridModel === targetInfo.gridModel;
}, function (foundCpts, targetInfo) {
    var geoModel = foundCpts.geoModel;
    return geoModel && geoModel === targetInfo.geoModel;
}];

var panelRectBuilder = {

    grid: function grid() {
        return this.coordSys.grid.getRect().clone();
    },

    geo: function geo() {
        var coordSys = this.coordSys;
        var rect = coordSys.getBoundingRect().clone();

        rect.applyTransform(graphic["getTransform"](coordSys));
        return rect;
    }
};

var coordConvert = {

    lineX: BrushTargetManager_curry(axisConvert, 0),

    lineY: BrushTargetManager_curry(axisConvert, 1),

    rect: function rect(to, coordSys, rangeOrCoordRange) {
        var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);
        var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);
        var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
        return { values: values, xyMinMax: values };
    },

    polygon: function polygon(to, coordSys, rangeOrCoordRange) {
        var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
        var values = util["v" /* map */](rangeOrCoordRange, function (item) {
            var p = coordSys[COORD_CONVERTS[to]](item);
            xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
            xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
            xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
            xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
            return p;
        });
        return { values: values, xyMinMax: xyMinMax };
    }
};

function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
    if (false) {
        zrUtil.assert(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');
    }

    var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);
    var values = formatMinMax(util["v" /* map */]([0, 1], function (i) {
        return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
    }));
    var xyMinMax = [];
    xyMinMax[axisNameIndex] = values;
    xyMinMax[1 - axisNameIndex] = [NaN, NaN];

    return { values: values, xyMinMax: xyMinMax };
}

var diffProcessor = {
    lineX: BrushTargetManager_curry(axisDiffProcessor, 0),

    lineY: BrushTargetManager_curry(axisDiffProcessor, 1),

    rect: function rect(values, refer, scales) {
        return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
    },

    polygon: function polygon(values, refer, scales) {
        return util["v" /* map */](values, function (item, idx) {
            return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
        });
    }
};

function axisDiffProcessor(axisNameIndex, values, refer, scales) {
    return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
}

function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
    var sizeCurr = getSize(xyMinMaxCurr);
    var sizeOrigin = getSize(xyMinMaxOrigin);
    var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
    isNaN(scales[0]) && (scales[0] = 1);
    isNaN(scales[1]) && (scales[1] = 1);
    return scales;
}

function getSize(xyMinMax) {
    return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}

/* harmony default export */ var helper_BrushTargetManager = (BrushTargetManager);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/history.js


var history_each = util["i" /* each */];

var history_ATTR = '\0_ec_hist_store';

function push(ecModel, newSnapshot) {
    var store = giveStore(ecModel);

    history_each(newSnapshot, function (batchItem, dataZoomId) {
        var i = store.length - 1;
        for (; i >= 0; i--) {
            var snapshot = store[i];
            if (snapshot[dataZoomId]) {
                break;
            }
        }
        if (i < 0) {
            var dataZoomModel = ecModel.queryComponents({ mainType: 'dataZoom', subType: 'select', id: dataZoomId })[0];
            if (dataZoomModel) {
                var percentRange = dataZoomModel.getPercentRange();
                store[0][dataZoomId] = {
                    dataZoomId: dataZoomId,
                    start: percentRange[0],
                    end: percentRange[1]
                };
            }
        }
    });

    store.push(newSnapshot);
}

function pop(ecModel) {
    var store = giveStore(ecModel);
    var head = store[store.length - 1];
    store.length > 1 && store.pop();

    var snapshot = {};
    history_each(head, function (batchItem, dataZoomId) {
        for (var i = store.length - 1; i >= 0; i--) {
            var batchItem = store[i][dataZoomId];
            if (batchItem) {
                snapshot[dataZoomId] = batchItem;
                break;
            }
        }
    });

    return snapshot;
}

function history_clear(ecModel) {
    ecModel[history_ATTR] = null;
}

function history_count(ecModel) {
    return giveStore(ecModel).length;
}

function giveStore(ecModel) {
    var store = ecModel[history_ATTR];
    if (!store) {
        store = ecModel[history_ATTR] = [{}];
    }
    return store;
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/helper/sliderMove.js

/* harmony default export */ var sliderMove = (function (delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
    handleEnds[0] = restrict(handleEnds[0], extent);
    handleEnds[1] = restrict(handleEnds[1], extent);

    delta = delta || 0;

    var extentSpan = extent[1] - extent[0];

    if (minSpan != null) {
        minSpan = restrict(minSpan, [0, extentSpan]);
    }
    if (maxSpan != null) {
        maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
    }
    if (handleIndex === 'all') {
        minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);
        handleIndex = 0;
    }

    var originalDistSign = getSpanSign(handleEnds, handleIndex);

    handleEnds[handleIndex] += delta;

    var extentMinSpan = minSpan || 0;
    var realExtent = extent.slice();
    originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
    handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);

    var currDistSign = getSpanSign(handleEnds, handleIndex);
    if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
    }

    var currDistSign = getSpanSign(handleEnds, handleIndex);
    if (maxSpan != null && currDistSign.span > maxSpan) {
        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
    }

    return handleEnds;
});

function getSpanSign(handleEnds, handleIndex) {
    var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];

    return { span: Math.abs(dist), sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1 };
}

function restrict(value, extend) {
    return Math.min(extend[1], Math.max(extend[0], value));
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/typeDefaulter.js


model_Component.registerSubTypeDefaulter('dataZoom', function () {
    return 'slider';
});
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/helper.js



var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single'];

var COORDS = ['cartesian2d', 'polar', 'singleAxis'];

function isCoordSupported(coordType) {
    return util["n" /* indexOf */](COORDS, coordType) >= 0;
}

function createNameEach(names, attrs) {
    names = names.slice();
    var capitalNames = util["v" /* map */](names, format["b" /* capitalFirst */]);
    attrs = (attrs || []).slice();
    var capitalAttrs = util["v" /* map */](attrs, format["b" /* capitalFirst */]);

    return function (callback, context) {
        util["i" /* each */](names, function (name, index) {
            var nameObj = { name: name, capital: capitalNames[index] };

            for (var j = 0; j < attrs.length; j++) {
                nameObj[attrs[j]] = name + capitalAttrs[j];
            }

            callback.call(context, nameObj);
        });
    };
}

var eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);

function createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {

    return function (sourceNode) {
        var result = {
            nodes: [],
            records: {} };

        forEachEdgeType(function (edgeType) {
            result.records[edgeType.name] = {};
        });

        if (!sourceNode) {
            return result;
        }

        absorb(sourceNode, result);

        var existsLink;
        do {
            existsLink = false;
            forEachNode(processSingleNode);
        } while (existsLink);

        function processSingleNode(node) {
            if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
                absorb(node, result);
                existsLink = true;
            }
        }

        return result;
    };

    function isNodeAbsorded(node, result) {
        return util["n" /* indexOf */](result.nodes, node) >= 0;
    }

    function isLinked(node, result) {
        var hasLink = false;
        forEachEdgeType(function (edgeType) {
            util["i" /* each */](edgeIdGetter(node, edgeType) || [], function (edgeId) {
                result.records[edgeType.name][edgeId] && (hasLink = true);
            });
        });
        return hasLink;
    }

    function absorb(node, result) {
        result.nodes.push(node);
        forEachEdgeType(function (edgeType) {
            util["i" /* each */](edgeIdGetter(node, edgeType) || [], function (edgeId) {
                result.records[edgeType.name][edgeId] = true;
            });
        });
    }
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/AxisProxy.js




var AxisProxy_each = util["i" /* each */];
var asc = number["a" /* asc */];

var AxisProxy = function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;

    this._axisIndex = axisIndex;

    this._valueWindow;

    this._percentWindow;

    this._dataExtent;

    this._minMaxSpan;

    this.ecModel = ecModel;

    this._dataZoomModel = dataZoomModel;
};

AxisProxy.prototype = {

    constructor: AxisProxy,

    hostedBy: function hostedBy(dataZoomModel) {
        return this._dataZoomModel === dataZoomModel;
    },

    getDataValueWindow: function getDataValueWindow() {
        return this._valueWindow.slice();
    },

    getDataPercentWindow: function getDataPercentWindow() {
        return this._percentWindow.slice();
    },

    getTargetSeriesModels: function getTargetSeriesModels() {
        var seriesModels = [];
        var ecModel = this.ecModel;

        ecModel.eachSeries(function (seriesModel) {
            if (isCoordSupported(seriesModel.get('coordinateSystem'))) {
                var dimName = this._dimName;
                var axisModel = ecModel.queryComponents({
                    mainType: dimName + 'Axis',
                    index: seriesModel.get(dimName + 'AxisIndex'),
                    id: seriesModel.get(dimName + 'AxisId')
                })[0];
                if (this._axisIndex === (axisModel && axisModel.componentIndex)) {
                    seriesModels.push(seriesModel);
                }
            }
        }, this);

        return seriesModels;
    },

    getAxisModel: function getAxisModel() {
        return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);
    },

    getOtherAxisModel: function getOtherAxisModel() {
        var axisDim = this._dimName;
        var ecModel = this.ecModel;
        var axisModel = this.getAxisModel();
        var isCartesian = axisDim === 'x' || axisDim === 'y';
        var otherAxisDim;
        var coordSysIndexName;
        if (isCartesian) {
            coordSysIndexName = 'gridIndex';
            otherAxisDim = axisDim === 'x' ? 'y' : 'x';
        } else {
            coordSysIndexName = 'polarIndex';
            otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';
        }
        var foundOtherAxisModel;
        ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {
            if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
                foundOtherAxisModel = otherAxisModel;
            }
        });
        return foundOtherAxisModel;
    },

    getMinMaxSpan: function getMinMaxSpan() {
        return util["d" /* clone */](this._minMaxSpan);
    },

    calculateDataWindow: function calculateDataWindow(opt) {
        var dataExtent = this._dataExtent;
        var axisModel = this.getAxisModel();
        var scale = axisModel.axis.scale;
        var rangePropMode = this._dataZoomModel.getRangePropMode();
        var percentExtent = [0, 100];
        var percentWindow = [opt.start, opt.end];
        var valueWindow = [];

        AxisProxy_each(['startValue', 'endValue'], function (prop) {
            valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);
        });

        AxisProxy_each([0, 1], function (idx) {
            var boundValue = valueWindow[idx];
            var boundPercent = percentWindow[idx];

            if (rangePropMode[idx] === 'percent') {
                if (boundPercent == null) {
                    boundPercent = percentExtent[idx];
                }

                boundValue = scale.parse(number["e" /* linearMap */](boundPercent, percentExtent, dataExtent, true));
            } else {
                boundPercent = number["e" /* linearMap */](boundValue, dataExtent, percentExtent, true);
            }

            valueWindow[idx] = boundValue;
            percentWindow[idx] = boundPercent;
        });

        return {
            valueWindow: asc(valueWindow),
            percentWindow: asc(percentWindow)
        };
    },

    reset: function reset(dataZoomModel) {
        if (dataZoomModel !== this._dataZoomModel) {
            return;
        }

        this._dataExtent = calculateDataExtent(this, this._dimName, this.getTargetSeriesModels());

        var dataWindow = this.calculateDataWindow(dataZoomModel.option);

        this._valueWindow = dataWindow.valueWindow;
        this._percentWindow = dataWindow.percentWindow;

        setMinMaxSpan(this);

        setAxisModel(this);
    },

    restore: function restore(dataZoomModel) {
        if (dataZoomModel !== this._dataZoomModel) {
            return;
        }

        this._valueWindow = this._percentWindow = null;
        setAxisModel(this, true);
    },

    filterData: function filterData(dataZoomModel) {
        if (dataZoomModel !== this._dataZoomModel) {
            return;
        }

        var axisDim = this._dimName;
        var seriesModels = this.getTargetSeriesModels();
        var filterMode = dataZoomModel.get('filterMode');
        var valueWindow = this._valueWindow;

        if (filterMode === 'none') {
            return;
        }

        var otherAxisModel = this.getOtherAxisModel();
        if (dataZoomModel.get('$fromToolbox') && otherAxisModel && otherAxisModel.get('type') === 'category') {
            filterMode = 'empty';
        }

        AxisProxy_each(seriesModels, function (seriesModel) {
            var seriesData = seriesModel.getData();
            var dataDims = seriesModel.coordDimToDataDim(axisDim);

            if (filterMode === 'weakFilter') {
                seriesData && seriesData.filterSelf(function (dataIndex) {
                    var leftOut;
                    var rightOut;
                    var hasValue;
                    for (var i = 0; i < dataDims.length; i++) {
                        var value = seriesData.get(dataDims[i], dataIndex);
                        var thisHasValue = !isNaN(value);
                        var thisLeftOut = value < valueWindow[0];
                        var thisRightOut = value > valueWindow[1];
                        if (thisHasValue && !thisLeftOut && !thisRightOut) {
                            return true;
                        }
                        thisHasValue && (hasValue = true);
                        thisLeftOut && (leftOut = true);
                        thisRightOut && (rightOut = true);
                    }

                    return hasValue && leftOut && rightOut;
                });
            } else {
                seriesData && AxisProxy_each(dataDims, function (dim) {
                    if (filterMode === 'empty') {
                        seriesModel.setData(seriesData.map(dim, function (value) {
                            return !isInWindow(value) ? NaN : value;
                        }));
                    } else {
                        seriesData.filterSelf(dim, isInWindow);
                    }
                });
            }
        });

        function isInWindow(value) {
            return value >= valueWindow[0] && value <= valueWindow[1];
        }
    }
};

function calculateDataExtent(axisProxy, axisDim, seriesModels) {
    var dataExtent = [Infinity, -Infinity];

    AxisProxy_each(seriesModels, function (seriesModel) {
        var seriesData = seriesModel.getData();
        if (seriesData) {
            AxisProxy_each(seriesModel.coordDimToDataDim(axisDim), function (dim) {
                var seriesExtent = seriesData.getDataExtent(dim);
                seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
                seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
            });
        }
    });

    if (dataExtent[1] < dataExtent[0]) {
        dataExtent = [NaN, NaN];
    }

    fixExtentByAxis(axisProxy, dataExtent);

    return dataExtent;
}

function fixExtentByAxis(axisProxy, dataExtent) {
    var axisModel = axisProxy.getAxisModel();
    var min = axisModel.getMin(true);

    var isCategoryAxis = axisModel.get('type') === 'category';
    var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;

    if (min != null && min !== 'dataMin' && typeof min !== 'function') {
        dataExtent[0] = min;
    } else if (isCategoryAxis) {
        dataExtent[0] = axisDataLen > 0 ? 0 : NaN;
    }

    var max = axisModel.getMax(true);
    if (max != null && max !== 'dataMax' && typeof max !== 'function') {
        dataExtent[1] = max;
    } else if (isCategoryAxis) {
        dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;
    }

    if (!axisModel.get('scale', true)) {
        dataExtent[0] > 0 && (dataExtent[0] = 0);
        dataExtent[1] < 0 && (dataExtent[1] = 0);
    }

    return dataExtent;
}

function setAxisModel(axisProxy, isRestore) {
    var axisModel = axisProxy.getAxisModel();

    var percentWindow = axisProxy._percentWindow;
    var valueWindow = axisProxy._valueWindow;

    if (!percentWindow) {
        return;
    }

    var precision = number["b" /* getPixelPrecision */](valueWindow, [0, 500]);
    precision = Math.min(precision, 20);

    var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;

    axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
}

function setMinMaxSpan(axisProxy) {
    var minMaxSpan = axisProxy._minMaxSpan = {};
    var dataZoomModel = axisProxy._dataZoomModel;

    AxisProxy_each(['min', 'max'], function (minMax) {
        minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span');

        var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');

        if (valueSpan != null) {
            minMaxSpan[minMax + 'ValueSpan'] = valueSpan;
            valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);

            if (valueSpan != null) {
                var dataExtent = axisProxy._dataExtent;
                minMaxSpan[minMax + 'Span'] = number["e" /* linearMap */](dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
            }
        }
    });
}

/* harmony default export */ var dataZoom_AxisProxy = (AxisProxy);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/DataZoomModel.js







var DataZoomModel_each = util["i" /* each */];
var DataZoomModel_eachAxisDim = eachAxisDim;

var DataZoomModel = extendComponentModel({

    type: 'dataZoom',

    dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],

    defaultOption: {
        zlevel: 0,
        z: 4,
        orient: null,
        xAxisIndex: null,
        yAxisIndex: null,

        filterMode: 'filter',

        throttle: null,
        start: 0,
        end: 100,
        startValue: null,
        endValue: null,
        minSpan: null,
        maxSpan: null,
        minValueSpan: null,
        maxValueSpan: null,
        rangeMode: null },

    init: function init(option, parentModel, ecModel) {
        this._dataIntervalByAxis = {};

        this._dataInfo = {};

        this._axisProxies = {};

        this.textStyleModel;

        this._autoThrottle = true;

        this._rangePropMode = ['percent', 'percent'];

        var rawOption = retrieveRaw(option);

        this.mergeDefaultAndTheme(option, ecModel);

        this.doInit(rawOption);
    },

    mergeOption: function mergeOption(newOption) {
        var rawOption = retrieveRaw(newOption);

        util["w" /* merge */](this.option, newOption, true);

        this.doInit(rawOption);
    },

    doInit: function doInit(rawOption) {
        var thisOption = this.option;

        if (!core_env["a" /* default */].canvasSupported) {
            thisOption.realtime = false;
        }

        this._setDefaultThrottle(rawOption);

        updateRangeUse(this, rawOption);

        DataZoomModel_each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
            if (this._rangePropMode[index] === 'value') {
                thisOption[names[0]] = null;
            }
        }, this);

        this.textStyleModel = this.getModel('textStyle');

        this._resetTarget();

        this._giveAxisProxies();
    },

    _giveAxisProxies: function _giveAxisProxies() {
        var axisProxies = this._axisProxies;

        this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {
            var axisModel = this.dependentModels[dimNames.axis][axisIndex];

            var axisProxy = axisModel.__dzAxisProxy || (axisModel.__dzAxisProxy = new dataZoom_AxisProxy(dimNames.name, axisIndex, this, ecModel));


            axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;
        }, this);
    },

    _resetTarget: function _resetTarget() {
        var thisOption = this.option;

        var autoMode = this._judgeAutoMode();

        DataZoomModel_eachAxisDim(function (dimNames) {
            var axisIndexName = dimNames.axisIndex;
            thisOption[axisIndexName] = util_model["m" /* normalizeToArray */](thisOption[axisIndexName]);
        }, this);

        if (autoMode === 'axisIndex') {
            this._autoSetAxisIndex();
        } else if (autoMode === 'orient') {
            this._autoSetOrient();
        }
    },

    _judgeAutoMode: function _judgeAutoMode() {
        var thisOption = this.option;

        var hasIndexSpecified = false;
        DataZoomModel_eachAxisDim(function (dimNames) {
            if (thisOption[dimNames.axisIndex] != null) {
                hasIndexSpecified = true;
            }
        }, this);

        var orient = thisOption.orient;

        if (orient == null && hasIndexSpecified) {
            return 'orient';
        } else if (!hasIndexSpecified) {
            if (orient == null) {
                thisOption.orient = 'horizontal';
            }
            return 'axisIndex';
        }
    },

    _autoSetAxisIndex: function _autoSetAxisIndex() {
        var autoAxisIndex = true;
        var orient = this.get('orient', true);
        var thisOption = this.option;
        var dependentModels = this.dependentModels;

        if (autoAxisIndex) {
            var dimName = orient === 'vertical' ? 'y' : 'x';

            if (dependentModels[dimName + 'Axis'].length) {
                thisOption[dimName + 'AxisIndex'] = [0];
                autoAxisIndex = false;
            } else {
                DataZoomModel_each(dependentModels.singleAxis, function (singleAxisModel) {
                    if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {
                        thisOption.singleAxisIndex = [singleAxisModel.componentIndex];
                        autoAxisIndex = false;
                    }
                });
            }
        }

        if (autoAxisIndex) {
            DataZoomModel_eachAxisDim(function (dimNames) {
                if (!autoAxisIndex) {
                    return;
                }
                var axisIndices = [];
                var axisModels = this.dependentModels[dimNames.axis];
                if (axisModels.length && !axisIndices.length) {
                    for (var i = 0, len = axisModels.length; i < len; i++) {
                        if (axisModels[i].get('type') === 'category') {
                            axisIndices.push(i);
                        }
                    }
                }
                thisOption[dimNames.axisIndex] = axisIndices;
                if (axisIndices.length) {
                    autoAxisIndex = false;
                }
            }, this);
        }

        if (autoAxisIndex) {
            this.ecModel.eachSeries(function (seriesModel) {
                if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {
                    DataZoomModel_eachAxisDim(function (dimNames) {
                        var axisIndices = thisOption[dimNames.axisIndex];

                        var axisIndex = seriesModel.get(dimNames.axisIndex);
                        var axisId = seriesModel.get(dimNames.axisId);

                        var axisModel = seriesModel.ecModel.queryComponents({
                            mainType: dimNames.axis,
                            index: axisIndex,
                            id: axisId
                        })[0];

                        if (false) {
                            if (!axisModel) {
                                throw new Error(dimNames.axis + ' "' + zrUtil.retrieve(axisIndex, axisId, 0) + '" not found');
                            }
                        }
                        axisIndex = axisModel.componentIndex;

                        if (util["n" /* indexOf */](axisIndices, axisIndex) < 0) {
                            axisIndices.push(axisIndex);
                        }
                    });
                }
            }, this);
        }
    },

    _autoSetOrient: function _autoSetOrient() {
        var dim;

        this.eachTargetAxis(function (dimNames) {
            !dim && (dim = dimNames.name);
        }, this);

        this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';
    },

    _isSeriesHasAllAxesTypeOf: function _isSeriesHasAllAxesTypeOf(seriesModel, axisType) {

        var is = true;
        DataZoomModel_eachAxisDim(function (dimNames) {
            var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
            var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];

            if (!axisModel || axisModel.get('type') !== axisType) {
                is = false;
            }
        }, this);
        return is;
    },

    _setDefaultThrottle: function _setDefaultThrottle(rawOption) {
        if (rawOption.hasOwnProperty('throttle')) {
            this._autoThrottle = false;
        }
        if (this._autoThrottle) {
            var globalOption = this.ecModel.option;
            this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
        }
    },

    getFirstTargetAxisModel: function getFirstTargetAxisModel() {
        var firstAxisModel;
        DataZoomModel_eachAxisDim(function (dimNames) {
            if (firstAxisModel == null) {
                var indices = this.get(dimNames.axisIndex);
                if (indices.length) {
                    firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
                }
            }
        }, this);

        return firstAxisModel;
    },

    eachTargetAxis: function eachTargetAxis(callback, context) {
        var ecModel = this.ecModel;
        DataZoomModel_eachAxisDim(function (dimNames) {
            DataZoomModel_each(this.get(dimNames.axisIndex), function (axisIndex) {
                callback.call(context, dimNames, axisIndex, this, ecModel);
            }, this);
        }, this);
    },

    getAxisProxy: function getAxisProxy(dimName, axisIndex) {
        return this._axisProxies[dimName + '_' + axisIndex];
    },

    getAxisModel: function getAxisModel(dimName, axisIndex) {
        var axisProxy = this.getAxisProxy(dimName, axisIndex);
        return axisProxy && axisProxy.getAxisModel();
    },

    setRawRange: function setRawRange(opt, ignoreUpdateRangeUsg) {
        var option = this.option;
        DataZoomModel_each([['start', 'startValue'], ['end', 'endValue']], function (names) {
            if (opt[names[0]] != null || opt[names[1]] != null) {
                option[names[0]] = opt[names[0]];
                option[names[1]] = opt[names[1]];
            }
        }, this);

        !ignoreUpdateRangeUsg && updateRangeUse(this, opt);
    },

    getPercentRange: function getPercentRange() {
        var axisProxy = this.findRepresentativeAxisProxy();
        if (axisProxy) {
            return axisProxy.getDataPercentWindow();
        }
    },

    getValueRange: function getValueRange(axisDimName, axisIndex) {
        if (axisDimName == null && axisIndex == null) {
            var axisProxy = this.findRepresentativeAxisProxy();
            if (axisProxy) {
                return axisProxy.getDataValueWindow();
            }
        } else {
            return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
        }
    },

    findRepresentativeAxisProxy: function findRepresentativeAxisProxy(axisModel) {
        if (axisModel) {
            return axisModel.__dzAxisProxy;
        }

        var axisProxies = this._axisProxies;
        for (var key in axisProxies) {
            if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
                return axisProxies[key];
            }
        }

        for (var key in axisProxies) {
            if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
                return axisProxies[key];
            }
        }
    },

    getRangePropMode: function getRangePropMode() {
        return this._rangePropMode.slice();
    }

});

function retrieveRaw(option) {
    var ret = {};
    DataZoomModel_each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {
        option.hasOwnProperty(name) && (ret[name] = option[name]);
    });
    return ret;
}

function updateRangeUse(dataZoomModel, rawOption) {
    var rangePropMode = dataZoomModel._rangePropMode;
    var rangeModeInOption = dataZoomModel.get('rangeMode');

    DataZoomModel_each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
        var percentSpecified = rawOption[names[0]] != null;
        var valueSpecified = rawOption[names[1]] != null;
        if (percentSpecified && !valueSpecified) {
            rangePropMode[index] = 'percent';
        } else if (!percentSpecified && valueSpecified) {
            rangePropMode[index] = 'value';
        } else if (rangeModeInOption) {
            rangePropMode[index] = rangeModeInOption[index];
        } else if (percentSpecified) {
            rangePropMode[index] = 'percent';
        }
    });
}

/* harmony default export */ var dataZoom_DataZoomModel = (DataZoomModel);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/DataZoomView.js


/* harmony default export */ var DataZoomView = (view_Component.extend({

    type: 'dataZoom',

    render: function render(dataZoomModel, ecModel, api, payload) {
        this.dataZoomModel = dataZoomModel;
        this.ecModel = ecModel;
        this.api = api;
    },

    getTargetCoordInfo: function getTargetCoordInfo() {
        var dataZoomModel = this.dataZoomModel;
        var ecModel = this.ecModel;
        var coordSysLists = {};

        dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
            var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);
            if (axisModel) {
                var coordModel = axisModel.getCoordSysModel();
                coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);
            }
        }, this);

        function save(coordModel, axisModel, store, coordIndex) {
            var item;
            for (var i = 0; i < store.length; i++) {
                if (store[i].model === coordModel) {
                    item = store[i];
                    break;
                }
            }
            if (!item) {
                store.push(item = {
                    model: coordModel, axisModels: [], coordIndex: coordIndex
                });
            }
            item.axisModels.push(axisModel);
        }

        return coordSysLists;
    }

}));
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/SelectZoomModel.js


/* harmony default export */ var SelectZoomModel = (dataZoom_DataZoomModel.extend({
    type: 'dataZoom.select'
}));
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/SelectZoomView.js


/* harmony default export */ var SelectZoomView = (DataZoomView.extend({
    type: 'dataZoom.select'
}));
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/dataZoomProcessor.js


registerProcessor(function (ecModel, api) {

    ecModel.eachComponent('dataZoom', function (dataZoomModel) {
        dataZoomModel.eachTargetAxis(resetSingleAxis);

        dataZoomModel.eachTargetAxis(filterSingleAxis);
    });

    ecModel.eachComponent('dataZoom', function (dataZoomModel) {
        var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
        var percentRange = axisProxy.getDataPercentWindow();
        var valueRange = axisProxy.getDataValueWindow();

        dataZoomModel.setRawRange({
            start: percentRange[0],
            end: percentRange[1],
            startValue: valueRange[0],
            endValue: valueRange[1]
        }, true);
    });
});

function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {
    dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);
}

function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {
    dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);
}
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoom/dataZoomAction.js




registerAction('dataZoom', function (payload, ecModel) {

    var linkedNodesFinder = createLinkedNodesFinder(util["c" /* bind */](ecModel.eachComponent, ecModel, 'dataZoom'), eachAxisDim, function (model, dimNames) {
        return model.get(dimNames.axisIndex);
    });

    var effectedModels = [];

    ecModel.eachComponent({ mainType: 'dataZoom', query: payload }, function (model, index) {
        effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
    });

    util["i" /* each */](effectedModels, function (dataZoomModel, index) {
        dataZoomModel.setRawRange({
            start: payload.start,
            end: payload.end,
            startValue: payload.startValue,
            endValue: payload.endValue
        });
    });
});
// CONCATENATED MODULE: ./node_modules/echarts/src/component/dataZoomSelect.js












// CONCATENATED MODULE: ./node_modules/echarts/src/component/toolbox/feature/DataZoom.js











var dataZoomLang = src_lang.toolbox.dataZoom;
var DataZoom_each = util["i" /* each */];

var DATA_ZOOM_ID_BASE = '\0_ec_\0toolbox-dataZoom_';

function DataZoom(model, ecModel, api) {
    (this._brushController = new helper_BrushController(api.getZr())).on('brush', util["c" /* bind */](this._onBrush, this)).mount();

    this._isZoomActive;
}

DataZoom.defaultOption = {
    show: true,

    icon: {
        zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
        back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
    },

    title: util["d" /* clone */](dataZoomLang.title)
};

var DataZoom_proto = DataZoom.prototype;

DataZoom_proto.render = function (featureModel, ecModel, api, payload) {
    this.model = featureModel;
    this.ecModel = ecModel;
    this.api = api;

    updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
    updateBackBtnStatus(featureModel, ecModel);
};

DataZoom_proto.onclick = function (ecModel, api, type) {
    handlers[type].call(this);
};

DataZoom_proto.remove = function (ecModel, api) {
    this._brushController.unmount();
};

DataZoom_proto.dispose = function (ecModel, api) {
    this._brushController.dispose();
};

var handlers = {

    zoom: function zoom() {
        var nextActive = !this._isZoomActive;

        this.api.dispatchAction({
            type: 'takeGlobalCursor',
            key: 'dataZoomSelect',
            dataZoomSelectActive: nextActive
        });
    },

    back: function back() {
        this._dispatchZoomAction(pop(this.ecModel));
    }
};

DataZoom_proto._onBrush = function (areas, opt) {
    if (!opt.isEnd || !areas.length) {
        return;
    }
    var snapshot = {};
    var ecModel = this.ecModel;

    this._brushController.updateCovers([]);

    var brushTargetManager = new helper_BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, { include: ['grid'] });
    brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
        if (coordSys.type !== 'cartesian2d') {
            return;
        }

        var brushType = area.brushType;
        if (brushType === 'rect') {
            setBatch('x', coordSys, coordRange[0]);
            setBatch('y', coordSys, coordRange[1]);
        } else {
            setBatch({ lineX: 'x', lineY: 'y' }[brushType], coordSys, coordRange);
        }
    });

    push(ecModel, snapshot);

    this._dispatchZoomAction(snapshot);

    function setBatch(dimName, coordSys, minMax) {
        var axis = coordSys.getAxis(dimName);
        var axisModel = axis.model;
        var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);

        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
        if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
            minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
        }

        dataZoomModel && (snapshot[dataZoomModel.id] = {
            dataZoomId: dataZoomModel.id,
            startValue: minMax[0],
            endValue: minMax[1]
        });
    }

    function findDataZoom(dimName, axisModel, ecModel) {
        var found;
        ecModel.eachComponent({ mainType: 'dataZoom', subType: 'select' }, function (dzModel) {
            var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);
            has && (found = dzModel);
        });
        return found;
    }
};

DataZoom_proto._dispatchZoomAction = function (snapshot) {
    var batch = [];

    DataZoom_each(snapshot, function (batchItem, dataZoomId) {
        batch.push(util["d" /* clone */](batchItem));
    });

    batch.length && this.api.dispatchAction({
        type: 'dataZoom',
        from: this.uid,
        batch: batch
    });
};

function retrieveAxisSetting(option) {
    var setting = {};

    util["i" /* each */](['xAxisIndex', 'yAxisIndex'], function (name) {
        setting[name] = option[name];
        setting[name] == null && (setting[name] = 'all');
        (setting[name] === false || setting[name] === 'none') && (setting[name] = []);
    });
    return setting;
}

function updateBackBtnStatus(featureModel, ecModel) {
    featureModel.setIconStatus('back', history_count(ecModel) > 1 ? 'emphasis' : 'normal');
}

function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
    var zoomActive = view._isZoomActive;

    if (payload && payload.type === 'takeGlobalCursor') {
        zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;
    }

    view._isZoomActive = zoomActive;

    featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');

    var brushTargetManager = new helper_BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, { include: ['grid'] });

    view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {
        return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';
    })).enableBrush(zoomActive ? {
        brushType: 'auto',
        brushStyle: {
            lineWidth: 0,
            fill: 'rgba(0,0,0,0.2)'
        }
    } : false);
}

featureManager_register('dataZoom', DataZoom);

registerPreprocessor(function (option) {
    if (!option) {
        return;
    }

    var dataZoomOpts = option.dataZoom || (option.dataZoom = []);
    if (!util["p" /* isArray */](dataZoomOpts)) {
        option.dataZoom = dataZoomOpts = [dataZoomOpts];
    }

    var toolboxOpt = option.toolbox;
    if (toolboxOpt) {
        if (util["p" /* isArray */](toolboxOpt)) {
            toolboxOpt = toolboxOpt[0];
        }

        if (toolboxOpt && toolboxOpt.feature) {
            var dataZoomOpt = toolboxOpt.feature.dataZoom;
            addForAxis('xAxis', dataZoomOpt);
            addForAxis('yAxis', dataZoomOpt);
        }
    }

    function addForAxis(axisName, dataZoomOpt) {
        if (!dataZoomOpt) {
            return;
        }

        var axisIndicesName = axisName + 'Index';
        var givenAxisIndices = dataZoomOpt[axisIndicesName];
        if (givenAxisIndices != null && givenAxisIndices != 'all' && !util["p" /* isArray */](givenAxisIndices)) {
            givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];
        }

        forEachComponent(axisName, function (axisOpt, axisIndex) {
            if (givenAxisIndices != null && givenAxisIndices != 'all' && util["n" /* indexOf */](givenAxisIndices, axisIndex) === -1) {
                return;
            }
            var newOpt = {
                type: 'select',
                $fromToolbox: true,

                id: DATA_ZOOM_ID_BASE + axisName + axisIndex
            };

            newOpt[axisIndicesName] = axisIndex;
            dataZoomOpts.push(newOpt);
        });
    }

    function forEachComponent(mainType, cb) {
        var opts = option[mainType];
        if (!util["p" /* isArray */](opts)) {
            opts = opts ? [opts] : [];
        }
        DataZoom_each(opts, cb);
    }
});

/* harmony default export */ var feature_DataZoom = (DataZoom);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/toolbox/feature/Restore.js





var restoreLang = src_lang.toolbox.restore;

function Restore(model) {
    this.model = model;
}

Restore.defaultOption = {
    show: true,
    icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
    title: restoreLang.title
};

var Restore_proto = Restore.prototype;

Restore_proto.onclick = function (ecModel, api, type) {
    history_clear(ecModel);

    api.dispatchAction({
        type: 'restore',
        from: this.uid
    });
};

featureManager_register('restore', Restore);

registerAction({ type: 'restore', event: 'restore', update: 'prepareAndUpdate' }, function (payload, ecModel) {
    ecModel.resetOption('recreate');
});

/* harmony default export */ var feature_Restore = (Restore);
// CONCATENATED MODULE: ./node_modules/echarts/src/component/toolbox.js







// CONCATENATED MODULE: ./src/charts.js










var myChart = echarts_init(document.getElementById('main'));

myChart.setOption({
    title: {
        text: 'ECharts 柱形图'
    },
    tooltip: {},
    xAxis: {
        data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
    },
    yAxis: {},
    series: [{
        name: '销量',
        type: 'bar',
        data: [5, 20, 36, 10, 10, 20]
    }]
});
var myChart1 = echarts_init(document.getElementById("main1"), "macarons");
var myChart2 = echarts_init(document.getElementById("main2"), "macarons");
var myChart3 = echarts_init(document.getElementById("main3"), "macarons");
var myChart4 = echarts_init(document.getElementById("main4"), "macarons");
var option1 = {
    title: {
        text: '温度状况',
        subtext: '纯属虚构'
    },
    tooltip: {
        trigger: 'axis'
    },
    legend: {
        data: ['设定温度', '进水温度', '出水温度', '环境温度']
    },
    toolbox: {
        show: true,
        feature: {
            mark: { show: true },
            dataView: { show: true, readOnly: false },
            magicType: { show: true, type: ['line', 'bar', 'stack', 'tiled'] },
            restore: { show: true },
            saveAsImage: { show: true }
        }
    },
    xAxis: [{
        type: 'category',
        axisLabel: {
            show: true,
            interval: 0,
            rotate: 45
        },
        data: ['00:00:00', '00:05:00', '00:10:00', '00:15:00', '00:20:00', '00:25:00', '00:30:00', '00:35:00', '00:40:00', '00:45:00']

    }],
    yAxis: [{
        type: 'value' }],
    series: [{
        name: '设定温度',
        type: 'line',
        smooth: true,
        data: [55, 55, 55, 55, 55, 55, 55, 55, 55, 55]
    }]
};

var option2 = {
    tooltip: {
        trigger: 'axis'
    },
    legend: {
        y: -30,
        data: ['设定温度', '进水温度', '出水温度', '环境温度']
    },
    toolbox: {
        y: -30,
        show: true,
        feature: {
            mark: { show: true },
            dataView: { show: true, readOnly: false },
            magicType: { show: true, type: ['line', 'bar', 'stack', 'tiled'] },
            restore: { show: true },
            saveAsImage: { show: true }
        }
    },
    xAxis: [{
        type: 'category',
        axisLabel: {
            show: true,
            interval: 0,
            rotate: 45
        },
        data: ['00:00:00', '00:05:00', '00:10:00', '00:15:00', '00:20:00', '00:25:00', '00:30:00', '00:35:00', '00:40:00', '00:45:00']

    }],
    yAxis: [{
        type: 'value' }],
    series: [{
        name: '进水温度',
        type: 'line',
        smooth: true,
        data: [15, 15, 16, 18, 18, 19, 19, 19, 19, 19]
    }]
};

var option3 = {
    tooltip: {
        trigger: 'axis'
    },
    legend: {
        y: -30,
        data: ['设定温度', '进水温度', '出水温度', '环境温度']
    },
    toolbox: {
        y: -30,
        show: true,
        feature: {
            mark: { show: true },
            dataView: { show: true, readOnly: false },
            magicType: { show: true, type: ['line', 'bar', 'stack', 'tiled'] },
            restore: { show: true },
            saveAsImage: { show: true }
        }
    },
    xAxis: [{
        type: 'category',
        axisLabel: {
            show: true,
            interval: 0,
            rotate: 45
        },
        data: ['00:00:00', '00:05:00', '00:10:00', '00:15:00', '00:20:00', '00:25:00', '00:30:00', '00:35:00', '00:40:00', '00:45:00']

    }],
    yAxis: [{
        type: 'value' }],
    series: [{
        name: '出水温度',
        type: 'line',
        smooth: true,
        data: [20, 25, 30, 35, 38, 44, 46, 48, 53, 56]
    }]
};

var option4 = {
    tooltip: {
        trigger: 'axis'
    },
    legend: {
        y: -30,
        data: ['设定温度', '进水温度', '出水温度', '环境温度']
    },
    toolbox: {
        y: -30,
        show: true,
        feature: {
            mark: { show: true },
            dataView: { show: true, readOnly: false },
            magicType: { show: true, type: ['line', 'bar', 'stack', 'tiled'] },
            restore: { show: true },
            saveAsImage: { show: true }
        }
    },
    xAxis: [{
        type: 'category',
        axisLabel: {
            show: true,
            interval: 0,
            rotate: 45
        },
        data: ['00:00:00', '00:05:00', '00:10:00', '00:15:00', '00:20:00', '00:25:00', '00:30:00', '00:35:00', '00:40:00', '00:45:00']

    }],
    yAxis: [{
        type: 'value' }],
    series: [{
        name: '环境温度',
        type: 'line',
        smooth: true,
        data: [15, 15, 15, 15, 15, 15, 15, 15, 15, 15]
    }]
};

myChart1.setOption(option1);
myChart2.setOption(option2);
myChart3.setOption(option3);
myChart4.setOption(option4);

connect([myChart1, myChart2, myChart3, myChart4]);

/***/ }),

/***/ 227:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_Model__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__DataDiffer__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_model__ = __webpack_require__(2);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };






var isObject = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["t" /* isObject */];

var UNDEFINED = 'undefined';
var globalObj = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === UNDEFINED ? global : window;

var dataCtors = {
    'float': _typeof(globalObj.Float64Array) === UNDEFINED ? Array : globalObj.Float64Array,
    'int': _typeof(globalObj.Int32Array) === UNDEFINED ? Array : globalObj.Int32Array,

    'ordinal': Array,
    'number': Array,
    'time': Array
};

var TRANSFERABLE_PROPERTIES = ['stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'];

function transferProperties(a, b) {
    __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["i" /* each */](TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {
        if (b.hasOwnProperty(propName)) {
            a[propName] = b[propName];
        }
    });

    a.__wrappedMethods = b.__wrappedMethods;
}

function DefaultDataProvider(dataArray) {
    this._array = dataArray || [];
}

DefaultDataProvider.prototype.pure = false;

DefaultDataProvider.prototype.count = function () {
    return this._array.length;
};
DefaultDataProvider.prototype.getItem = function (idx) {
    return this._array[idx];
};

var List = function List(dimensions, hostModel) {

    dimensions = dimensions || ['x', 'y'];

    var dimensionInfos = {};
    var dimensionNames = [];
    for (var i = 0; i < dimensions.length; i++) {
        var dimensionName;
        var dimensionInfo = {};
        if (typeof dimensions[i] === 'string') {
            dimensionName = dimensions[i];
            dimensionInfo = {
                name: dimensionName,
                coordDim: dimensionName,
                coordDimIndex: 0,
                stackable: false,

                type: 'number'
            };
        } else {
            dimensionInfo = dimensions[i];
            dimensionName = dimensionInfo.name;
            dimensionInfo.type = dimensionInfo.type || 'number';
            if (!dimensionInfo.coordDim) {
                dimensionInfo.coordDim = dimensionName;
                dimensionInfo.coordDimIndex = 0;
            }
        }
        dimensionInfo.otherDims = dimensionInfo.otherDims || {};
        dimensionNames.push(dimensionName);
        dimensionInfos[dimensionName] = dimensionInfo;
    }

    this.dimensions = dimensionNames;

    this._dimensionInfos = dimensionInfos;

    this.hostModel = hostModel;

    this.dataType;

    this.indices = [];

    this._storage = {};

    this._nameList = [];

    this._idList = [];

    this._optionModels = [];

    this.stackedOn = null;

    this._visual = {};

    this._layout = {};

    this._itemVisuals = [];

    this._itemLayouts = [];

    this._graphicEls = [];

    this._rawData;

    this._extent;
};

var listProto = List.prototype;

listProto.type = 'list';

listProto.hasItemOption = true;

listProto.getDimension = function (dim) {
    if (!isNaN(dim)) {
        dim = this.dimensions[dim] || dim;
    }
    return dim;
};

listProto.getDimensionInfo = function (dim) {
    return __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["d" /* clone */](this._dimensionInfos[this.getDimension(dim)]);
};

listProto.initData = function (data, nameList, dimValueGetter) {
    data = data || [];

    var isDataArray = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["p" /* isArray */](data);
    if (isDataArray) {
        data = new DefaultDataProvider(data);
    }
    if (false) {
        if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {
            throw new Error('Inavlid data provider.');
        }
    }

    this._rawData = data;

    var storage = this._storage = {};
    var indices = this.indices = [];

    var dimensions = this.dimensions;
    var dimensionInfoMap = this._dimensionInfos;

    var size = data.count();

    var idList = [];
    var nameRepeatCount = {};
    var nameDimIdx;

    nameList = nameList || [];

    for (var i = 0; i < dimensions.length; i++) {
        var dimInfo = dimensionInfoMap[dimensions[i]];
        dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);
        var DataCtor = dataCtors[dimInfo.type];
        storage[dimensions[i]] = new DataCtor(size);
    }

    var self = this;
    if (!dimValueGetter) {
        self.hasItemOption = false;
    }

    dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {
        var value = __WEBPACK_IMPORTED_MODULE_3__util_model__["g" /* getDataItemValue */](dataItem);

        if (__WEBPACK_IMPORTED_MODULE_3__util_model__["h" /* isDataItemOption */](dataItem)) {
            self.hasItemOption = true;
        }
        return __WEBPACK_IMPORTED_MODULE_3__util_model__["b" /* converDataValue */](value instanceof Array ? value[dimIndex] : value, dimensionInfoMap[dimName]);
    };

    for (var i = 0; i < size; i++) {
        var dataItem = data.getItem(i);

        for (var k = 0; k < dimensions.length; k++) {
            var dim = dimensions[k];
            var dimStorage = storage[dim];

            dimStorage[i] = dimValueGetter(dataItem, dim, i, k);
        }

        indices.push(i);
    }

    for (var i = 0; i < size; i++) {
        var dataItem = data.getItem(i);
        if (!nameList[i] && dataItem) {
            if (dataItem.name != null) {
                nameList[i] = dataItem.name;
            } else if (nameDimIdx != null) {
                nameList[i] = storage[dimensions[nameDimIdx]][i];
            }
        }
        var name = nameList[i] || '';

        var id = dataItem && dataItem.id;

        if (!id && name) {
            nameRepeatCount[name] = nameRepeatCount[name] || 0;
            id = name;
            if (nameRepeatCount[name] > 0) {
                id += '__ec__' + nameRepeatCount[name];
            }
            nameRepeatCount[name]++;
        }
        id && (idList[i] = id);
    }

    this._nameList = nameList;
    this._idList = idList;
};

listProto.count = function () {
    return this.indices.length;
};

listProto.get = function (dim, idx, stack) {
    var storage = this._storage;
    var dataIndex = this.indices[idx];

    if (dataIndex == null || !storage[dim]) {
        return NaN;
    }

    var value = storage[dim][dataIndex];

    if (stack) {
        var dimensionInfo = this._dimensionInfos[dim];
        if (dimensionInfo && dimensionInfo.stackable) {
            var stackedOn = this.stackedOn;
            while (stackedOn) {
                var stackedValue = stackedOn.get(dim, idx);

                if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {
                        value += stackedValue;
                    }
                stackedOn = stackedOn.stackedOn;
            }
        }
    }
    return value;
};

listProto.getValues = function (dimensions, idx, stack) {
    var values = [];

    if (!__WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["p" /* isArray */](dimensions)) {
        stack = idx;
        idx = dimensions;
        dimensions = this.dimensions;
    }

    for (var i = 0, len = dimensions.length; i < len; i++) {
        values.push(this.get(dimensions[i], idx, stack));
    }

    return values;
};

listProto.hasValue = function (idx) {
    var dimensions = this.dimensions;
    var dimensionInfos = this._dimensionInfos;
    for (var i = 0, len = dimensions.length; i < len; i++) {
        if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {
            return false;
        }
    }
    return true;
};

listProto.getDataExtent = function (dim, stack, filter) {
    dim = this.getDimension(dim);
    var dimData = this._storage[dim];
    var dimInfo = this.getDimensionInfo(dim);
    stack = dimInfo && dimInfo.stackable && stack;
    var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];
    var value;
    if (dimExtent) {
        return dimExtent;
    }

    if (dimData) {
        var min = Infinity;
        var max = -Infinity;

        for (var i = 0, len = this.count(); i < len; i++) {
            value = this.get(dim, i, stack);

            if (!filter || filter(value, dim, i)) {
                value < min && (min = value);
                value > max && (max = value);
            }
        }
        return this._extent[dim + !!stack] = [min, max];
    } else {
        return [Infinity, -Infinity];
    }
};

listProto.getSum = function (dim, stack) {
    var dimData = this._storage[dim];
    var sum = 0;
    if (dimData) {
        for (var i = 0, len = this.count(); i < len; i++) {
            var value = this.get(dim, i, stack);
            if (!isNaN(value)) {
                sum += value;
            }
        }
    }
    return sum;
};

listProto.indexOf = function (dim, value) {
    var storage = this._storage;
    var dimData = storage[dim];
    var indices = this.indices;

    if (dimData) {
        for (var i = 0, len = indices.length; i < len; i++) {
            var rawIndex = indices[i];
            if (dimData[rawIndex] === value) {
                return i;
            }
        }
    }
    return -1;
};

listProto.indexOfName = function (name) {
    var indices = this.indices;
    var nameList = this._nameList;

    for (var i = 0, len = indices.length; i < len; i++) {
        var rawIndex = indices[i];
        if (nameList[rawIndex] === name) {
            return i;
        }
    }

    return -1;
};

listProto.indexOfRawIndex = function (rawIndex) {
    var indices = this.indices;

    var rawDataIndex = indices[rawIndex];
    if (rawDataIndex != null && rawDataIndex === rawIndex) {
        return rawIndex;
    }

    var left = 0;
    var right = indices.length - 1;
    while (left <= right) {
        var mid = (left + right) / 2 | 0;
        if (indices[mid] < rawIndex) {
            left = mid + 1;
        } else if (indices[mid] > rawIndex) {
            right = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
};

listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {
    var storage = this._storage;
    var dimData = storage[dim];
    var nearestIndices = [];

    if (!dimData) {
        return nearestIndices;
    }

    if (maxDistance == null) {
        maxDistance = Infinity;
    }

    var minDist = Number.MAX_VALUE;
    var minDiff = -1;
    for (var i = 0, len = this.count(); i < len; i++) {
        var diff = value - this.get(dim, i, stack);
        var dist = Math.abs(diff);
        if (diff <= maxDistance && dist <= minDist) {
            if (dist < minDist || diff >= 0 && minDiff < 0) {
                minDist = dist;
                minDiff = diff;
                nearestIndices.length = 0;
            }
            nearestIndices.push(i);
        }
    }
    return nearestIndices;
};

listProto.getRawIndex = function (idx) {
    var rawIdx = this.indices[idx];
    return rawIdx == null ? -1 : rawIdx;
};

listProto.getRawDataItem = function (idx) {
    return this._rawData.getItem(this.getRawIndex(idx));
};

listProto.getName = function (idx) {
    return this._nameList[this.indices[idx]] || '';
};

listProto.getId = function (idx) {
    return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';
};

function normalizeDimensions(dimensions) {
    if (!__WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["p" /* isArray */](dimensions)) {
        dimensions = [dimensions];
    }
    return dimensions;
}

listProto.each = function (dims, cb, stack, context) {
    if (typeof dims === 'function') {
        context = stack;
        stack = cb;
        cb = dims;
        dims = [];
    }

    dims = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](normalizeDimensions(dims), this.getDimension, this);

    var value = [];
    var dimSize = dims.length;
    var indices = this.indices;

    context = context || this;

    for (var i = 0; i < indices.length; i++) {
        switch (dimSize) {
            case 0:
                cb.call(context, i);
                break;
            case 1:
                cb.call(context, this.get(dims[0], i, stack), i);
                break;
            case 2:
                cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);
                break;
            default:
                for (var k = 0; k < dimSize; k++) {
                    value[k] = this.get(dims[k], i, stack);
                }

                value[k] = i;
                cb.apply(context, value);
        }
    }
};

listProto.filterSelf = function (dimensions, cb, stack, context) {
    if (typeof dimensions === 'function') {
        context = stack;
        stack = cb;
        cb = dimensions;
        dimensions = [];
    }

    dimensions = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](normalizeDimensions(dimensions), this.getDimension, this);

    var newIndices = [];
    var value = [];
    var dimSize = dimensions.length;
    var indices = this.indices;

    context = context || this;

    for (var i = 0; i < indices.length; i++) {
        var keep;

        if (!dimSize) {
            keep = cb.call(context, i);
        } else if (dimSize === 1) {
            keep = cb.call(context, this.get(dimensions[0], i, stack), i);
        } else {
            for (var k = 0; k < dimSize; k++) {
                value[k] = this.get(dimensions[k], i, stack);
            }
            value[k] = i;
            keep = cb.apply(context, value);
        }
        if (keep) {
            newIndices.push(indices[i]);
        }
    }

    this.indices = newIndices;

    this._extent = {};

    return this;
};

listProto.mapArray = function (dimensions, cb, stack, context) {
    if (typeof dimensions === 'function') {
        context = stack;
        stack = cb;
        cb = dimensions;
        dimensions = [];
    }

    var result = [];
    this.each(dimensions, function () {
        result.push(cb && cb.apply(this, arguments));
    }, stack, context);
    return result;
};

function cloneListForMapAndSample(original, excludeDimensions) {
    var allDimensions = original.dimensions;
    var list = new List(__WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](allDimensions, original.getDimensionInfo, original), original.hostModel);

    transferProperties(list, original);

    var storage = list._storage = {};
    var originalStorage = original._storage;

    for (var i = 0; i < allDimensions.length; i++) {
        var dim = allDimensions[i];
        var dimStore = originalStorage[dim];
        if (__WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["n" /* indexOf */](excludeDimensions, dim) >= 0) {
            storage[dim] = new dimStore.constructor(originalStorage[dim].length);
        } else {
            storage[dim] = originalStorage[dim];
        }
    }
    return list;
}

listProto.map = function (dimensions, cb, stack, context) {
    dimensions = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](normalizeDimensions(dimensions), this.getDimension, this);

    var list = cloneListForMapAndSample(this, dimensions);

    var indices = list.indices = this.indices;

    var storage = list._storage;

    var tmpRetValue = [];
    this.each(dimensions, function () {
        var idx = arguments[arguments.length - 1];
        var retValue = cb && cb.apply(this, arguments);
        if (retValue != null) {
            if (typeof retValue === 'number') {
                tmpRetValue[0] = retValue;
                retValue = tmpRetValue;
            }
            for (var i = 0; i < retValue.length; i++) {
                var dim = dimensions[i];
                var dimStore = storage[dim];
                var rawIdx = indices[idx];
                if (dimStore) {
                    dimStore[rawIdx] = retValue[i];
                }
            }
        }
    }, stack, context);

    return list;
};

listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {
    var list = cloneListForMapAndSample(this, [dimension]);
    var storage = this._storage;
    var targetStorage = list._storage;

    var originalIndices = this.indices;
    var indices = list.indices = [];

    var frameValues = [];
    var frameIndices = [];
    var frameSize = Math.floor(1 / rate);

    var dimStore = targetStorage[dimension];
    var len = this.count();

    for (var i = 0; i < storage[dimension].length; i++) {
        targetStorage[dimension][i] = storage[dimension][i];
    }
    for (var i = 0; i < len; i += frameSize) {
        if (frameSize > len - i) {
            frameSize = len - i;
            frameValues.length = frameSize;
        }
        for (var k = 0; k < frameSize; k++) {
            var idx = originalIndices[i + k];
            frameValues[k] = dimStore[idx];
            frameIndices[k] = idx;
        }
        var value = sampleValue(frameValues);
        var idx = frameIndices[sampleIndex(frameValues, value) || 0];

        dimStore[idx] = value;
        indices.push(idx);
    }

    return list;
};

listProto.getItemModel = function (idx) {
    var hostModel = this.hostModel;
    idx = this.indices[idx];
    return new __WEBPACK_IMPORTED_MODULE_1__model_Model__["a" /* default */](this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);
};

listProto.diff = function (otherList) {
    var idList = this._idList;
    var otherIdList = otherList && otherList._idList;
    var val;

    var prefix = 'e\0\0';

    return new __WEBPACK_IMPORTED_MODULE_2__DataDiffer__["a" /* default */](otherList ? otherList.indices : [], this.indices, function (idx) {
        return (val = otherIdList[idx]) != null ? val : prefix + idx;
    }, function (idx) {
        return (val = idList[idx]) != null ? val : prefix + idx;
    });
};

listProto.getVisual = function (key) {
    var visual = this._visual;
    return visual && visual[key];
};

listProto.setVisual = function (key, val) {
    if (isObject(key)) {
        for (var name in key) {
            if (key.hasOwnProperty(name)) {
                this.setVisual(name, key[name]);
            }
        }
        return;
    }
    this._visual = this._visual || {};
    this._visual[key] = val;
};

listProto.setLayout = function (key, val) {
    if (isObject(key)) {
        for (var name in key) {
            if (key.hasOwnProperty(name)) {
                this.setLayout(name, key[name]);
            }
        }
        return;
    }
    this._layout[key] = val;
};

listProto.getLayout = function (key) {
    return this._layout[key];
};

listProto.getItemLayout = function (idx) {
    return this._itemLayouts[idx];
};

listProto.setItemLayout = function (idx, layout, merge) {
    this._itemLayouts[idx] = merge ? __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["k" /* extend */](this._itemLayouts[idx] || {}, layout) : layout;
};

listProto.clearItemLayouts = function () {
    this._itemLayouts.length = 0;
};

listProto.getItemVisual = function (idx, key, ignoreParent) {
    var itemVisual = this._itemVisuals[idx];
    var val = itemVisual && itemVisual[key];
    if (val == null && !ignoreParent) {
        return this.getVisual(key);
    }
    return val;
};

listProto.setItemVisual = function (idx, key, value) {
    var itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;

    if (isObject(key)) {
        for (var name in key) {
            if (key.hasOwnProperty(name)) {
                itemVisual[name] = key[name];
            }
        }
        return;
    }
    itemVisual[key] = value;
};

listProto.clearAllVisual = function () {
    this._visual = {};
    this._itemVisuals = [];
};

var setItemDataAndSeriesIndex = function setItemDataAndSeriesIndex(child) {
    child.seriesIndex = this.seriesIndex;
    child.dataIndex = this.dataIndex;
    child.dataType = this.dataType;
};

listProto.setItemGraphicEl = function (idx, el) {
    var hostModel = this.hostModel;

    if (el) {
        el.dataIndex = idx;
        el.dataType = this.dataType;
        el.seriesIndex = hostModel && hostModel.seriesIndex;
        if (el.type === 'group') {
            el.traverse(setItemDataAndSeriesIndex, el);
        }
    }

    this._graphicEls[idx] = el;
};

listProto.getItemGraphicEl = function (idx) {
    return this._graphicEls[idx];
};

listProto.eachItemGraphicEl = function (cb, context) {
    __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["i" /* each */](this._graphicEls, function (el, idx) {
        if (el) {
            cb && cb.call(context, el, idx);
        }
    });
};

listProto.cloneShallow = function () {
    var dimensionInfoList = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](this.dimensions, this.getDimensionInfo, this);
    var list = new List(dimensionInfoList, this.hostModel);

    list._storage = this._storage;

    transferProperties(list, this);

    list.indices = this.indices.slice();

    if (this._extent) {
        list._extent = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["k" /* extend */]({}, this._extent);
    }

    return list;
};

listProto.wrapMethod = function (methodName, injectFunction) {
    var originalMethod = this[methodName];
    if (typeof originalMethod !== 'function') {
        return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function () {
        var res = originalMethod.apply(this, arguments);
        return injectFunction.apply(this, [res].concat(__WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["G" /* slice */](arguments)));
    };
};

listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];

listProto.CHANGABLE_METHODS = ['filterSelf'];

/* harmony default export */ __webpack_exports__["a"] = (List);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(10)))

/***/ }),

/***/ 3:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = linearMap;
/* harmony export (immutable) */ __webpack_exports__["h"] = parsePercent;
/* harmony export (immutable) */ __webpack_exports__["k"] = round;
/* harmony export (immutable) */ __webpack_exports__["a"] = asc;
/* unused harmony export getPrecision */
/* harmony export (immutable) */ __webpack_exports__["c"] = getPrecisionSafe;
/* harmony export (immutable) */ __webpack_exports__["b"] = getPixelPrecision;
/* unused harmony export getPercentWithPrecision */
/* unused harmony export MAX_SAFE_INTEGER */
/* harmony export (immutable) */ __webpack_exports__["j"] = remRadian;
/* harmony export (immutable) */ __webpack_exports__["d"] = isRadianAroundZero;
/* harmony export (immutable) */ __webpack_exports__["g"] = parseDate;
/* harmony export (immutable) */ __webpack_exports__["i"] = quantity;
/* harmony export (immutable) */ __webpack_exports__["f"] = nice;
/* unused harmony export reformIntervals */
/* unused harmony export isNumeric */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__ = __webpack_require__(0);


var RADIAN_EPSILON = 1e-4;

function _trim(str) {
    return str.replace(/^\s+/, '').replace(/\s+$/, '');
}

function linearMap(val, domain, range, clamp) {
    var subDomain = domain[1] - domain[0];
    var subRange = range[1] - range[0];

    if (subDomain === 0) {
        return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
    }

    if (clamp) {
        if (subDomain > 0) {
            if (val <= domain[0]) {
                return range[0];
            } else if (val >= domain[1]) {
                return range[1];
            }
        } else {
            if (val >= domain[0]) {
                return range[0];
            } else if (val <= domain[1]) {
                return range[1];
            }
        }
    } else {
        if (val === domain[0]) {
            return range[0];
        }
        if (val === domain[1]) {
            return range[1];
        }
    }

    return (val - domain[0]) / subDomain * subRange + range[0];
}

function parsePercent(percent, all) {
    switch (percent) {
        case 'center':
        case 'middle':
            percent = '50%';
            break;
        case 'left':
        case 'top':
            percent = '0%';
            break;
        case 'right':
        case 'bottom':
            percent = '100%';
            break;
    }
    if (typeof percent === 'string') {
        if (_trim(percent).match(/%$/)) {
            return parseFloat(percent) / 100 * all;
        }

        return parseFloat(percent);
    }

    return percent == null ? NaN : +percent;
}

function round(x, precision, returnStr) {
    if (precision == null) {
        precision = 10;
    }

    precision = Math.min(Math.max(0, precision), 20);
    x = (+x).toFixed(precision);
    return returnStr ? x : +x;
}

function asc(arr) {
    arr.sort(function (a, b) {
        return a - b;
    });
    return arr;
}

function getPrecision(val) {
    val = +val;
    if (isNaN(val)) {
        return 0;
    }

    var e = 1;
    var count = 0;
    while (Math.round(val * e) / e !== val) {
        e *= 10;
        count++;
    }
    return count;
}

function getPrecisionSafe(val) {
    var str = val.toString();

    var eIndex = str.indexOf('e');
    if (eIndex > 0) {
        var precision = +str.slice(eIndex + 1);
        return precision < 0 ? -precision : 0;
    } else {
        var dotIndex = str.indexOf('.');
        return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
    }
}

function getPixelPrecision(dataExtent, pixelExtent) {
    var log = Math.log;
    var LN10 = Math.LN10;
    var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
    var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);

    var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
    return !isFinite(precision) ? 20 : precision;
}

function getPercentWithPrecision(valueList, idx, precision) {
    if (!valueList[idx]) {
        return 0;
    }

    var sum = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["B" /* reduce */](valueList, function (acc, val) {
        return acc + (isNaN(val) ? 0 : val);
    }, 0);
    if (sum === 0) {
        return 0;
    }

    var digits = Math.pow(10, precision);
    var votesPerQuota = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](valueList, function (val) {
        return (isNaN(val) ? 0 : val) / sum * digits * 100;
    });
    var targetSeats = digits * 100;

    var seats = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](votesPerQuota, function (votes) {
        return Math.floor(votes);
    });
    var currentSum = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["B" /* reduce */](seats, function (acc, val) {
        return acc + val;
    }, 0);

    var remainder = __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["v" /* map */](votesPerQuota, function (votes, idx) {
        return votes - seats[idx];
    });

    while (currentSum < targetSeats) {
        var max = Number.NEGATIVE_INFINITY;
        var maxId = null;
        for (var i = 0, len = remainder.length; i < len; ++i) {
            if (remainder[i] > max) {
                max = remainder[i];
                maxId = i;
            }
        }

        ++seats[maxId];
        remainder[maxId] = 0;
        ++currentSum;
    }

    return seats[idx] / digits;
}

var MAX_SAFE_INTEGER = 9007199254740991;

function remRadian(radian) {
    var pi2 = Math.PI * 2;
    return (radian % pi2 + pi2) % pi2;
}

function isRadianAroundZero(val) {
    return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}

var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(value) {
    if (value instanceof Date) {
        return value;
    } else if (typeof value === 'string') {
        var match = TIME_REG.exec(value);

        if (!match) {
            return new Date(NaN);
        }

        if (!match[8]) {
            return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
        } else {
                var hour = +match[4] || 0;
                if (match[8].toUpperCase() !== 'Z') {
                    hour -= match[8].slice(0, 3);
                }
                return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
            }
    } else if (value == null) {
        return new Date(NaN);
    }

    return new Date(Math.round(value));
}

function quantity(val) {
    return Math.pow(10, quantityExponent(val));
}

function quantityExponent(val) {
    return Math.floor(Math.log(val) / Math.LN10);
}

function nice(val, round) {
    var exponent = quantityExponent(val);
    var exp10 = Math.pow(10, exponent);
    var f = val / exp10;
    var nf;
    if (round) {
        if (f < 1.5) {
            nf = 1;
        } else if (f < 2.5) {
            nf = 2;
        } else if (f < 4) {
            nf = 3;
        } else if (f < 7) {
            nf = 5;
        } else {
            nf = 10;
        }
    } else {
        if (f < 1) {
            nf = 1;
        } else if (f < 2) {
            nf = 2;
        } else if (f < 3) {
            nf = 3;
        } else if (f < 5) {
            nf = 5;
        } else {
            nf = 10;
        }
    }
    val = nf * exp10;

    return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}

function reformIntervals(list) {
    list.sort(function (a, b) {
        return littleThan(a, b, 0) ? -1 : 1;
    });

    var curr = -Infinity;
    var currClose = 1;
    for (var i = 0; i < list.length;) {
        var interval = list[i].interval;
        var close = list[i].close;

        for (var lg = 0; lg < 2; lg++) {
            if (interval[lg] <= curr) {
                interval[lg] = curr;
                close[lg] = !lg ? 1 - currClose : 1;
            }
            curr = interval[lg];
            currClose = close[lg];
        }

        if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
            list.splice(i, 1);
        } else {
            i++;
        }
    }

    return list;

    function littleThan(a, b, lg) {
        return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));
    }
}

function isNumeric(v) {
    return v - parseFloat(v) >= 0;
}

/***/ }),

/***/ 31:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = create;
/* harmony export (immutable) */ __webpack_exports__["c"] = identity;
/* harmony export (immutable) */ __webpack_exports__["a"] = copy;
/* harmony export (immutable) */ __webpack_exports__["e"] = mul;
/* harmony export (immutable) */ __webpack_exports__["h"] = translate;
/* harmony export (immutable) */ __webpack_exports__["f"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["g"] = scale;
/* harmony export (immutable) */ __webpack_exports__["d"] = invert;


var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;

function create() {
    var out = new ArrayCtor(6);
    identity(out);

    return out;
}

function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
}

function copy(out, m) {
    out[0] = m[0];
    out[1] = m[1];
    out[2] = m[2];
    out[3] = m[3];
    out[4] = m[4];
    out[5] = m[5];
    return out;
}

function mul(out, m1, m2) {
    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
    var out2 = m1[0] * m2[2] + m1[2] * m2[3];
    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = out3;
    out[4] = out4;
    out[5] = out5;
    return out;
}

function translate(out, a, v) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4] + v[0];
    out[5] = a[5] + v[1];
    return out;
}

function rotate(out, a, rad) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var st = Math.sin(rad);
    var ct = Math.cos(rad);

    out[0] = aa * ct + ab * st;
    out[1] = -aa * st + ab * ct;
    out[2] = ac * ct + ad * st;
    out[3] = -ac * st + ct * ad;
    out[4] = ct * atx + st * aty;
    out[5] = ct * aty - st * atx;
    return out;
}

function scale(out, a, v) {
    var vx = v[0];
    var vy = v[1];
    out[0] = a[0] * vx;
    out[1] = a[1] * vy;
    out[2] = a[2] * vx;
    out[3] = a[3] * vy;
    out[4] = a[4] * vx;
    out[5] = a[5] * vy;
    return out;
}

function invert(out, a) {

    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];

    var det = aa * ad - ab * ac;
    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
}

/***/ }),

/***/ 39:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Element__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_BoundingRect__ = __webpack_require__(11);






var Group = function Group(opts) {

    opts = opts || {};

    __WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].call(this, opts);

    for (var key in opts) {
        if (opts.hasOwnProperty(key)) {
            this[key] = opts[key];
        }
    }

    this._children = [];

    this.__storage = null;

    this.__dirty = true;
};

Group.prototype = {

    constructor: Group,

    isGroup: true,

    type: 'group',

    silent: false,

    children: function children() {
        return this._children.slice();
    },

    childAt: function childAt(idx) {
        return this._children[idx];
    },

    childOfName: function childOfName(name) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
            if (children[i].name === name) {
                return children[i];
            }
        }
    },

    childCount: function childCount() {
        return this._children.length;
    },

    add: function add(child) {
        if (child && child !== this && child.parent !== this) {

            this._children.push(child);

            this._doAdd(child);
        }

        return this;
    },

    addBefore: function addBefore(child, nextSibling) {
        if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {

            var children = this._children;
            var idx = children.indexOf(nextSibling);

            if (idx >= 0) {
                children.splice(idx, 0, child);
                this._doAdd(child);
            }
        }

        return this;
    },

    _doAdd: function _doAdd(child) {
        if (child.parent) {
            child.parent.remove(child);
        }

        child.parent = this;

        var storage = this.__storage;
        var zr = this.__zr;
        if (storage && storage !== child.__storage) {

            storage.addToStorage(child);

            if (child instanceof Group) {
                child.addChildrenToStorage(storage);
            }
        }

        zr && zr.refresh();
    },

    remove: function remove(child) {
        var zr = this.__zr;
        var storage = this.__storage;
        var children = this._children;

        var idx = __WEBPACK_IMPORTED_MODULE_0__core_util__["n" /* indexOf */](children, child);
        if (idx < 0) {
            return this;
        }
        children.splice(idx, 1);

        child.parent = null;

        if (storage) {

            storage.delFromStorage(child);

            if (child instanceof Group) {
                child.delChildrenFromStorage(storage);
            }
        }

        zr && zr.refresh();

        return this;
    },

    removeAll: function removeAll() {
        var children = this._children;
        var storage = this.__storage;
        var child;
        var i;
        for (i = 0; i < children.length; i++) {
            child = children[i];
            if (storage) {
                storage.delFromStorage(child);
                if (child instanceof Group) {
                    child.delChildrenFromStorage(storage);
                }
            }
            child.parent = null;
        }
        children.length = 0;

        return this;
    },

    eachChild: function eachChild(cb, context) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            cb.call(context, child, i);
        }
        return this;
    },

    traverse: function traverse(cb, context) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            cb.call(context, child);

            if (child.type === 'group') {
                child.traverse(cb, context);
            }
        }
        return this;
    },

    addChildrenToStorage: function addChildrenToStorage(storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.addToStorage(child);
            if (child instanceof Group) {
                child.addChildrenToStorage(storage);
            }
        }
    },

    delChildrenFromStorage: function delChildrenFromStorage(storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.delFromStorage(child);
            if (child instanceof Group) {
                child.delChildrenFromStorage(storage);
            }
        }
    },

    dirty: function dirty() {
        this.__dirty = true;
        this.__zr && this.__zr.refresh();
        return this;
    },

    getBoundingRect: function getBoundingRect(includeChildren) {
        var rect = null;
        var tmpRect = new __WEBPACK_IMPORTED_MODULE_2__core_BoundingRect__["a" /* default */](0, 0, 0, 0);
        var children = includeChildren || this._children;
        var tmpMat = [];

        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (child.ignore || child.invisible) {
                continue;
            }

            var childRect = child.getBoundingRect();
            var transform = child.getLocalTransform(tmpMat);

            if (transform) {
                tmpRect.copy(childRect);
                tmpRect.applyTransform(transform);
                rect = rect || tmpRect.clone();
                rect.union(tmpRect);
            } else {
                rect = rect || childRect.clone();
                rect.union(childRect);
            }
        }
        return rect || tmpRect;
    }
};

__WEBPACK_IMPORTED_MODULE_0__core_util__["o" /* inherits */](Group, __WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (Group);

/***/ }),

/***/ 4:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var env = {};

if (typeof navigator === 'undefined') {
    env = {
        browser: {},
        os: {},
        node: true,

        canvasSupported: true,
        svgSupported: true
    };
} else {
    env = detect(navigator.userAgent);
}

/* harmony default export */ __webpack_exports__["a"] = (env);

function detect(ua) {
    var os = {};
    var browser = {};

    var firefox = ua.match(/Firefox\/([\d.]+)/);

    var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
    var edge = ua.match(/Edge\/([\d.]+)/);

    var weChat = /micromessenger/i.test(ua);

    if (firefox) {
        browser.firefox = true;
        browser.version = firefox[1];
    }


    if (ie) {
        browser.ie = true;
        browser.version = ie[1];
    }

    if (edge) {
        browser.edge = true;
        browser.version = edge[1];
    }

    if (weChat) {
        browser.weChat = true;
    }

    return {
        browser: browser,
        os: os,
        node: false,

        canvasSupported: !!document.createElement('canvas').getContext,
        svgSupported: typeof SVGRect !== 'undefined',

        touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,

        pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 11)
    };
}

/***/ }),

/***/ 40:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = parse;
/* harmony export (immutable) */ __webpack_exports__["a"] = lift;
/* harmony export (immutable) */ __webpack_exports__["d"] = toHex;
/* unused harmony export fastLerp */
/* unused harmony export fastMapToColor */
/* unused harmony export lerp */
/* unused harmony export mapToColor */
/* unused harmony export modifyHSL */
/* unused harmony export modifyAlpha */
/* harmony export (immutable) */ __webpack_exports__["c"] = stringify;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_LRU__ = __webpack_require__(95);


var kCSSColorTable = {
    'transparent': [0, 0, 0, 0], 'aliceblue': [240, 248, 255, 1],
    'antiquewhite': [250, 235, 215, 1], 'aqua': [0, 255, 255, 1],
    'aquamarine': [127, 255, 212, 1], 'azure': [240, 255, 255, 1],
    'beige': [245, 245, 220, 1], 'bisque': [255, 228, 196, 1],
    'black': [0, 0, 0, 1], 'blanchedalmond': [255, 235, 205, 1],
    'blue': [0, 0, 255, 1], 'blueviolet': [138, 43, 226, 1],
    'brown': [165, 42, 42, 1], 'burlywood': [222, 184, 135, 1],
    'cadetblue': [95, 158, 160, 1], 'chartreuse': [127, 255, 0, 1],
    'chocolate': [210, 105, 30, 1], 'coral': [255, 127, 80, 1],
    'cornflowerblue': [100, 149, 237, 1], 'cornsilk': [255, 248, 220, 1],
    'crimson': [220, 20, 60, 1], 'cyan': [0, 255, 255, 1],
    'darkblue': [0, 0, 139, 1], 'darkcyan': [0, 139, 139, 1],
    'darkgoldenrod': [184, 134, 11, 1], 'darkgray': [169, 169, 169, 1],
    'darkgreen': [0, 100, 0, 1], 'darkgrey': [169, 169, 169, 1],
    'darkkhaki': [189, 183, 107, 1], 'darkmagenta': [139, 0, 139, 1],
    'darkolivegreen': [85, 107, 47, 1], 'darkorange': [255, 140, 0, 1],
    'darkorchid': [153, 50, 204, 1], 'darkred': [139, 0, 0, 1],
    'darksalmon': [233, 150, 122, 1], 'darkseagreen': [143, 188, 143, 1],
    'darkslateblue': [72, 61, 139, 1], 'darkslategray': [47, 79, 79, 1],
    'darkslategrey': [47, 79, 79, 1], 'darkturquoise': [0, 206, 209, 1],
    'darkviolet': [148, 0, 211, 1], 'deeppink': [255, 20, 147, 1],
    'deepskyblue': [0, 191, 255, 1], 'dimgray': [105, 105, 105, 1],
    'dimgrey': [105, 105, 105, 1], 'dodgerblue': [30, 144, 255, 1],
    'firebrick': [178, 34, 34, 1], 'floralwhite': [255, 250, 240, 1],
    'forestgreen': [34, 139, 34, 1], 'fuchsia': [255, 0, 255, 1],
    'gainsboro': [220, 220, 220, 1], 'ghostwhite': [248, 248, 255, 1],
    'gold': [255, 215, 0, 1], 'goldenrod': [218, 165, 32, 1],
    'gray': [128, 128, 128, 1], 'green': [0, 128, 0, 1],
    'greenyellow': [173, 255, 47, 1], 'grey': [128, 128, 128, 1],
    'honeydew': [240, 255, 240, 1], 'hotpink': [255, 105, 180, 1],
    'indianred': [205, 92, 92, 1], 'indigo': [75, 0, 130, 1],
    'ivory': [255, 255, 240, 1], 'khaki': [240, 230, 140, 1],
    'lavender': [230, 230, 250, 1], 'lavenderblush': [255, 240, 245, 1],
    'lawngreen': [124, 252, 0, 1], 'lemonchiffon': [255, 250, 205, 1],
    'lightblue': [173, 216, 230, 1], 'lightcoral': [240, 128, 128, 1],
    'lightcyan': [224, 255, 255, 1], 'lightgoldenrodyellow': [250, 250, 210, 1],
    'lightgray': [211, 211, 211, 1], 'lightgreen': [144, 238, 144, 1],
    'lightgrey': [211, 211, 211, 1], 'lightpink': [255, 182, 193, 1],
    'lightsalmon': [255, 160, 122, 1], 'lightseagreen': [32, 178, 170, 1],
    'lightskyblue': [135, 206, 250, 1], 'lightslategray': [119, 136, 153, 1],
    'lightslategrey': [119, 136, 153, 1], 'lightsteelblue': [176, 196, 222, 1],
    'lightyellow': [255, 255, 224, 1], 'lime': [0, 255, 0, 1],
    'limegreen': [50, 205, 50, 1], 'linen': [250, 240, 230, 1],
    'magenta': [255, 0, 255, 1], 'maroon': [128, 0, 0, 1],
    'mediumaquamarine': [102, 205, 170, 1], 'mediumblue': [0, 0, 205, 1],
    'mediumorchid': [186, 85, 211, 1], 'mediumpurple': [147, 112, 219, 1],
    'mediumseagreen': [60, 179, 113, 1], 'mediumslateblue': [123, 104, 238, 1],
    'mediumspringgreen': [0, 250, 154, 1], 'mediumturquoise': [72, 209, 204, 1],
    'mediumvioletred': [199, 21, 133, 1], 'midnightblue': [25, 25, 112, 1],
    'mintcream': [245, 255, 250, 1], 'mistyrose': [255, 228, 225, 1],
    'moccasin': [255, 228, 181, 1], 'navajowhite': [255, 222, 173, 1],
    'navy': [0, 0, 128, 1], 'oldlace': [253, 245, 230, 1],
    'olive': [128, 128, 0, 1], 'olivedrab': [107, 142, 35, 1],
    'orange': [255, 165, 0, 1], 'orangered': [255, 69, 0, 1],
    'orchid': [218, 112, 214, 1], 'palegoldenrod': [238, 232, 170, 1],
    'palegreen': [152, 251, 152, 1], 'paleturquoise': [175, 238, 238, 1],
    'palevioletred': [219, 112, 147, 1], 'papayawhip': [255, 239, 213, 1],
    'peachpuff': [255, 218, 185, 1], 'peru': [205, 133, 63, 1],
    'pink': [255, 192, 203, 1], 'plum': [221, 160, 221, 1],
    'powderblue': [176, 224, 230, 1], 'purple': [128, 0, 128, 1],
    'red': [255, 0, 0, 1], 'rosybrown': [188, 143, 143, 1],
    'royalblue': [65, 105, 225, 1], 'saddlebrown': [139, 69, 19, 1],
    'salmon': [250, 128, 114, 1], 'sandybrown': [244, 164, 96, 1],
    'seagreen': [46, 139, 87, 1], 'seashell': [255, 245, 238, 1],
    'sienna': [160, 82, 45, 1], 'silver': [192, 192, 192, 1],
    'skyblue': [135, 206, 235, 1], 'slateblue': [106, 90, 205, 1],
    'slategray': [112, 128, 144, 1], 'slategrey': [112, 128, 144, 1],
    'snow': [255, 250, 250, 1], 'springgreen': [0, 255, 127, 1],
    'steelblue': [70, 130, 180, 1], 'tan': [210, 180, 140, 1],
    'teal': [0, 128, 128, 1], 'thistle': [216, 191, 216, 1],
    'tomato': [255, 99, 71, 1], 'turquoise': [64, 224, 208, 1],
    'violet': [238, 130, 238, 1], 'wheat': [245, 222, 179, 1],
    'white': [255, 255, 255, 1], 'whitesmoke': [245, 245, 245, 1],
    'yellow': [255, 255, 0, 1], 'yellowgreen': [154, 205, 50, 1]
};

function clampCssByte(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clampCssAngle(i) {
    i = Math.round(i);
    return i < 0 ? 0 : i > 360 ? 360 : i;
}

function clampCssFloat(f) {
    return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parseCssInt(str) {
    if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssByte(parseFloat(str) / 100 * 255);
    }
    return clampCssByte(parseInt(str, 10));
}

function parseCssFloat(str) {
    if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssFloat(parseFloat(str) / 100);
    }
    return clampCssFloat(parseFloat(str));
}

function cssHueToRgb(m1, m2, h) {
    if (h < 0) {
        h += 1;
    } else if (h > 1) {
        h -= 1;
    }

    if (h * 6 < 1) {
        return m1 + (m2 - m1) * h * 6;
    }
    if (h * 2 < 1) {
        return m2;
    }
    if (h * 3 < 2) {
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
}

function lerpNumber(a, b, p) {
    return a + (b - a) * p;
}

function setRgba(out, r, g, b, a) {
    out[0] = r;out[1] = g;out[2] = b;out[3] = a;
    return out;
}
function copyRgba(out, a) {
    out[0] = a[0];out[1] = a[1];out[2] = a[2];out[3] = a[3];
    return out;
}

var colorCache = new __WEBPACK_IMPORTED_MODULE_0__core_LRU__["a" /* default */](20);
var lastRemovedArr = null;

function putToCache(colorStr, rgbaArr) {
    if (lastRemovedArr) {
        copyRgba(lastRemovedArr, rgbaArr);
    }
    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}

function parse(colorStr, rgbaArr) {
    if (!colorStr) {
        return;
    }
    rgbaArr = rgbaArr || [];

    var cached = colorCache.get(colorStr);
    if (cached) {
        return copyRgba(rgbaArr, cached);
    }

    colorStr = colorStr + '';

    var str = colorStr.replace(/ /g, '').toLowerCase();

    if (str in kCSSColorTable) {
        copyRgba(rgbaArr, kCSSColorTable[str]);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
    }

    if (str.charAt(0) === '#') {
        if (str.length === 4) {
            var iv = parseInt(str.substr(1), 16);
            if (!(iv >= 0 && iv <= 0xfff)) {
                setRgba(rgbaArr, 0, 0, 0, 1);
                return;
            }
            setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
        } else if (str.length === 7) {
            var iv = parseInt(str.substr(1), 16);
            if (!(iv >= 0 && iv <= 0xffffff)) {
                setRgba(rgbaArr, 0, 0, 0, 1);
                return;
            }
            setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
        }

        return;
    }
    var op = str.indexOf('('),
        ep = str.indexOf(')');
    if (op !== -1 && ep + 1 === str.length) {
        var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(',');
        var alpha = 1;
        switch (fname) {
            case 'rgba':
                if (params.length !== 4) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                alpha = parseCssFloat(params.pop());
            case 'rgb':
                if (params.length !== 3) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
                putToCache(colorStr, rgbaArr);
                return rgbaArr;
            case 'hsla':
                if (params.length !== 4) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                params[3] = parseCssFloat(params[3]);
                hsla2rgba(params, rgbaArr);
                putToCache(colorStr, rgbaArr);
                return rgbaArr;
            case 'hsl':
                if (params.length !== 3) {
                    setRgba(rgbaArr, 0, 0, 0, 1);
                    return;
                }
                hsla2rgba(params, rgbaArr);
                putToCache(colorStr, rgbaArr);
                return rgbaArr;
            default:
                return;
        }
    }

    setRgba(rgbaArr, 0, 0, 0, 1);
    return;
}

function hsla2rgba(hsla, rgba) {
    var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
    var s = parseCssFloat(hsla[1]);
    var l = parseCssFloat(hsla[2]);
    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
    var m1 = l * 2 - m2;

    rgba = rgba || [];
    setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);

    if (hsla.length === 4) {
        rgba[3] = hsla[3];
    }

    return rgba;
}

function rgba2hsla(rgba) {
    if (!rgba) {
        return;
    }

    var R = rgba[0] / 255;
    var G = rgba[1] / 255;
    var B = rgba[2] / 255;

    var vMin = Math.min(R, G, B);
    var vMax = Math.max(R, G, B);
    var delta = vMax - vMin;

    var L = (vMax + vMin) / 2;
    var H;
    var S;

    if (delta === 0) {
        H = 0;
        S = 0;
    } else {
        if (L < 0.5) {
            S = delta / (vMax + vMin);
        } else {
            S = delta / (2 - vMax - vMin);
        }

        var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
        var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
        var deltaB = ((vMax - B) / 6 + delta / 2) / delta;

        if (R === vMax) {
            H = deltaB - deltaG;
        } else if (G === vMax) {
            H = 1 / 3 + deltaR - deltaB;
        } else if (B === vMax) {
            H = 2 / 3 + deltaG - deltaR;
        }

        if (H < 0) {
            H += 1;
        }

        if (H > 1) {
            H -= 1;
        }
    }

    var hsla = [H * 360, S, L];

    if (rgba[3] != null) {
        hsla.push(rgba[3]);
    }

    return hsla;
}

function lift(color, level) {
    var colorArr = parse(color);
    if (colorArr) {
        for (var i = 0; i < 3; i++) {
            if (level < 0) {
                colorArr[i] = colorArr[i] * (1 - level) | 0;
            } else {
                colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
            }
        }
        return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
    }
}

function toHex(color) {
    var colorArr = parse(color);
    if (colorArr) {
        return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
    }
}

function fastLerp(normalizedValue, colors, out) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
    }

    out = out || [];

    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = colors[leftIndex];
    var rightColor = colors[rightIndex];
    var dv = value - leftIndex;
    out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
    out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
    out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
    out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));

    return out;
}

var fastMapToColor = fastLerp;

function lerp(normalizedValue, colors, fullOutput) {
    if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
    }

    var value = normalizedValue * (colors.length - 1);
    var leftIndex = Math.floor(value);
    var rightIndex = Math.ceil(value);
    var leftColor = parse(colors[leftIndex]);
    var rightColor = parse(colors[rightIndex]);
    var dv = value - leftIndex;

    var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');

    return fullOutput ? {
        color: color,
        leftIndex: leftIndex,
        rightIndex: rightIndex,
        value: value
    } : color;
}

var mapToColor = lerp;

function modifyHSL(color, h, s, l) {
    color = parse(color);

    if (color) {
        color = rgba2hsla(color);
        h != null && (color[0] = clampCssAngle(h));
        s != null && (color[1] = parseCssFloat(s));
        l != null && (color[2] = parseCssFloat(l));

        return stringify(hsla2rgba(color), 'rgba');
    }
}

function modifyAlpha(color, alpha) {
    color = parse(color);

    if (color && alpha != null) {
        color[3] = clampCssFloat(alpha);
        return stringify(color, 'rgba');
    }
}

function stringify(arrColor, type) {
    if (!arrColor || !arrColor.length) {
        return;
    }
    var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
    if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
        colorStr += ',' + arrColor[3];
    }
    return type + '(' + colorStr + ')';
}

/***/ }),

/***/ 41:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return debugMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return devicePixelRatio; });
var dpr = 1;

if (typeof window !== 'undefined') {
  dpr = Math.max(window.devicePixelRatio || 1, 1);
}

var debugMode = 0;

var devicePixelRatio = dpr;

/***/ }),

/***/ 42:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__ = __webpack_require__(0);



/* harmony default export */ __webpack_exports__["a"] = (function (properties) {
    for (var i = 0; i < properties.length; i++) {
        if (!properties[i][1]) {
            properties[i][1] = properties[i][0];
        }
    }
    return function (model, excludes, includes) {
        var style = {};
        for (var i = 0; i < properties.length; i++) {
            var propName = properties[i][1];
            if (excludes && __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["n" /* indexOf */](excludes, propName) >= 0 || includes && __WEBPACK_IMPORTED_MODULE_0_zrender_src_core_util__["n" /* indexOf */](includes, propName) < 0) {
                continue;
            }
            var val = model.getShallow(propName);
            if (val != null) {
                style[properties[i][0]] = val;
            }
        }
        return style;
    };
});

/***/ }),

/***/ 43:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/zrender/src/core/curve.js
var curve = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/vector.js
var vector = __webpack_require__(5);

// CONCATENATED MODULE: ./node_modules/zrender/src/core/bbox.js





var mathMin = Math.min;
var mathMax = Math.max;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI2 = Math.PI * 2;

var start = vector["e" /* create */]();
var end = vector["e" /* create */]();
var extremity = vector["e" /* create */]();

function fromPoints(points, min, max) {
    if (points.length === 0) {
        return;
    }
    var p = points[0];
    var left = p[0];
    var right = p[0];
    var top = p[1];
    var bottom = p[1];
    var i;

    for (i = 1; i < points.length; i++) {
        p = points[i];
        left = mathMin(left, p[0]);
        right = mathMax(right, p[0]);
        top = mathMin(top, p[1]);
        bottom = mathMax(bottom, p[1]);
    }

    min[0] = left;
    min[1] = top;
    max[0] = right;
    max[1] = bottom;
}

function fromLine(x0, y0, x1, y1, min, max) {
    min[0] = mathMin(x0, x1);
    min[1] = mathMin(y0, y1);
    max[0] = mathMax(x0, x1);
    max[1] = mathMax(y0, y1);
}

var xDim = [];
var yDim = [];

function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
    var cubicExtrema = curve["c" /* cubicExtrema */];
    var cubicAt = curve["a" /* cubicAt */];
    var i;
    var n = cubicExtrema(x0, x1, x2, x3, xDim);
    min[0] = Infinity;
    min[1] = Infinity;
    max[0] = -Infinity;
    max[1] = -Infinity;

    for (i = 0; i < n; i++) {
        var x = cubicAt(x0, x1, x2, x3, xDim[i]);
        min[0] = mathMin(x, min[0]);
        max[0] = mathMax(x, max[0]);
    }
    n = cubicExtrema(y0, y1, y2, y3, yDim);
    for (i = 0; i < n; i++) {
        var y = cubicAt(y0, y1, y2, y3, yDim[i]);
        min[1] = mathMin(y, min[1]);
        max[1] = mathMax(y, max[1]);
    }

    min[0] = mathMin(x0, min[0]);
    max[0] = mathMax(x0, max[0]);
    min[0] = mathMin(x3, min[0]);
    max[0] = mathMax(x3, max[0]);

    min[1] = mathMin(y0, min[1]);
    max[1] = mathMax(y0, max[1]);
    min[1] = mathMin(y3, min[1]);
    max[1] = mathMax(y3, max[1]);
}

function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
    var quadraticExtremum = curve["i" /* quadraticExtremum */];
    var quadraticAt = curve["g" /* quadraticAt */];

    var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
    var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);

    var x = quadraticAt(x0, x1, x2, tx);
    var y = quadraticAt(y0, y1, y2, ty);

    min[0] = mathMin(x0, x2, x);
    min[1] = mathMin(y0, y2, y);
    max[0] = mathMax(x0, x2, x);
    max[1] = mathMax(y0, y2, y);
}

function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
    var vec2Min = vector["j" /* min */];
    var vec2Max = vector["i" /* max */];

    var diff = Math.abs(startAngle - endAngle);

    if (diff % PI2 < 1e-4 && diff > 1e-4) {
        min[0] = x - rx;
        min[1] = y - ry;
        max[0] = x + rx;
        max[1] = y + ry;
        return;
    }

    start[0] = mathCos(startAngle) * rx + x;
    start[1] = mathSin(startAngle) * ry + y;

    end[0] = mathCos(endAngle) * rx + x;
    end[1] = mathSin(endAngle) * ry + y;

    vec2Min(min, start, end);
    vec2Max(max, start, end);

    startAngle = startAngle % PI2;
    if (startAngle < 0) {
        startAngle = startAngle + PI2;
    }
    endAngle = endAngle % PI2;
    if (endAngle < 0) {
        endAngle = endAngle + PI2;
    }

    if (startAngle > endAngle && !anticlockwise) {
        endAngle += PI2;
    } else if (startAngle < endAngle && anticlockwise) {
        startAngle += PI2;
    }
    if (anticlockwise) {
        var tmp = endAngle;
        endAngle = startAngle;
        startAngle = tmp;
    }

    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
        if (angle > startAngle) {
            extremity[0] = mathCos(angle) * rx + x;
            extremity[1] = mathSin(angle) * ry + y;

            vec2Min(min, extremity, min);
            vec2Max(max, extremity, max);
        }
    }
}
// EXTERNAL MODULE: ./node_modules/zrender/src/core/BoundingRect.js
var BoundingRect = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/zrender/src/config.js
var config = __webpack_require__(41);

// CONCATENATED MODULE: ./node_modules/zrender/src/core/PathProxy.js








var CMD = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,

    R: 7
};

var PathProxy_min = [];
var PathProxy_max = [];
var min2 = [];
var max2 = [];
var PathProxy_mathMin = Math.min;
var PathProxy_mathMax = Math.max;
var PathProxy_mathCos = Math.cos;
var PathProxy_mathSin = Math.sin;
var mathSqrt = Math.sqrt;
var mathAbs = Math.abs;

var hasTypedArray = typeof Float32Array != 'undefined';

var PathProxy = function PathProxy(notSaveData) {

    this._saveData = !(notSaveData || false);

    if (this._saveData) {
        this.data = [];
    }

    this._ctx = null;
};

PathProxy.prototype = {

    constructor: PathProxy,

    _xi: 0,
    _yi: 0,

    _x0: 0,
    _y0: 0,

    _ux: 0,
    _uy: 0,

    _len: 0,

    _lineDash: null,

    _dashOffset: 0,

    _dashIdx: 0,

    _dashSum: 0,

    setScale: function setScale(sx, sy) {
        this._ux = mathAbs(1 / config["b" /* devicePixelRatio */] / sx) || 0;
        this._uy = mathAbs(1 / config["b" /* devicePixelRatio */] / sy) || 0;
    },

    getContext: function getContext() {
        return this._ctx;
    },

    beginPath: function beginPath(ctx) {

        this._ctx = ctx;

        ctx && ctx.beginPath();

        ctx && (this.dpr = ctx.dpr);

        if (this._saveData) {
            this._len = 0;
        }

        if (this._lineDash) {
            this._lineDash = null;

            this._dashOffset = 0;
        }

        return this;
    },

    moveTo: function moveTo(x, y) {
        this.addData(CMD.M, x, y);
        this._ctx && this._ctx.moveTo(x, y);

        this._x0 = x;
        this._y0 = y;

        this._xi = x;
        this._yi = y;

        return this;
    },

    lineTo: function lineTo(x, y) {
        var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;

        this.addData(CMD.L, x, y);

        if (this._ctx && exceedUnit) {
            this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
        }
        if (exceedUnit) {
            this._xi = x;
            this._yi = y;
        }

        return this;
    },

    bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x3, y3) {
        this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
        if (this._ctx) {
            this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        this._xi = x3;
        this._yi = y3;
        return this;
    },

    quadraticCurveTo: function quadraticCurveTo(x1, y1, x2, y2) {
        this.addData(CMD.Q, x1, y1, x2, y2);
        if (this._ctx) {
            this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }
        this._xi = x2;
        this._yi = y2;
        return this;
    },

    arc: function arc(cx, cy, r, startAngle, endAngle, anticlockwise) {
        this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);

        this._xi = PathProxy_mathCos(endAngle) * r + cx;
        this._yi = PathProxy_mathSin(endAngle) * r + cx;
        return this;
    },

    arcTo: function arcTo(x1, y1, x2, y2, radius) {
        if (this._ctx) {
            this._ctx.arcTo(x1, y1, x2, y2, radius);
        }
        return this;
    },

    rect: function rect(x, y, w, h) {
        this._ctx && this._ctx.rect(x, y, w, h);
        this.addData(CMD.R, x, y, w, h);
        return this;
    },

    closePath: function closePath() {
        this.addData(CMD.Z);

        var ctx = this._ctx;
        var x0 = this._x0;
        var y0 = this._y0;
        if (ctx) {
            this._needsDash() && this._dashedLineTo(x0, y0);
            ctx.closePath();
        }

        this._xi = x0;
        this._yi = y0;
        return this;
    },

    fill: function fill(ctx) {
        ctx && ctx.fill();
        this.toStatic();
    },

    stroke: function stroke(ctx) {
        ctx && ctx.stroke();
        this.toStatic();
    },

    setLineDash: function setLineDash(lineDash) {
        if (lineDash instanceof Array) {
            this._lineDash = lineDash;

            this._dashIdx = 0;

            var lineDashSum = 0;
            for (var i = 0; i < lineDash.length; i++) {
                lineDashSum += lineDash[i];
            }
            this._dashSum = lineDashSum;
        }
        return this;
    },

    setLineDashOffset: function setLineDashOffset(offset) {
        this._dashOffset = offset;
        return this;
    },

    len: function len() {
        return this._len;
    },

    setData: function setData(data) {

        var len = data.length;

        if (!(this.data && this.data.length == len) && hasTypedArray) {
            this.data = new Float32Array(len);
        }

        for (var i = 0; i < len; i++) {
            this.data[i] = data[i];
        }

        this._len = len;
    },

    appendPath: function appendPath(path) {
        if (!(path instanceof Array)) {
            path = [path];
        }
        var len = path.length;
        var appendSize = 0;
        var offset = this._len;
        for (var i = 0; i < len; i++) {
            appendSize += path[i].len();
        }
        if (hasTypedArray && this.data instanceof Float32Array) {
            this.data = new Float32Array(offset + appendSize);
        }
        for (var i = 0; i < len; i++) {
            var appendPathData = path[i].data;
            for (var k = 0; k < appendPathData.length; k++) {
                this.data[offset++] = appendPathData[k];
            }
        }
        this._len = offset;
    },

    addData: function addData(cmd) {
        if (!this._saveData) {
            return;
        }

        var data = this.data;
        if (this._len + arguments.length > data.length) {
            this._expandData();
            data = this.data;
        }
        for (var i = 0; i < arguments.length; i++) {
            data[this._len++] = arguments[i];
        }

        this._prevCmd = cmd;
    },

    _expandData: function _expandData() {
        if (!(this.data instanceof Array)) {
            var newData = [];
            for (var i = 0; i < this._len; i++) {
                newData[i] = this.data[i];
            }
            this.data = newData;
        }
    },

    _needsDash: function _needsDash() {
        return this._lineDash;
    },

    _dashedLineTo: function _dashedLineTo(x1, y1) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;

        var x0 = this._xi;
        var y0 = this._yi;
        var dx = x1 - x0;
        var dy = y1 - y0;
        var dist = mathSqrt(dx * dx + dy * dy);
        var x = x0;
        var y = y0;
        var dash;
        var nDash = lineDash.length;
        var idx;
        dx /= dist;
        dy /= dist;

        if (offset < 0) {
            offset = dashSum + offset;
        }
        offset %= dashSum;
        x -= offset * dx;
        y -= offset * dy;

        while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx == 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
            idx = this._dashIdx;
            dash = lineDash[idx];
            x += dx * dash;
            y += dy * dash;
            this._dashIdx = (idx + 1) % nDash;

            if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
                continue;
            }
            ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? PathProxy_mathMin(x, x1) : PathProxy_mathMax(x, x1), dy >= 0 ? PathProxy_mathMin(y, y1) : PathProxy_mathMax(y, y1));
        }

        dx = x - x1;
        dy = y - y1;
        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
    },

    _dashedBezierTo: function _dashedBezierTo(x1, y1, x2, y2, x3, y3) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;

        var x0 = this._xi;
        var y0 = this._yi;
        var t;
        var dx;
        var dy;
        var cubicAt = curve["a" /* cubicAt */];
        var bezierLen = 0;
        var idx = this._dashIdx;
        var nDash = lineDash.length;

        var x;
        var y;

        var tmpLen = 0;

        if (offset < 0) {
            offset = dashSum + offset;
        }
        offset %= dashSum;

        for (t = 0; t < 1; t += 0.1) {
            dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
            dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
            bezierLen += mathSqrt(dx * dx + dy * dy);
        }

        for (; idx < nDash; idx++) {
            tmpLen += lineDash[idx];
            if (tmpLen > offset) {
                break;
            }
        }
        t = (tmpLen - offset) / bezierLen;

        while (t <= 1) {

            x = cubicAt(x0, x1, x2, x3, t);
            y = cubicAt(y0, y1, y2, y3, t);

            idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);

            t += lineDash[idx] / bezierLen;

            idx = (idx + 1) % nDash;
        }

        idx % 2 !== 0 && ctx.lineTo(x3, y3);
        dx = x3 - x;
        dy = y3 - y;
        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
    },

    _dashedQuadraticTo: function _dashedQuadraticTo(x1, y1, x2, y2) {
        var x3 = x2;
        var y3 = y2;
        x2 = (x2 + 2 * x1) / 3;
        y2 = (y2 + 2 * y1) / 3;
        x1 = (this._xi + 2 * x1) / 3;
        y1 = (this._yi + 2 * y1) / 3;

        this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
    },

    toStatic: function toStatic() {
        var data = this.data;
        if (data instanceof Array) {
            data.length = this._len;
            if (hasTypedArray) {
                this.data = new Float32Array(data);
            }
        }
    },

    getBoundingRect: function getBoundingRect() {
        PathProxy_min[0] = PathProxy_min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
        PathProxy_max[0] = PathProxy_max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;

        var data = this.data;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;

        for (var i = 0; i < data.length;) {
            var cmd = data[i++];

            if (i == 1) {
                xi = data[i];
                yi = data[i + 1];

                x0 = xi;
                y0 = yi;
            }

            switch (cmd) {
                case CMD.M:
                    x0 = data[i++];
                    y0 = data[i++];
                    xi = x0;
                    yi = y0;
                    min2[0] = x0;
                    min2[1] = y0;
                    max2[0] = x0;
                    max2[1] = y0;
                    break;
                case CMD.L:
                    fromLine(xi, yi, data[i], data[i + 1], min2, max2);
                    xi = data[i++];
                    yi = data[i++];
                    break;
                case CMD.C:
                    fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
                    xi = data[i++];
                    yi = data[i++];
                    break;
                case CMD.Q:
                    fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
                    xi = data[i++];
                    yi = data[i++];
                    break;
                case CMD.A:
                    var cx = data[i++];
                    var cy = data[i++];
                    var rx = data[i++];
                    var ry = data[i++];
                    var startAngle = data[i++];
                    var endAngle = data[i++] + startAngle;

                    var psi = data[i++];
                    var anticlockwise = 1 - data[i++];

                    if (i == 1) {
                        x0 = PathProxy_mathCos(startAngle) * rx + cx;
                        y0 = PathProxy_mathSin(startAngle) * ry + cy;
                    }

                    fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);

                    xi = PathProxy_mathCos(endAngle) * rx + cx;
                    yi = PathProxy_mathSin(endAngle) * ry + cy;
                    break;
                case CMD.R:
                    x0 = xi = data[i++];
                    y0 = yi = data[i++];
                    var width = data[i++];
                    var height = data[i++];

                    fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
                    break;
                case CMD.Z:
                    xi = x0;
                    yi = y0;
                    break;
            }

            vector["j" /* min */](PathProxy_min, PathProxy_min, min2);
            vector["i" /* max */](PathProxy_max, PathProxy_max, max2);
        }

        if (i === 0) {
            PathProxy_min[0] = PathProxy_min[1] = PathProxy_max[0] = PathProxy_max[1] = 0;
        }

        return new BoundingRect["a" /* default */](PathProxy_min[0], PathProxy_min[1], PathProxy_max[0] - PathProxy_min[0], PathProxy_max[1] - PathProxy_min[1]);
    },

    rebuildPath: function rebuildPath(ctx) {
        var d = this.data;
        var x0, y0;
        var xi, yi;
        var x, y;
        var ux = this._ux;
        var uy = this._uy;
        var len = this._len;
        for (var i = 0; i < len;) {
            var cmd = d[i++];

            if (i == 1) {
                xi = d[i];
                yi = d[i + 1];

                x0 = xi;
                y0 = yi;
            }
            switch (cmd) {
                case CMD.M:
                    x0 = xi = d[i++];
                    y0 = yi = d[i++];
                    ctx.moveTo(xi, yi);
                    break;
                case CMD.L:
                    x = d[i++];
                    y = d[i++];

                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
                        ctx.lineTo(x, y);
                        xi = x;
                        yi = y;
                    }
                    break;
                case CMD.C:
                    ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
                    xi = d[i - 2];
                    yi = d[i - 1];
                    break;
                case CMD.Q:
                    ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
                    xi = d[i - 2];
                    yi = d[i - 1];
                    break;
                case CMD.A:
                    var cx = d[i++];
                    var cy = d[i++];
                    var rx = d[i++];
                    var ry = d[i++];
                    var theta = d[i++];
                    var dTheta = d[i++];
                    var psi = d[i++];
                    var fs = d[i++];
                    var r = rx > ry ? rx : ry;
                    var scaleX = rx > ry ? 1 : rx / ry;
                    var scaleY = rx > ry ? ry / rx : 1;
                    var isEllipse = Math.abs(rx - ry) > 1e-3;
                    var endAngle = theta + dTheta;
                    if (isEllipse) {
                        ctx.translate(cx, cy);
                        ctx.rotate(psi);
                        ctx.scale(scaleX, scaleY);
                        ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
                        ctx.scale(1 / scaleX, 1 / scaleY);
                        ctx.rotate(-psi);
                        ctx.translate(-cx, -cy);
                    } else {
                        ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
                    }

                    if (i == 1) {
                        x0 = PathProxy_mathCos(theta) * rx + cx;
                        y0 = PathProxy_mathSin(theta) * ry + cy;
                    }
                    xi = PathProxy_mathCos(endAngle) * rx + cx;
                    yi = PathProxy_mathSin(endAngle) * ry + cy;
                    break;
                case CMD.R:
                    x0 = xi = d[i];
                    y0 = yi = d[i + 1];
                    ctx.rect(d[i++], d[i++], d[i++], d[i++]);
                    break;
                case CMD.Z:
                    ctx.closePath();
                    xi = x0;
                    yi = y0;
            }
        }
    }
};

PathProxy.CMD = CMD;

/* harmony default export */ var core_PathProxy = __webpack_exports__["a"] = (PathProxy);

/***/ }),

/***/ 5:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = create;
/* harmony export (immutable) */ __webpack_exports__["d"] = copy;
/* harmony export (immutable) */ __webpack_exports__["c"] = clone;
/* unused harmony export set */
/* harmony export (immutable) */ __webpack_exports__["a"] = add;
/* harmony export (immutable) */ __webpack_exports__["m"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["n"] = sub;
/* unused harmony export len */
/* unused harmony export length */
/* unused harmony export lenSquare */
/* unused harmony export lengthSquare */
/* unused harmony export mul */
/* unused harmony export div */
/* unused harmony export dot */
/* harmony export (immutable) */ __webpack_exports__["l"] = scale;
/* harmony export (immutable) */ __webpack_exports__["k"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["h"] = distance;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return dist; });
/* unused harmony export distanceSquare */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return distSquare; });
/* unused harmony export negate */
/* unused harmony export lerp */
/* harmony export (immutable) */ __webpack_exports__["b"] = applyTransform;
/* harmony export (immutable) */ __webpack_exports__["j"] = min;
/* harmony export (immutable) */ __webpack_exports__["i"] = max;

var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;

function create(x, y) {
    var out = new ArrayCtor(2);
    if (x == null) {
        x = 0;
    }
    if (y == null) {
        y = 0;
    }
    out[0] = x;
    out[1] = y;
    return out;
}

function copy(out, v) {
    out[0] = v[0];
    out[1] = v[1];
    return out;
}

function clone(v) {
    var out = new ArrayCtor(2);
    out[0] = v[0];
    out[1] = v[1];
    return out;
}

function set(out, a, b) {
    out[0] = a;
    out[1] = b;
    return out;
}

function add(out, v1, v2) {
    out[0] = v1[0] + v2[0];
    out[1] = v1[1] + v2[1];
    return out;
}

function scaleAndAdd(out, v1, v2, a) {
    out[0] = v1[0] + v2[0] * a;
    out[1] = v1[1] + v2[1] * a;
    return out;
}

function sub(out, v1, v2) {
    out[0] = v1[0] - v2[0];
    out[1] = v1[1] - v2[1];
    return out;
}

function len(v) {
    return Math.sqrt(lenSquare(v));
}
var length = len;
function lenSquare(v) {
    return v[0] * v[0] + v[1] * v[1];
}
var lengthSquare = lenSquare;

function mul(out, v1, v2) {
    out[0] = v1[0] * v2[0];
    out[1] = v1[1] * v2[1];
    return out;
}

function div(out, v1, v2) {
    out[0] = v1[0] / v2[0];
    out[1] = v1[1] / v2[1];
    return out;
}

function dot(v1, v2) {
    return v1[0] * v2[0] + v1[1] * v2[1];
}

function scale(out, v, s) {
    out[0] = v[0] * s;
    out[1] = v[1] * s;
    return out;
}

function normalize(out, v) {
    var d = len(v);
    if (d === 0) {
        out[0] = 0;
        out[1] = 0;
    } else {
        out[0] = v[0] / d;
        out[1] = v[1] / d;
    }
    return out;
}

function distance(v1, v2) {
    return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
}
var dist = distance;

function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
var distSquare = distanceSquare;

function negate(out, v) {
    out[0] = -v[0];
    out[1] = -v[1];
    return out;
}

function lerp(out, v1, v2, t) {
    out[0] = v1[0] + t * (v2[0] - v1[0]);
    out[1] = v1[1] + t * (v2[1] - v1[1]);
    return out;
}

function applyTransform(out, v, m) {
    var x = v[0];
    var y = v[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}

function min(out, v1, v2) {
    out[0] = Math.min(v1[0], v2[0]);
    out[1] = Math.min(v1[1], v2[1]);
    return out;
}

function max(out, v1, v2) {
    out[0] = Math.max(v1[0], v2[0]);
    out[1] = Math.max(v1[1], v2[1]);
    return out;
}

/***/ }),

/***/ 56:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/zrender/src/core/util.js
var util = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Style.js
var Style = __webpack_require__(97);

// EXTERNAL MODULE: ./node_modules/zrender/src/Element.js + 1 modules
var Element = __webpack_require__(92);

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/helper/text.js
var helper_text = __webpack_require__(100);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/BoundingRect.js
var BoundingRect = __webpack_require__(11);

// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/mixin/RectText.js





var tmpRect = new BoundingRect["a" /* default */]();

var RectText = function RectText() {};

RectText.prototype = {

    constructor: RectText,

    drawRectText: function drawRectText(ctx, rect) {
        var style = this.style;

        rect = style.textRect || rect;

        this.__dirty && helper_text["c" /* normalizeTextStyle */](style, true);

        var text = style.text;

        text != null && (text += '');

        if (!helper_text["b" /* needDrawText */](text, style)) {
            return;
        }

        ctx.save();

        var transform = this.transform;
        if (!style.transformText) {
            if (transform) {
                tmpRect.copy(rect);
                tmpRect.applyTransform(transform);
                rect = tmpRect;
            }
        } else {
            this.setTransform(ctx);
        }

        helper_text["d" /* renderText */](this, ctx, text, style, rect);

        ctx.restore();
    }
};

/* harmony default export */ var mixin_RectText = (RectText);
// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/Displayable.js







function Displayable(opts) {

  opts = opts || {};

  Element["a" /* default */].call(this, opts);

  for (var name in opts) {
    if (opts.hasOwnProperty(name) && name !== 'style') {
      this[name] = opts[name];
    }
  }

  this.style = new Style["a" /* default */](opts.style, this);

  this._rect = null;

  this.__clipPaths = [];
}

Displayable.prototype = {

  constructor: Displayable,

  type: 'displayable',

  __dirty: true,

  invisible: false,

  z: 0,

  z2: 0,

  zlevel: 0,

  draggable: false,

  dragging: false,

  silent: false,

  culling: false,

  cursor: 'pointer',

  rectHover: false,

  progressive: -1,

  beforeBrush: function beforeBrush(ctx) {},

  afterBrush: function afterBrush(ctx) {},

  brush: function brush(ctx, prevEl) {},

  getBoundingRect: function getBoundingRect() {},

  contain: function contain(x, y) {
    return this.rectContain(x, y);
  },

  traverse: function traverse(cb, context) {
    cb.call(context, this);
  },

  rectContain: function rectContain(x, y) {
    var coord = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  },

  dirty: function dirty() {
    this.__dirty = true;

    this._rect = null;

    this.__zr && this.__zr.refresh();
  },

  animateStyle: function animateStyle(loop) {
    return this.animate('style', loop);
  },

  attrKV: function attrKV(key, value) {
    if (key !== 'style') {
      Element["a" /* default */].prototype.attrKV.call(this, key, value);
    } else {
      this.style.set(value);
    }
  },

  setStyle: function setStyle(key, value) {
    this.style.set(key, value);
    this.dirty(false);
    return this;
  },

  useStyle: function useStyle(obj) {
    this.style = new Style["a" /* default */](obj, this);
    this.dirty(false);
    return this;
  }
};

util["o" /* inherits */](Displayable, Element["a" /* default */]);

util["y" /* mixin */](Displayable, mixin_RectText);


/* harmony default export */ var graphic_Displayable = __webpack_exports__["a"] = (Displayable);

/***/ }),

/***/ 57:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = findExistImage;
/* harmony export (immutable) */ __webpack_exports__["a"] = createOrUpdateImage;
/* harmony export (immutable) */ __webpack_exports__["c"] = isImageReady;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_LRU__ = __webpack_require__(95);



var globalImageCache = new __WEBPACK_IMPORTED_MODULE_0__core_LRU__["a" /* default */](50);

function findExistImage(newImageOrSrc) {
    if (typeof newImageOrSrc === 'string') {
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        return cachedImgObj && cachedImgObj.image;
    } else {
        return newImageOrSrc;
    }
}

function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
    if (!newImageOrSrc) {
        return image;
    } else if (typeof newImageOrSrc === 'string') {
        if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
            return image;
        }

        var cachedImgObj = globalImageCache.get(newImageOrSrc);

        var pendingWrap = { hostEl: hostEl, cb: cb, cbPayload: cbPayload };

        if (cachedImgObj) {
            image = cachedImgObj.image;
            !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
        } else {
            !image && (image = new Image());
            image.onload = imageOnLoad;

            globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
                image: image,
                pending: [pendingWrap]
            });

            image.src = image.__zrImageSrc = newImageOrSrc;
        }

        return image;
    } else {
            return newImageOrSrc;
        }
}

function imageOnLoad() {
    var cachedImgObj = this.__cachedImgObj;
    this.onload = this.__cachedImgObj = null;

    for (var i = 0; i < cachedImgObj.pending.length; i++) {
        var pendingWrap = cachedImgObj.pending[i];
        var cb = pendingWrap.cb;
        cb && cb(this, pendingWrap.cbPayload);
        pendingWrap.hostEl.dirty();
    }
    cachedImgObj.pending.length = 0;
}

function isImageReady(image) {
    return image && image.width && image.height;
}

/***/ }),

/***/ 58:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var Gradient = function Gradient(colorStops) {

    this.colorStops = colorStops || [];
};

Gradient.prototype = {

    constructor: Gradient,

    addColorStop: function addColorStop(offset, color) {
        this.colorStops.push({

            offset: offset,

            color: color
        });
    }

};

/* harmony default export */ __webpack_exports__["a"] = (Gradient);

/***/ }),

/***/ 59:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

function defaultKeyGetter(item) {
    return item;
}

function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
    this._old = oldArr;
    this._new = newArr;

    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;

    this.context = context;
}

DataDiffer.prototype = {

    constructor: DataDiffer,

    add: function add(func) {
        this._add = func;
        return this;
    },

    update: function update(func) {
        this._update = func;
        return this;
    },

    remove: function remove(func) {
        this._remove = func;
        return this;
    },

    execute: function execute() {
        var oldArr = this._old;
        var newArr = this._new;

        var oldDataIndexMap = {};
        var newDataIndexMap = {};
        var oldDataKeyArr = [];
        var newDataKeyArr = [];
        var i;

        initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);
        initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this);

        for (i = 0; i < oldArr.length; i++) {
            var key = oldDataKeyArr[i];
            var idx = newDataIndexMap[key];

            if (idx != null) {
                var len = idx.length;
                if (len) {
                    len === 1 && (newDataIndexMap[key] = null);
                    idx = idx.unshift();
                } else {
                    newDataIndexMap[key] = null;
                }
                this._update && this._update(idx, i);
            } else {
                this._remove && this._remove(i);
            }
        }

        for (var i = 0; i < newDataKeyArr.length; i++) {
            var key = newDataKeyArr[i];
            if (newDataIndexMap.hasOwnProperty(key)) {
                var idx = newDataIndexMap[key];
                if (idx == null) {
                    continue;
                }

                if (!idx.length) {
                    this._add && this._add(idx);
                } else {
                    for (var j = 0, len = idx.length; j < len; j++) {
                        this._add && this._add(idx[j]);
                    }
                }
            }
        }
    }
};

function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {
    for (var i = 0; i < arr.length; i++) {
        var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);
        var existence = map[key];
        if (existence == null) {
            keyArr.push(key);
            map[key] = i;
        } else {
            if (!existence.length) {
                map[key] = existence = [existence];
            }
            existence.push(i);
        }
    }
}

/* harmony default export */ __webpack_exports__["a"] = (DataDiffer);

/***/ }),

/***/ 6:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Displayable.js + 1 modules
var Displayable = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/util.js
var util = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/PathProxy.js + 1 modules
var PathProxy = __webpack_require__(43);

// CONCATENATED MODULE: ./node_modules/zrender/src/contain/line.js

function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;
    var _a = 0;
    var _b = x0;

    if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
        return false;
    }

    if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
    } else {
        return Math.abs(x - x0) <= _l / 2;
    }
    var tmp = _a * x - y + _b;
    var _s = tmp * tmp / (_a * _a + 1);
    return _s <= _l / 2 * _l / 2;
}
// EXTERNAL MODULE: ./node_modules/zrender/src/core/curve.js
var curve = __webpack_require__(22);

// CONCATENATED MODULE: ./node_modules/zrender/src/contain/cubic.js



function cubic_containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;

    if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
        return false;
    }
    var d = curve["d" /* cubicProjectPoint */](x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
    return d <= _l / 2;
}
// CONCATENATED MODULE: ./node_modules/zrender/src/contain/quadratic.js


function quadratic_containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;

    if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
        return false;
    }
    var d = Object(curve["j" /* quadraticProjectPoint */])(x0, y0, x1, y1, x2, y2, x, y, null);
    return d <= _l / 2;
}
// CONCATENATED MODULE: ./node_modules/zrender/src/contain/util.js

var PI2 = Math.PI * 2;

function normalizeRadian(angle) {
    angle %= PI2;
    if (angle < 0) {
        angle += PI2;
    }
    return angle;
}
// CONCATENATED MODULE: ./node_modules/zrender/src/contain/arc.js



var arc_PI2 = Math.PI * 2;

function arc_containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {

    if (lineWidth === 0) {
        return false;
    }
    var _l = lineWidth;

    x -= cx;
    y -= cy;
    var d = Math.sqrt(x * x + y * y);

    if (d - _l > r || d + _l < r) {
        return false;
    }
    if (Math.abs(startAngle - endAngle) % arc_PI2 < 1e-4) {
        return true;
    }
    if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
    } else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
        endAngle += arc_PI2;
    }

    var angle = Math.atan2(y, x);
    if (angle < 0) {
        angle += arc_PI2;
    }
    return angle >= startAngle && angle <= endAngle || angle + arc_PI2 >= startAngle && angle + arc_PI2 <= endAngle;
}
// CONCATENATED MODULE: ./node_modules/zrender/src/contain/windingLine.js

function windingLine(x0, y0, x1, y1, x, y) {
    if (y > y0 && y > y1 || y < y0 && y < y1) {
        return 0;
    }

    if (y1 === y0) {
        return 0;
    }
    var dir = y1 < y0 ? 1 : -1;
    var t = (y - y0) / (y1 - y0);

    if (t === 1 || t === 0) {
        dir = y1 < y0 ? 0.5 : -0.5;
    }

    var x_ = t * (x1 - x0) + x0;

    return x_ > x ? dir : 0;
}
// CONCATENATED MODULE: ./node_modules/zrender/src/contain/path.js









var CMD = PathProxy["a" /* default */].CMD;
var path_PI2 = Math.PI * 2;

var EPSILON = 1e-4;

function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}

var roots = [-1, -1, -1];
var extrema = [-1, -1];

function swapExtrema() {
    var tmp = extrema[0];
    extrema[0] = extrema[1];
    extrema[1] = tmp;
}

function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
        return 0;
    }
    var nRoots = curve["e" /* cubicRootAt */](y0, y1, y2, y3, y, roots);
    if (nRoots === 0) {
        return 0;
    } else {
        var w = 0;
        var nExtrema = -1;
        var y0_, y1_;
        for (var i = 0; i < nRoots; i++) {
            var t = roots[i];

            var unit = t === 0 || t === 1 ? 0.5 : 1;

            var x_ = curve["a" /* cubicAt */](x0, x1, x2, x3, t);
            if (x_ < x) {
                continue;
            }
            if (nExtrema < 0) {
                nExtrema = curve["c" /* cubicExtrema */](y0, y1, y2, y3, extrema);
                if (extrema[1] < extrema[0] && nExtrema > 1) {
                    swapExtrema();
                }
                y0_ = curve["a" /* cubicAt */](y0, y1, y2, y3, extrema[0]);
                if (nExtrema > 1) {
                    y1_ = curve["a" /* cubicAt */](y0, y1, y2, y3, extrema[1]);
                }
            }
            if (nExtrema == 2) {
                if (t < extrema[0]) {
                    w += y0_ < y0 ? unit : -unit;
                } else if (t < extrema[1]) {
                    w += y1_ < y0_ ? unit : -unit;
                } else {
                    w += y3 < y1_ ? unit : -unit;
                }
            } else {
                if (t < extrema[0]) {
                    w += y0_ < y0 ? unit : -unit;
                } else {
                    w += y3 < y0_ ? unit : -unit;
                }
            }
        }
        return w;
    }
}

function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
        return 0;
    }
    var nRoots = curve["k" /* quadraticRootAt */](y0, y1, y2, y, roots);
    if (nRoots === 0) {
        return 0;
    } else {
        var t = curve["i" /* quadraticExtremum */](y0, y1, y2);
        if (t >= 0 && t <= 1) {
            var w = 0;
            var y_ = curve["g" /* quadraticAt */](y0, y1, y2, t);
            for (var i = 0; i < nRoots; i++) {
                var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;

                var x_ = curve["g" /* quadraticAt */](x0, x1, x2, roots[i]);
                if (x_ < x) {
                    continue;
                }
                if (roots[i] < t) {
                    w += y_ < y0 ? unit : -unit;
                } else {
                    w += y2 < y_ ? unit : -unit;
                }
            }
            return w;
        } else {
            var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;

            var x_ = curve["g" /* quadraticAt */](x0, x1, x2, roots[0]);
            if (x_ < x) {
                return 0;
            }
            return y2 < y0 ? unit : -unit;
        }
    }
}

function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    y -= cy;
    if (y > r || y < -r) {
        return 0;
    }
    var tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp;
    roots[1] = tmp;

    var diff = Math.abs(startAngle - endAngle);
    if (diff < 1e-4) {
        return 0;
    }
    if (diff % path_PI2 < 1e-4) {
        startAngle = 0;
        endAngle = path_PI2;
        var dir = anticlockwise ? 1 : -1;
        if (x >= roots[0] + cx && x <= roots[1] + cx) {
            return dir;
        } else {
            return 0;
        }
    }

    if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
    } else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
        endAngle += path_PI2;
    }

    var w = 0;
    for (var i = 0; i < 2; i++) {
        var x_ = roots[i];
        if (x_ + cx > x) {
            var angle = Math.atan2(y, x_);
            var dir = anticlockwise ? 1 : -1;
            if (angle < 0) {
                angle = path_PI2 + angle;
            }
            if (angle >= startAngle && angle <= endAngle || angle + path_PI2 >= startAngle && angle + path_PI2 <= endAngle) {
                if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
                    dir = -dir;
                }
                w += dir;
            }
        }
    }
    return w;
}

function containPath(data, lineWidth, isStroke, x, y) {
    var w = 0;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;

    for (var i = 0; i < data.length;) {
        var cmd = data[i++];

        if (cmd === CMD.M && i > 1) {
            if (!isStroke) {
                w += windingLine(xi, yi, x0, y0, x, y);
            }
        }

        if (i == 1) {
            xi = data[i];
            yi = data[i + 1];

            x0 = xi;
            y0 = yi;
        }

        switch (cmd) {
            case CMD.M:
                x0 = data[i++];
                y0 = data[i++];
                xi = x0;
                yi = y0;
                break;
            case CMD.L:
                if (isStroke) {
                    if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
                        return true;
                    }
                } else {
                    w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
                }
                xi = data[i++];
                yi = data[i++];
                break;
            case CMD.C:
                if (isStroke) {
                    if (cubic_containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                        return true;
                    }
                } else {
                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
                }
                xi = data[i++];
                yi = data[i++];
                break;
            case CMD.Q:
                if (isStroke) {
                    if (quadratic_containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                        return true;
                    }
                } else {
                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
                }
                xi = data[i++];
                yi = data[i++];
                break;
            case CMD.A:
                var cx = data[i++];
                var cy = data[i++];
                var rx = data[i++];
                var ry = data[i++];
                var theta = data[i++];
                var dTheta = data[i++];

                var psi = data[i++];
                var anticlockwise = 1 - data[i++];
                var x1 = Math.cos(theta) * rx + cx;
                var y1 = Math.sin(theta) * ry + cy;

                if (i > 1) {
                    w += windingLine(xi, yi, x1, y1, x, y);
                } else {
                    x0 = x1;
                    y0 = y1;
                }

                var _x = (x - cx) * ry / rx + cx;
                if (isStroke) {
                    if (arc_containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
                        return true;
                    }
                } else {
                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
                }
                xi = Math.cos(theta + dTheta) * rx + cx;
                yi = Math.sin(theta + dTheta) * ry + cy;
                break;
            case CMD.R:
                x0 = xi = data[i++];
                y0 = yi = data[i++];
                var width = data[i++];
                var height = data[i++];
                var x1 = x0 + width;
                var y1 = y0 + height;
                if (isStroke) {
                    if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
                        return true;
                    }
                } else {
                    w += windingLine(x1, y0, x1, y1, x, y);
                    w += windingLine(x0, y1, x0, y0, x, y);
                }
                break;
            case CMD.Z:
                if (isStroke) {
                    if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
                        return true;
                    }
                } else {
                    w += windingLine(xi, yi, x0, y0, x, y);
                }
                xi = x0;
                yi = y0;
                break;
        }
    }
    if (!isStroke && !isAroundEqual(yi, y0)) {
        w += windingLine(xi, yi, x0, y0, x, y) || 0;
    }
    return w !== 0;
}

function path_contain(pathData, x, y) {
    return containPath(pathData, 0, false, x, y);
}

function path_containStroke(pathData, lineWidth, x, y) {
    return containPath(pathData, lineWidth, true, x, y);
}
// EXTERNAL MODULE: ./node_modules/zrender/src/graphic/Pattern.js
var Pattern = __webpack_require__(98);

// CONCATENATED MODULE: ./node_modules/zrender/src/graphic/Path.js






var getCanvasPattern = Pattern["a" /* default */].prototype.getCanvasPattern;

var abs = Math.abs;

var pathProxyForDraw = new PathProxy["a" /* default */](true);

function Path(opts) {
    Displayable["a" /* default */].call(this, opts);

    this.path = null;
}

Path.prototype = {

    constructor: Path,

    type: 'path',

    __dirtyPath: true,

    strokeContainThreshold: 5,

    brush: function brush(ctx, prevEl) {
        var style = this.style;
        var path = this.path || pathProxyForDraw;
        var hasStroke = style.hasStroke();
        var hasFill = style.hasFill();
        var fill = style.fill;
        var stroke = style.stroke;
        var hasFillGradient = hasFill && !!fill.colorStops;
        var hasStrokeGradient = hasStroke && !!stroke.colorStops;
        var hasFillPattern = hasFill && !!fill.image;
        var hasStrokePattern = hasStroke && !!stroke.image;

        style.bind(ctx, this, prevEl);
        this.setTransform(ctx);

        if (this.__dirty) {
            var rect;

            if (hasFillGradient) {
                rect = rect || this.getBoundingRect();
                this._fillGradient = style.getGradient(ctx, fill, rect);
            }
            if (hasStrokeGradient) {
                rect = rect || this.getBoundingRect();
                this._strokeGradient = style.getGradient(ctx, stroke, rect);
            }
        }

        if (hasFillGradient) {
            ctx.fillStyle = this._fillGradient;
        } else if (hasFillPattern) {
            ctx.fillStyle = getCanvasPattern.call(fill, ctx);
        }
        if (hasStrokeGradient) {
            ctx.strokeStyle = this._strokeGradient;
        } else if (hasStrokePattern) {
            ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
        }

        var lineDash = style.lineDash;
        var lineDashOffset = style.lineDashOffset;

        var ctxLineDash = !!ctx.setLineDash;

        var scale = this.getGlobalScale();
        path.setScale(scale[0], scale[1]);

        if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
            path.beginPath(ctx);

            if (lineDash && !ctxLineDash) {
                path.setLineDash(lineDash);
                path.setLineDashOffset(lineDashOffset);
            }

            this.buildPath(path, this.shape, false);

            if (this.path) {
                this.__dirtyPath = false;
            }
        } else {
            ctx.beginPath();
            this.path.rebuildPath(ctx);
        }

        hasFill && path.fill(ctx);

        if (lineDash && ctxLineDash) {
            ctx.setLineDash(lineDash);
            ctx.lineDashOffset = lineDashOffset;
        }

        hasStroke && path.stroke(ctx);

        if (lineDash && ctxLineDash) {
            ctx.setLineDash([]);
        }

        this.restoreTransform(ctx);

        if (style.text != null) {
            this.drawRectText(ctx, this.getBoundingRect());
        }
    },

    buildPath: function buildPath(ctx, shapeCfg, inBundle) {},

    createPathProxy: function createPathProxy() {
        this.path = new PathProxy["a" /* default */]();
    },

    getBoundingRect: function getBoundingRect() {
        var rect = this._rect;
        var style = this.style;
        var needsUpdateRect = !rect;
        if (needsUpdateRect) {
            var path = this.path;
            if (!path) {
                path = this.path = new PathProxy["a" /* default */]();
            }
            if (this.__dirtyPath) {
                path.beginPath();
                this.buildPath(path, this.shape, false);
            }
            rect = path.getBoundingRect();
        }
        this._rect = rect;

        if (style.hasStroke()) {
            var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
            if (this.__dirty || needsUpdateRect) {
                rectWithStroke.copy(rect);

                var w = style.lineWidth;

                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;

                if (!style.hasFill()) {
                    w = Math.max(w, this.strokeContainThreshold || 4);
                }

                if (lineScale > 1e-10) {
                    rectWithStroke.width += w / lineScale;
                    rectWithStroke.height += w / lineScale;
                    rectWithStroke.x -= w / lineScale / 2;
                    rectWithStroke.y -= w / lineScale / 2;
                }
            }

            return rectWithStroke;
        }

        return rect;
    },

    contain: function contain(x, y) {
        var localPos = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        var style = this.style;
        x = localPos[0];
        y = localPos[1];

        if (rect.contain(x, y)) {
            var pathData = this.path.data;
            if (style.hasStroke()) {
                var lineWidth = style.lineWidth;
                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;

                if (lineScale > 1e-10) {
                    if (!style.hasFill()) {
                        lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
                    }
                    if (path_containStroke(pathData, lineWidth / lineScale, x, y)) {
                        return true;
                    }
                }
            }
            if (style.hasFill()) {
                return path_contain(pathData, x, y);
            }
        }
        return false;
    },

    dirty: function dirty(dirtyPath) {
        if (dirtyPath == null) {
            dirtyPath = true;
        }

        if (dirtyPath) {
            this.__dirtyPath = dirtyPath;
            this._rect = null;
        }

        this.__dirty = true;

        this.__zr && this.__zr.refresh();

        if (this.__clipTarget) {
            this.__clipTarget.dirty();
        }
    },

    animateShape: function animateShape(loop) {
        return this.animate('shape', loop);
    },

    attrKV: function attrKV(key, value) {
        if (key === 'shape') {
            this.setShape(value);
            this.__dirtyPath = true;
            this._rect = null;
        } else {
            Displayable["a" /* default */].prototype.attrKV.call(this, key, value);
        }
    },

    setShape: function setShape(key, value) {
        var shape = this.shape;

        if (shape) {
            if (util["t" /* isObject */](key)) {
                for (var name in key) {
                    if (key.hasOwnProperty(name)) {
                        shape[name] = key[name];
                    }
                }
            } else {
                shape[key] = value;
            }
            this.dirty(true);
        }
        return this;
    },

    getLineScale: function getLineScale() {
        var m = this.transform;

        return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
    }
};

Path.extend = function (defaults) {
    var Sub = function Sub(opts) {
        Path.call(this, opts);

        if (defaults.style) {
            this.style.extendFrom(defaults.style, false);
        }

        var defaultShape = defaults.shape;
        if (defaultShape) {
            this.shape = this.shape || {};
            var thisShape = this.shape;
            for (var name in defaultShape) {
                if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
                    thisShape[name] = defaultShape[name];
                }
            }
        }

        defaults.init && defaults.init.call(this, opts);
    };

    util["o" /* inherits */](Sub, Path);

    for (var name in defaults) {
        if (name !== 'style' && name !== 'shape') {
            Sub.prototype[name] = defaults[name];
        }
    }

    return Sub;
};

util["o" /* inherits */](Path, Displayable["a" /* default */]);

/* harmony default export */ var graphic_Path = __webpack_exports__["a"] = (Path);

/***/ }),

/***/ 91:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var idStart = 0x0907;

/* harmony default export */ __webpack_exports__["a"] = (function () {
  return idStart++;
});

/***/ }),

/***/ 92:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/zrender/src/core/guid.js
var guid = __webpack_require__(91);

// EXTERNAL MODULE: ./node_modules/zrender/src/mixin/Eventful.js
var Eventful = __webpack_require__(21);

// EXTERNAL MODULE: ./node_modules/zrender/src/mixin/Transformable.js
var Transformable = __webpack_require__(93);

// EXTERNAL MODULE: ./node_modules/zrender/src/animation/Animator.js + 2 modules
var Animator = __webpack_require__(94);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/log.js
var log = __webpack_require__(96);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/util.js
var util = __webpack_require__(0);

// CONCATENATED MODULE: ./node_modules/zrender/src/mixin/Animatable.js




var Animatable = function Animatable() {
    this.animators = [];
};

Animatable.prototype = {

    constructor: Animatable,

    animate: function animate(path, loop) {
        var target;
        var animatingShape = false;
        var el = this;
        var zr = this.__zr;
        if (path) {
            var pathSplitted = path.split('.');
            var prop = el;

            animatingShape = pathSplitted[0] === 'shape';
            for (var i = 0, l = pathSplitted.length; i < l; i++) {
                if (!prop) {
                    continue;
                }
                prop = prop[pathSplitted[i]];
            }
            if (prop) {
                target = prop;
            }
        } else {
            target = el;
        }

        if (!target) {
            Object(log["a" /* default */])('Property "' + path + '" is not existed in element ' + el.id);
            return;
        }

        var animators = el.animators;

        var animator = new Animator["a" /* default */](target, loop);

        animator.during(function (target) {
            el.dirty(animatingShape);
        }).done(function () {
            animators.splice(Object(util["n" /* indexOf */])(animators, animator), 1);
        });

        animators.push(animator);

        if (zr) {
            zr.animation.addAnimator(animator);
        }

        return animator;
    },

    stopAnimation: function stopAnimation(forwardToLast) {
        var animators = this.animators;
        var len = animators.length;
        for (var i = 0; i < len; i++) {
            animators[i].stop(forwardToLast);
        }
        animators.length = 0;

        return this;
    },

    animateTo: function animateTo(target, time, delay, easing, callback, forceAnimate) {
        if (Object(util["u" /* isString */])(delay)) {
            callback = easing;
            easing = delay;
            delay = 0;
        } else if (Object(util["s" /* isFunction */])(easing)) {
                callback = easing;
                easing = 'linear';
                delay = 0;
            } else if (Object(util["s" /* isFunction */])(delay)) {
                    callback = delay;
                    delay = 0;
                } else if (Object(util["s" /* isFunction */])(time)) {
                        callback = time;
                        time = 500;
                    } else if (!time) {
                            time = 500;
                        }

        this.stopAnimation();
        this._animateToShallow('', this, target, time, delay);

        var animators = this.animators.slice();
        var count = animators.length;
        function done() {
            count--;
            if (!count) {
                callback && callback();
            }
        }

        if (!count) {
            callback && callback();
        }

        for (var i = 0; i < animators.length; i++) {
            animators[i].done(done).start(easing, forceAnimate);
        }
    },

    _animateToShallow: function _animateToShallow(path, source, target, time, delay) {
        var objShallow = {};
        var propertyCount = 0;
        for (var name in target) {
            if (!target.hasOwnProperty(name)) {
                continue;
            }

            if (source[name] != null) {
                if (Object(util["t" /* isObject */])(target[name]) && !Object(util["q" /* isArrayLike */])(target[name])) {
                    this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
                } else {
                    objShallow[name] = target[name];
                    propertyCount++;
                }
            } else if (target[name] != null) {
                if (!path) {
                    this.attr(name, target[name]);
                } else {
                    var props = {};
                    props[path] = {};
                    props[path][name] = target[name];
                    this.attr(props);
                }
            }
        }

        if (propertyCount > 0) {
            this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
        }

        return this;
    }
};

/* harmony default export */ var mixin_Animatable = (Animatable);
// CONCATENATED MODULE: ./node_modules/zrender/src/Element.js






var Element_Element = function Element(opts) {

    Transformable["a" /* default */].call(this, opts);
    Eventful["a" /* default */].call(this, opts);
    mixin_Animatable.call(this, opts);

    this.id = opts.id || Object(guid["a" /* default */])();
};

Element_Element.prototype = {
    type: 'element',

    name: '',

    __zr: null,

    ignore: false,

    clipPath: null,

    drift: function drift(dx, dy) {
        switch (this.draggable) {
            case 'horizontal':
                dy = 0;
                break;
            case 'vertical':
                dx = 0;
                break;
        }

        var m = this.transform;
        if (!m) {
            m = this.transform = [1, 0, 0, 1, 0, 0];
        }
        m[4] += dx;
        m[5] += dy;

        this.decomposeTransform();
        this.dirty(false);
    },

    beforeUpdate: function beforeUpdate() {},

    afterUpdate: function afterUpdate() {},

    update: function update() {
        this.updateTransform();
    },

    traverse: function traverse(cb, context) {},

    attrKV: function attrKV(key, value) {
        if (key === 'position' || key === 'scale' || key === 'origin') {
            if (value) {
                var target = this[key];
                if (!target) {
                    target = this[key] = [];
                }
                target[0] = value[0];
                target[1] = value[1];
            }
        } else {
            this[key] = value;
        }
    },

    hide: function hide() {
        this.ignore = true;
        this.__zr && this.__zr.refresh();
    },

    show: function show() {
        this.ignore = false;
        this.__zr && this.__zr.refresh();
    },

    attr: function attr(key, value) {
        if (typeof key === 'string') {
            this.attrKV(key, value);
        } else if (util["t" /* isObject */](key)) {
            for (var name in key) {
                if (key.hasOwnProperty(name)) {
                    this.attrKV(name, key[name]);
                }
            }
        }

        this.dirty(false);

        return this;
    },

    setClipPath: function setClipPath(clipPath) {
        var zr = this.__zr;
        if (zr) {
            clipPath.addSelfToZr(zr);
        }

        if (this.clipPath && this.clipPath !== clipPath) {
            this.removeClipPath();
        }

        this.clipPath = clipPath;
        clipPath.__zr = zr;
        clipPath.__clipTarget = this;

        this.dirty(false);
    },

    removeClipPath: function removeClipPath() {
        var clipPath = this.clipPath;
        if (clipPath) {
            if (clipPath.__zr) {
                clipPath.removeSelfFromZr(clipPath.__zr);
            }

            clipPath.__zr = null;
            clipPath.__clipTarget = null;
            this.clipPath = null;

            this.dirty(false);
        }
    },

    addSelfToZr: function addSelfToZr(zr) {
        this.__zr = zr;

        var animators = this.animators;
        if (animators) {
            for (var i = 0; i < animators.length; i++) {
                zr.animation.addAnimator(animators[i]);
            }
        }

        if (this.clipPath) {
            this.clipPath.addSelfToZr(zr);
        }
    },

    removeSelfFromZr: function removeSelfFromZr(zr) {
        this.__zr = null;

        var animators = this.animators;
        if (animators) {
            for (var i = 0; i < animators.length; i++) {
                zr.animation.removeAnimator(animators[i]);
            }
        }

        if (this.clipPath) {
            this.clipPath.removeSelfFromZr(zr);
        }
    }
};

util["y" /* mixin */](Element_Element, mixin_Animatable);
util["y" /* mixin */](Element_Element, Transformable["a" /* default */]);
util["y" /* mixin */](Element_Element, Eventful["a" /* default */]);

/* harmony default export */ var src_Element = __webpack_exports__["a"] = (Element_Element);

/***/ }),

/***/ 93:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_matrix__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_vector__ = __webpack_require__(5);





var mIdentity = __WEBPACK_IMPORTED_MODULE_0__core_matrix__["c" /* identity */];

var EPSILON = 5e-5;

function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
}

var Transformable = function Transformable(opts) {
    opts = opts || {};

    if (!opts.position) {
        this.position = [0, 0];
    }
    if (opts.rotation == null) {
        this.rotation = 0;
    }
    if (!opts.scale) {
        this.scale = [1, 1];
    }

    this.origin = this.origin || null;
};

var transformableProto = Transformable.prototype;
transformableProto.transform = null;

transformableProto.needLocalTransform = function () {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
};

transformableProto.updateTransform = function () {
    var parent = this.parent;
    var parentHasTransform = parent && parent.transform;
    var needLocalTransform = this.needLocalTransform();

    var m = this.transform;
    if (!(needLocalTransform || parentHasTransform)) {
        m && mIdentity(m);
        return;
    }

    m = m || __WEBPACK_IMPORTED_MODULE_0__core_matrix__["b" /* create */]();

    if (needLocalTransform) {
        this.getLocalTransform(m);
    } else {
        mIdentity(m);
    }

    if (parentHasTransform) {
        if (needLocalTransform) {
            __WEBPACK_IMPORTED_MODULE_0__core_matrix__["e" /* mul */](m, parent.transform, m);
        } else {
            __WEBPACK_IMPORTED_MODULE_0__core_matrix__["a" /* copy */](m, parent.transform);
        }
    }

    this.transform = m;

    this.invTransform = this.invTransform || __WEBPACK_IMPORTED_MODULE_0__core_matrix__["b" /* create */]();
    __WEBPACK_IMPORTED_MODULE_0__core_matrix__["d" /* invert */](this.invTransform, m);
};

transformableProto.getLocalTransform = function (m) {
    return Transformable.getLocalTransform(this, m);
};

transformableProto.setTransform = function (ctx) {
    var m = this.transform;
    var dpr = ctx.dpr || 1;
    if (m) {
        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
    } else {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
};

transformableProto.restoreTransform = function (ctx) {
    var dpr = ctx.dpr || 1;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
};

var tmpTransform = [];

transformableProto.decomposeTransform = function () {
    if (!this.transform) {
        return;
    }
    var parent = this.parent;
    var m = this.transform;
    if (parent && parent.transform) {
        __WEBPACK_IMPORTED_MODULE_0__core_matrix__["e" /* mul */](tmpTransform, parent.invTransform, m);
        m = tmpTransform;
    }
    var sx = m[0] * m[0] + m[1] * m[1];
    var sy = m[2] * m[2] + m[3] * m[3];
    var position = this.position;
    var scale = this.scale;
    if (isNotAroundZero(sx - 1)) {
        sx = Math.sqrt(sx);
    }
    if (isNotAroundZero(sy - 1)) {
        sy = Math.sqrt(sy);
    }
    if (m[0] < 0) {
        sx = -sx;
    }
    if (m[3] < 0) {
        sy = -sy;
    }
    position[0] = m[4];
    position[1] = m[5];
    scale[0] = sx;
    scale[1] = sy;
    this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
};

transformableProto.getGlobalScale = function () {
    var m = this.transform;
    if (!m) {
        return [1, 1];
    }
    var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
    var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
    if (m[0] < 0) {
        sx = -sx;
    }
    if (m[3] < 0) {
        sy = -sy;
    }
    return [sx, sy];
};

transformableProto.transformCoordToLocal = function (x, y) {
    var v2 = [x, y];
    var invTransform = this.invTransform;
    if (invTransform) {
        __WEBPACK_IMPORTED_MODULE_1__core_vector__["b" /* applyTransform */](v2, v2, invTransform);
    }
    return v2;
};

transformableProto.transformCoordToGlobal = function (x, y) {
    var v2 = [x, y];
    var transform = this.transform;
    if (transform) {
        __WEBPACK_IMPORTED_MODULE_1__core_vector__["b" /* applyTransform */](v2, v2, transform);
    }
    return v2;
};

Transformable.getLocalTransform = function (target, m) {
    m = m || [];
    mIdentity(m);

    var origin = target.origin;
    var scale = target.scale || [1, 1];
    var rotation = target.rotation || 0;
    var position = target.position || [0, 0];

    if (origin) {
        m[4] -= origin[0];
        m[5] -= origin[1];
    }
    __WEBPACK_IMPORTED_MODULE_0__core_matrix__["g" /* scale */](m, m, scale);
    if (rotation) {
        __WEBPACK_IMPORTED_MODULE_0__core_matrix__["f" /* rotate */](m, m, rotation);
    }
    if (origin) {
        m[4] += origin[0];
        m[5] += origin[1];
    }

    m[4] += position[0];
    m[5] += position[1];

    return m;
};

/* harmony default export */ __webpack_exports__["a"] = (Transformable);

/***/ }),

/***/ 94:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/zrender/src/animation/easing.js

var easing_easing = {
    linear: function linear(k) {
        return k;
    },

    quadraticIn: function quadraticIn(k) {
        return k * k;
    },

    quadraticOut: function quadraticOut(k) {
        return k * (2 - k);
    },

    quadraticInOut: function quadraticInOut(k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
    },

    cubicIn: function cubicIn(k) {
        return k * k * k;
    },

    cubicOut: function cubicOut(k) {
        return --k * k * k + 1;
    },

    cubicInOut: function cubicInOut(k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
    },

    quarticIn: function quarticIn(k) {
        return k * k * k * k;
    },

    quarticOut: function quarticOut(k) {
        return 1 - --k * k * k * k;
    },

    quarticInOut: function quarticInOut(k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
    },

    quinticIn: function quinticIn(k) {
        return k * k * k * k * k;
    },

    quinticOut: function quinticOut(k) {
        return --k * k * k * k * k + 1;
    },

    quinticInOut: function quinticInOut(k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
    },

    sinusoidalIn: function sinusoidalIn(k) {
        return 1 - Math.cos(k * Math.PI / 2);
    },

    sinusoidalOut: function sinusoidalOut(k) {
        return Math.sin(k * Math.PI / 2);
    },

    sinusoidalInOut: function sinusoidalInOut(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
    },

    exponentialIn: function exponentialIn(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
    },

    exponentialOut: function exponentialOut(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    },

    exponentialInOut: function exponentialInOut(k) {
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if ((k *= 2) < 1) {
            return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    },

    circularIn: function circularIn(k) {
        return 1 - Math.sqrt(1 - k * k);
    },

    circularOut: function circularOut(k) {
        return Math.sqrt(1 - --k * k);
    },

    circularInOut: function circularInOut(k) {
        if ((k *= 2) < 1) {
            return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },

    elasticIn: function elasticIn(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (!a || a < 1) {
            a = 1;s = p / 4;
        } else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    },

    elasticOut: function elasticOut(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (!a || a < 1) {
            a = 1;s = p / 4;
        } else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
    },

    elasticInOut: function elasticInOut(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (!a || a < 1) {
            a = 1;s = p / 4;
        } else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        if ((k *= 2) < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
    },

    backIn: function backIn(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
    },

    backOut: function backOut(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
    },

    backInOut: function backInOut(k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) {
            return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },

    bounceIn: function bounceIn(k) {
        return 1 - easing_easing.bounceOut(1 - k);
    },

    bounceOut: function bounceOut(k) {
        if (k < 1 / 2.75) {
            return 7.5625 * k * k;
        } else if (k < 2 / 2.75) {
            return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
        } else if (k < 2.5 / 2.75) {
            return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
        } else {
            return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        }
    },

    bounceInOut: function bounceInOut(k) {
        if (k < 0.5) {
            return easing_easing.bounceIn(k * 2) * 0.5;
        }
        return easing_easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
    }
};

/* harmony default export */ var animation_easing = (easing_easing);
// CONCATENATED MODULE: ./node_modules/zrender/src/animation/Clip.js




function Clip(options) {

    this._target = options.target;

    this._life = options.life || 1000;

    this._delay = options.delay || 0;

    this._initialized = false;

    this.loop = options.loop == null ? false : options.loop;

    this.gap = options.gap || 0;

    this.easing = options.easing || 'Linear';

    this.onframe = options.onframe;
    this.ondestroy = options.ondestroy;
    this.onrestart = options.onrestart;

    this._pausedTime = 0;
    this._paused = false;
}

Clip.prototype = {

    constructor: Clip,

    step: function step(globalTime, deltaTime) {
        if (!this._initialized) {
            this._startTime = globalTime + this._delay;
            this._initialized = true;
        }

        if (this._paused) {
            this._pausedTime += deltaTime;
            return;
        }

        var percent = (globalTime - this._startTime - this._pausedTime) / this._life;

        if (percent < 0) {
            return;
        }

        percent = Math.min(percent, 1);

        var easing = this.easing;
        var easingFunc = typeof easing == 'string' ? animation_easing[easing] : easing;
        var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;

        this.fire('frame', schedule);

        if (percent == 1) {
            if (this.loop) {
                this.restart(globalTime);

                return 'restart';
            }

            this._needsRemove = true;
            return 'destroy';
        }

        return null;
    },

    restart: function restart(globalTime) {
        var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
        this._startTime = globalTime - remainder + this.gap;
        this._pausedTime = 0;

        this._needsRemove = false;
    },

    fire: function fire(eventType, arg) {
        eventType = 'on' + eventType;
        if (this[eventType]) {
            this[eventType](this._target, arg);
        }
    },

    pause: function pause() {
        this._paused = true;
    },

    resume: function resume() {
        this._paused = false;
    }
};

/* harmony default export */ var animation_Clip = (Clip);
// EXTERNAL MODULE: ./node_modules/zrender/src/tool/color.js
var color = __webpack_require__(40);

// EXTERNAL MODULE: ./node_modules/zrender/src/core/util.js
var util = __webpack_require__(0);

// CONCATENATED MODULE: ./node_modules/zrender/src/animation/Animator.js






var arraySlice = Array.prototype.slice;

function defaultGetter(target, key) {
    return target[key];
}

function defaultSetter(target, key, value) {
    target[key] = value;
}

function interpolateNumber(p0, p1, percent) {
    return (p1 - p0) * percent + p0;
}

function interpolateString(p0, p1, percent) {
    return percent > 0.5 ? p1 : p0;
}

function interpolateArray(p0, p1, percent, out, arrDim) {
    var len = p0.length;
    if (arrDim == 1) {
        for (var i = 0; i < len; i++) {
            out[i] = interpolateNumber(p0[i], p1[i], percent);
        }
    } else {
        var len2 = len && p0[0].length;
        for (var i = 0; i < len; i++) {
            for (var j = 0; j < len2; j++) {
                out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
            }
        }
    }
}

function fillArr(arr0, arr1, arrDim) {
    var arr0Len = arr0.length;
    var arr1Len = arr1.length;
    if (arr0Len !== arr1Len) {
        var isPreviousLarger = arr0Len > arr1Len;
        if (isPreviousLarger) {
            arr0.length = arr1Len;
        } else {
            for (var i = arr0Len; i < arr1Len; i++) {
                arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
            }
        }
    }

    var len2 = arr0[0] && arr0[0].length;
    for (var i = 0; i < arr0.length; i++) {
        if (arrDim === 1) {
            if (isNaN(arr0[i])) {
                arr0[i] = arr1[i];
            }
        } else {
            for (var j = 0; j < len2; j++) {
                if (isNaN(arr0[i][j])) {
                    arr0[i][j] = arr1[i][j];
                }
            }
        }
    }
}

function isArraySame(arr0, arr1, arrDim) {
    if (arr0 === arr1) {
        return true;
    }
    var len = arr0.length;
    if (len !== arr1.length) {
        return false;
    }
    if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
            if (arr0[i] !== arr1[i]) {
                return false;
            }
        }
    } else {
        var len2 = arr0[0].length;
        for (var i = 0; i < len; i++) {
            for (var j = 0; j < len2; j++) {
                if (arr0[i][j] !== arr1[i][j]) {
                    return false;
                }
            }
        }
    }
    return true;
}

function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
    var len = p0.length;
    if (arrDim == 1) {
        for (var i = 0; i < len; i++) {
            out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
        }
    } else {
        var len2 = p0[0].length;
        for (var i = 0; i < len; i++) {
            for (var j = 0; j < len2; j++) {
                out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
            }
        }
    }
}

function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
}

function cloneValue(value) {
    if (Object(util["q" /* isArrayLike */])(value)) {
        var len = value.length;
        if (Object(util["q" /* isArrayLike */])(value[0])) {
            var ret = [];
            for (var i = 0; i < len; i++) {
                ret.push(arraySlice.call(value[i]));
            }
            return ret;
        }

        return arraySlice.call(value);
    }

    return value;
}

function rgba2String(rgba) {
    rgba[0] = Math.floor(rgba[0]);
    rgba[1] = Math.floor(rgba[1]);
    rgba[2] = Math.floor(rgba[2]);

    return 'rgba(' + rgba.join(',') + ')';
}

function getArrayDim(keyframes) {
    var lastValue = keyframes[keyframes.length - 1].value;
    return Object(util["q" /* isArrayLike */])(lastValue && lastValue[0]) ? 2 : 1;
}

function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
    var getter = animator._getter;
    var setter = animator._setter;
    var useSpline = easing === 'spline';

    var trackLen = keyframes.length;
    if (!trackLen) {
        return;
    }

    var firstVal = keyframes[0].value;
    var isValueArray = Object(util["q" /* isArrayLike */])(firstVal);
    var isValueColor = false;
    var isValueString = false;

    var arrDim = isValueArray ? getArrayDim(keyframes) : 0;

    var trackMaxTime;

    keyframes.sort(function (a, b) {
        return a.time - b.time;
    });

    trackMaxTime = keyframes[trackLen - 1].time;

    var kfPercents = [];

    var kfValues = [];
    var prevValue = keyframes[0].value;
    var isAllValueEqual = true;
    for (var i = 0; i < trackLen; i++) {
        kfPercents.push(keyframes[i].time / trackMaxTime);

        var value = keyframes[i].value;

        if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
            isAllValueEqual = false;
        }
        prevValue = value;

        if (typeof value == 'string') {
            var colorArray = color["b" /* parse */](value);
            if (colorArray) {
                value = colorArray;
                isValueColor = true;
            } else {
                isValueString = true;
            }
        }
        kfValues.push(value);
    }
    if (!forceAnimate && isAllValueEqual) {
        return;
    }

    var lastValue = kfValues[trackLen - 1];

    for (var i = 0; i < trackLen - 1; i++) {
        if (isValueArray) {
            fillArr(kfValues[i], lastValue, arrDim);
        } else {
            if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
                kfValues[i] = lastValue;
            }
        }
    }
    isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);

    var lastFrame = 0;
    var lastFramePercent = 0;
    var start;
    var w;
    var p0;
    var p1;
    var p2;
    var p3;

    if (isValueColor) {
        var rgba = [0, 0, 0, 0];
    }

    var onframe = function onframe(target, percent) {
        var frame;

        if (percent < 0) {
            frame = 0;
        } else if (percent < lastFramePercent) {
            start = Math.min(lastFrame + 1, trackLen - 1);
            for (frame = start; frame >= 0; frame--) {
                if (kfPercents[frame] <= percent) {
                    break;
                }
            }

            frame = Math.min(frame, trackLen - 2);
        } else {
            for (frame = lastFrame; frame < trackLen; frame++) {
                if (kfPercents[frame] > percent) {
                    break;
                }
            }
            frame = Math.min(frame - 1, trackLen - 2);
        }
        lastFrame = frame;
        lastFramePercent = percent;

        var range = kfPercents[frame + 1] - kfPercents[frame];
        if (range === 0) {
            return;
        } else {
            w = (percent - kfPercents[frame]) / range;
        }
        if (useSpline) {
            p1 = kfValues[frame];
            p0 = kfValues[frame === 0 ? frame : frame - 1];
            p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
            p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
            if (isValueArray) {
                catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
            } else {
                var value;
                if (isValueColor) {
                    value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
                    value = rgba2String(rgba);
                } else if (isValueString) {
                    return interpolateString(p1, p2, w);
                } else {
                    value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
                }
                setter(target, propName, value);
            }
        } else {
            if (isValueArray) {
                interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
            } else {
                var value;
                if (isValueColor) {
                    interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
                    value = rgba2String(rgba);
                } else if (isValueString) {
                    return interpolateString(kfValues[frame], kfValues[frame + 1], w);
                } else {
                    value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
                }
                setter(target, propName, value);
            }
        }
    };

    var clip = new animation_Clip({
        target: animator._target,
        life: trackMaxTime,
        loop: animator._loop,
        delay: animator._delay,
        onframe: onframe,
        ondestroy: oneTrackDone
    });

    if (easing && easing !== 'spline') {
        clip.easing = easing;
    }

    return clip;
}

var Animator = function Animator(target, loop, getter, setter) {
    this._tracks = {};
    this._target = target;

    this._loop = loop || false;

    this._getter = getter || defaultGetter;
    this._setter = setter || defaultSetter;

    this._clipCount = 0;

    this._delay = 0;

    this._doneList = [];

    this._onframeList = [];

    this._clipList = [];
};

Animator.prototype = {
    when: function when(time, props) {
        var tracks = this._tracks;
        for (var propName in props) {
            if (!props.hasOwnProperty(propName)) {
                continue;
            }

            if (!tracks[propName]) {
                tracks[propName] = [];

                var value = this._getter(this._target, propName);
                if (value == null) {
                    continue;
                }

                if (time !== 0) {
                    tracks[propName].push({
                        time: 0,
                        value: cloneValue(value)
                    });
                }
            }
            tracks[propName].push({
                time: time,
                value: props[propName]
            });
        }
        return this;
    },

    during: function during(callback) {
        this._onframeList.push(callback);
        return this;
    },

    pause: function pause() {
        for (var i = 0; i < this._clipList.length; i++) {
            this._clipList[i].pause();
        }
        this._paused = true;
    },

    resume: function resume() {
        for (var i = 0; i < this._clipList.length; i++) {
            this._clipList[i].resume();
        }
        this._paused = false;
    },

    isPaused: function isPaused() {
        return !!this._paused;
    },

    _doneCallback: function _doneCallback() {
        this._tracks = {};

        this._clipList.length = 0;

        var doneList = this._doneList;
        var len = doneList.length;
        for (var i = 0; i < len; i++) {
            doneList[i].call(this);
        }
    },

    start: function start(easing, forceAnimate) {

        var self = this;
        var clipCount = 0;

        var oneTrackDone = function oneTrackDone() {
            clipCount--;
            if (!clipCount) {
                self._doneCallback();
            }
        };

        var lastClip;
        for (var propName in this._tracks) {
            if (!this._tracks.hasOwnProperty(propName)) {
                continue;
            }
            var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);
            if (clip) {
                this._clipList.push(clip);
                clipCount++;

                if (this.animation) {
                    this.animation.addClip(clip);
                }

                lastClip = clip;
            }
        }

        if (lastClip) {
            var oldOnFrame = lastClip.onframe;
            lastClip.onframe = function (target, percent) {
                oldOnFrame(target, percent);

                for (var i = 0; i < self._onframeList.length; i++) {
                    self._onframeList[i](target, percent);
                }
            };
        }

        if (!clipCount) {
            this._doneCallback();
        }
        return this;
    },

    stop: function stop(forwardToLast) {
        var clipList = this._clipList;
        var animation = this.animation;
        for (var i = 0; i < clipList.length; i++) {
            var clip = clipList[i];
            if (forwardToLast) {
                clip.onframe(this._target, 1);
            }
            animation && animation.removeClip(clip);
        }
        clipList.length = 0;
    },

    delay: function delay(time) {
        this._delay = time;
        return this;
    },

    done: function done(cb) {
        if (cb) {
            this._doneList.push(cb);
        }
        return this;
    },

    getClips: function getClips() {
        return this._clipList;
    }
};

/* harmony default export */ var animation_Animator = __webpack_exports__["a"] = (Animator);

/***/ }),

/***/ 95:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var LinkedList = function LinkedList() {
    this.head = null;

    this.tail = null;

    this._len = 0;
};

var linkedListProto = LinkedList.prototype;

linkedListProto.insert = function (val) {
    var entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
};

linkedListProto.insertEntry = function (entry) {
    if (!this.head) {
        this.head = this.tail = entry;
    } else {
        this.tail.next = entry;
        entry.prev = this.tail;
        entry.next = null;
        this.tail = entry;
    }
    this._len++;
};

linkedListProto.remove = function (entry) {
    var prev = entry.prev;
    var next = entry.next;
    if (prev) {
        prev.next = next;
    } else {
        this.head = next;
    }
    if (next) {
        next.prev = prev;
    } else {
        this.tail = prev;
    }
    entry.next = entry.prev = null;
    this._len--;
};

linkedListProto.len = function () {
    return this._len;
};

linkedListProto.clear = function () {
    this.head = this.tail = null;
    this._len = 0;
};

var Entry = function Entry(val) {
    this.value = val;

    this.next;

    this.prev;
};

var LRU = function LRU(maxSize) {

    this._list = new LinkedList();

    this._map = {};

    this._maxSize = maxSize || 10;

    this._lastRemovedEntry = null;
};

var LRUProto = LRU.prototype;

LRUProto.put = function (key, value) {
    var list = this._list;
    var map = this._map;
    var removed = null;
    if (map[key] == null) {
        var len = list.len();

        var entry = this._lastRemovedEntry;

        if (len >= this._maxSize && len > 0) {
            var leastUsedEntry = list.head;
            list.remove(leastUsedEntry);
            delete map[leastUsedEntry.key];

            removed = leastUsedEntry.value;
            this._lastRemovedEntry = leastUsedEntry;
        }

        if (entry) {
            entry.value = value;
        } else {
            entry = new Entry(value);
        }
        entry.key = key;
        list.insertEntry(entry);
        map[key] = entry;
    }

    return removed;
};

LRUProto.get = function (key) {
    var entry = this._map[key];
    var list = this._list;
    if (entry != null) {
        if (entry !== list.tail) {
            list.remove(entry);
            list.insertEntry(entry);
        }

        return entry.value;
    }
};

LRUProto.clear = function () {
    this._list.clear();
    this._map = {};
};

/* harmony default export */ __webpack_exports__["a"] = (LRU);

/***/ }),

/***/ 96:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(41);


var log = function log() {};

if (__WEBPACK_IMPORTED_MODULE_0__config__["a" /* debugMode */] === 1) {
    log = function log() {
        for (var k in arguments) {
            throw new Error(arguments[k]);
        }
    };
} else if (__WEBPACK_IMPORTED_MODULE_0__config__["a" /* debugMode */] > 1) {
    log = function log() {
        for (var k in arguments) {
            console.log(arguments[k]);
        }
    };
}

/* harmony default export */ __webpack_exports__["a"] = (log);

/***/ }),

/***/ 97:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]];

var Style = function Style(opts, host) {
  this.extendFrom(opts, false);
  this.host = host;
};

function createLinearGradient(ctx, obj, rect) {
  var x = obj.x == null ? 0 : obj.x;
  var x2 = obj.x2 == null ? 1 : obj.x2;
  var y = obj.y == null ? 0 : obj.y;
  var y2 = obj.y2 == null ? 0 : obj.y2;

  if (!obj.global) {
    x = x * rect.width + rect.x;
    x2 = x2 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  }

  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);

  return canvasGradient;
}

function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min = Math.min(width, height);

  var x = obj.x == null ? 0.5 : obj.x;
  var y = obj.y == null ? 0.5 : obj.y;
  var r = obj.r == null ? 0.5 : obj.r;
  if (!obj.global) {
    x = x * width + rect.x;
    y = y * height + rect.y;
    r = r * min;
  }

  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);

  return canvasGradient;
}

Style.prototype = {

  constructor: Style,

  host: null,

  fill: '#000',

  stroke: null,

  opacity: 1,

  lineDash: null,

  lineDashOffset: 0,

  shadowBlur: 0,

  shadowOffsetX: 0,

  shadowOffsetY: 0,

  lineWidth: 1,

  strokeNoScale: false,

  text: null,

  font: null,

  textFont: null,

  fontStyle: null,

  fontWeight: null,

  fontSize: null,

  fontFamily: null,

  textTag: null,

  textFill: '#000',

  textStroke: null,

  textWidth: null,

  textHeight: null,

  textStrokeWidth: 0,

  textLineHeight: null,

  textPosition: 'inside',

  textRect: null,

  textOffset: null,

  textAlign: null,

  textVerticalAlign: null,

  textDistance: 5,

  textShadowColor: 'transparent',

  textShadowBlur: 0,

  textShadowOffsetX: 0,

  textShadowOffsetY: 0,

  textBoxShadowColor: 'transparent',

  textBoxShadowBlur: 0,

  textBoxShadowOffsetX: 0,

  textBoxShadowOffsetY: 0,

  transformText: false,

  textRotation: 0,

  textOrigin: null,

  textBackgroundColor: null,

  textBorderColor: null,

  textBorderWidth: 0,

  textBorderRadius: 0,

  textPadding: null,

  rich: null,

  truncate: null,

  blend: null,

  bind: function bind(ctx, el, prevEl) {
    var style = this;
    var prevStyle = prevEl && prevEl.style;
    var firstDraw = !prevStyle;

    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      var prop = STYLE_COMMON_PROPS[i];
      var styleName = prop[0];

      if (firstDraw || style[styleName] !== prevStyle[styleName]) {
        ctx[styleName] = style[styleName] || prop[1];
      }
    }

    if (firstDraw || style.fill !== prevStyle.fill) {
      ctx.fillStyle = style.fill;
    }
    if (firstDraw || style.stroke !== prevStyle.stroke) {
      ctx.strokeStyle = style.stroke;
    }
    if (firstDraw || style.opacity !== prevStyle.opacity) {
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }

    if (firstDraw || style.blend !== prevStyle.blend) {
      ctx.globalCompositeOperation = style.blend || 'source-over';
    }
    if (this.hasStroke()) {
      var lineWidth = style.lineWidth;
      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
    }
  },

  hasFill: function hasFill() {
    var fill = this.fill;
    return fill != null && fill !== 'none';
  },

  hasStroke: function hasStroke() {
    var stroke = this.stroke;
    return stroke != null && stroke !== 'none' && this.lineWidth > 0;
  },

  extendFrom: function extendFrom(otherStyle, overwrite) {
    if (otherStyle) {
      for (var name in otherStyle) {
        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
          this[name] = otherStyle[name];
        }
      }
    }
  },

  set: function set(obj, value) {
    if (typeof obj === 'string') {
      this[obj] = value;
    } else {
      this.extendFrom(obj, true);
    }
  },

  clone: function clone() {
    var newStyle = new this.constructor();
    newStyle.extendFrom(this, true);
    return newStyle;
  },

  getGradient: function getGradient(ctx, obj, rect) {
    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
    var canvasGradient = method(ctx, obj, rect);
    var colorStops = obj.colorStops;
    for (var i = 0; i < colorStops.length; i++) {
      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
    }
    return canvasGradient;
  }

};

var styleProto = Style.prototype;
for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
  var prop = STYLE_COMMON_PROPS[i];
  if (!(prop[0] in styleProto)) {
    styleProto[prop[0]] = prop[1];
  }
}

Style.getGradient = styleProto.getGradient;

/* harmony default export */ __webpack_exports__["a"] = (Style);

/***/ }),

/***/ 98:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var Pattern = function Pattern(image, repeat) {

    this.image = image;
    this.repeat = repeat;

    this.type = 'pattern';
};

Pattern.prototype.getCanvasPattern = function (ctx) {
    return ctx.createPattern(this.image, this.repeat || 'repeat');
};

/* harmony default export */ __webpack_exports__["a"] = (Pattern);

/***/ }),

/***/ 99:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Displayable__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_BoundingRect__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helper_image__ = __webpack_require__(57);





function ZImage(opts) {
    __WEBPACK_IMPORTED_MODULE_0__Displayable__["a" /* default */].call(this, opts);
}

ZImage.prototype = {

    constructor: ZImage,

    type: 'image',

    brush: function brush(ctx, prevEl) {
        var style = this.style;
        var src = style.image;

        style.bind(ctx, this, prevEl);

        var image = this._image = __WEBPACK_IMPORTED_MODULE_3__helper_image__["a" /* createOrUpdateImage */](src, this._image, this, this.onload);

        if (!image || !__WEBPACK_IMPORTED_MODULE_3__helper_image__["c" /* isImageReady */](image)) {
            return;
        }

        var x = style.x || 0;
        var y = style.y || 0;
        var width = style.width;
        var height = style.height;
        var aspect = image.width / image.height;
        if (width == null && height != null) {
            width = height * aspect;
        } else if (height == null && width != null) {
            height = width / aspect;
        } else if (width == null && height == null) {
            width = image.width;
            height = image.height;
        }

        this.setTransform(ctx);

        if (style.sWidth && style.sHeight) {
            var sx = style.sx || 0;
            var sy = style.sy || 0;
            ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
        } else if (style.sx && style.sy) {
            var sx = style.sx;
            var sy = style.sy;
            var sWidth = width - sx;
            var sHeight = height - sy;
            ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
        } else {
            ctx.drawImage(image, x, y, width, height);
        }

        this.restoreTransform(ctx);

        if (style.text != null) {
            this.drawRectText(ctx, this.getBoundingRect());
        }
    },

    getBoundingRect: function getBoundingRect() {
        var style = this.style;
        if (!this._rect) {
            this._rect = new __WEBPACK_IMPORTED_MODULE_1__core_BoundingRect__["a" /* default */](style.x || 0, style.y || 0, style.width || 0, style.height || 0);
        }
        return this._rect;
    }
};

__WEBPACK_IMPORTED_MODULE_2__core_util__["o" /* inherits */](ZImage, __WEBPACK_IMPORTED_MODULE_0__Displayable__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (ZImage);

/***/ })

},[226]);
//# sourceMappingURL=charts.min.js.map